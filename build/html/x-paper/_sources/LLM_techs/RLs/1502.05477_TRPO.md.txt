# ❇️1502.05477_TRPO: Trust Region Policy Optimization

* 首页: <https://arxiv.org/abs/1502.05477>
* PDF: <https://arxiv.org/pdf/1502.05477>
* 引用: 10726(2025-11-15)
* 组织: 
    * University of California, Berkeley



## 总结

**策略优化算法**
1. **策略迭代方法**：通过交替估计当前策略下的价值函数和改进策略来优化策略
2. **策略梯度方法**：利用从样本轨迹中估计的回报梯度进行优化
3. **无导数优化方法**：如交叉熵方法（CEM）和协方差矩阵自适应（CMA），将回报视为黑箱函数，直接对策略参数进行优化

**主要贡献**
* 证明了最小化某个代理目标函数可以保证策略改进，即使在非小步长下
* 过对理论算法进行一系列近似，提出了实用的策略优化算法TRPO
* TRPO有两个变体：
    * 单路径方法：适用于无模型（model-free）设置；
    * 藤蔓方法（vine method）：需要系统能回退到特定状态，通常仅适用于模拟环境；

**TRPO**
* 核心思想是通过信任区域方法保证策略改进
* 解决了传统策略梯度方法和无导数方法在样本效率和稳定性之间的权衡问题



## Abstract


本节介绍了**TRPO（Trust Region Policy Optimization，信任区域策略优化）**算法的核心思想和优势。

- **核心方法**：提出了一种**迭代策略优化方法**，理论上保证了策略的**单调改进**（即每一步更新都不会使策略变差）。
- **实际应用**：在理论方法的基础上进行了若干近似，得到了一个**实用的算法 TRPO**。该算法与**自然策略梯度方法**类似，适用于优化**大规模非线性策略**，如神经网络。
- **实验效果**：TRPO 在多种任务中表现出色，包括：
  - 学习模拟机器人游泳、跳跃和行走的步态；
  - 使用屏幕图像作为输入玩 Atari 游戏。
- **优势与特点**：尽管 TRPO 引入了一些理论上的近似，但它依然能实现**稳定的性能提升**，且**超参数调优需求较少**，具有良好的实用性与鲁棒性。

✅ **重点内容**：TRPO 的设计目标是实现策略的稳定提升，适用于复杂策略（如深度神经网络），并且在多种任务中表现良好。


## 1 Introduction

本节介绍了策略优化算法的三大类方法：

1. **策略迭代方法**：通过交替估计当前策略下的价值函数和改进策略来优化策略（参考Bertsekas, 2005）；
2. **策略梯度方法**：利用从样本轨迹中估计的回报梯度进行优化（Peters & Schaal, 2008a），文中指出这类方法与策略迭代有密切联系；
3. **无导数优化方法**：如交叉熵方法（CEM）和协方差矩阵自适应（CMA），将回报视为黑箱函数，直接对策略参数进行优化（Szita & Lörincz, 2006）。

接着，文章强调了**无导数随机优化方法**（如CEM和CMA）在许多任务中的优势，因为它们实现简单且效果良好。例如，在Tetris游戏任务中，尽管它是近似动态规划（ADP）的经典测试平台，但随机优化方法表现更优；在连续控制任务中，如运动控制，CMA等方法在低维手工设计策略参数空间中也取得了成功（Wampler & Popović, 2009）。

然而，文章指出，ADP和基于梯度的方法在样本效率理论上优于无梯度方法（Nemirovski, 2005），因此其表现不如无梯度方法是令人不满意的。同时，梯度优化在监督学习中已成功训练了具有大量参数的函数逼近器，将其扩展到强化学习有助于高效训练复杂策略。

最后，文章概述了本文的主要贡献：

- 首先，**证明了最小化某个代理目标函数可以保证策略改进**，即使在非小步长下；
- 然后，通过对理论算法进行一系列近似，提出了**实用的策略优化算法TRPO**（Trust Region Policy Optimization）；
- TRPO有两个变体：
  - **单路径方法**：适用于无模型（model-free）设置；
  - **藤蔓方法**（vine method）：需要系统能回退到特定状态，通常仅适用于模拟环境；
- 该算法具有良好的可扩展性，能够优化具有数万个参数的非线性策略（这在以往的无模型策略搜索中是重大挑战）；
- 实验表明，TRPO可以成功学习复杂的任务策略，如游泳、跳跃、行走，以及从原始图像中玩Atari游戏。

**重点内容强调**：
- TRPO的核心思想是通过信任区域方法保证策略改进；
- 它解决了传统策略梯度方法和无导数方法在样本效率和稳定性之间的权衡问题；
- TRPO能够处理高维非线性策略，是强化学习策略优化的重要进展。


## 2 Preliminaries


### 2.1 MDP 定义与策略

本节首先定义了一个**无限时间折扣马尔可夫决策过程（MDP）**，其由元组 $(\mathcal{S}, \mathcal{A}, P, r, \rho_0, \gamma)$ 组成，其中：

- $\mathcal{S}$：有限状态集合  
- $\mathcal{A}$：有限动作集合  
- $P(s' | s, a)$：状态转移概率  
- $r(s)$：状态奖励函数  
- $\rho_0(s)$：初始状态分布  
- $\gamma \in (0,1)$：折扣因子  

接着定义了一个**随机策略** $\pi(a|s)$，并定义其期望折扣回报为：

$$
\eta(\pi) = \mathbb{E}_{s_0,a_0,\dots} \left[ \sum_{t=0}^{\infty} \gamma^t r(s_t) \right]
$$

其中 $s_0 \sim \rho_0, a_t \sim \pi(a_t|s_t), s_{t+1} \sim P(s_{t+1}|s_t, a_t)$。

### 2.2 值函数与优势函数

定义了以下三个关键函数：

- **状态-动作值函数**：
  $$
  Q_\pi(s_t, a_t) = \mathbb{E}_{s_{t+1},a_{t+1},\dots} \left[ \sum_{l=0}^{\infty} \gamma^l r(s_{t+l}) \right]
  $$

- **状态值函数**：
  $$
  V_\pi(s_t) = \mathbb{E}_{a_t,s_{t+1},\dots} \left[ \sum_{l=0}^{\infty} \gamma^l r(s_{t+l}) \right]
  $$

- **优势函数**：
  $$
  A_\pi(s, a) = Q_\pi(s, a) - V_\pi(s)
  $$

这些函数用于衡量策略在不同状态和动作下的表现。

### 2.3 策略更新的期望回报关系

给出一个关键公式，表示新策略 $\tilde{\pi}$ 的期望回报与旧策略 $\pi$ 的关系：

$$
\eta(\tilde{\pi}) = \eta(\pi) + \mathbb{E}_{s_0,a_0,\dots \sim \tilde{\pi}} \left[ \sum_{t=0}^{\infty} \gamma^t A_\pi(s_t, a_t) \right]
$$

该式说明策略更新的收益可以由旧策略下的优势函数来衡量。

进一步引入**折扣状态访问频率** $\rho_\pi(s)$，表示策略 $\pi$ 下各状态的加权访问次数：

$$
\rho_\pi(s) = P(s_0=s) + \gamma P(s_1=s) + \gamma^2 P(s_2=s) + \dots
$$

从而将策略更新的收益表达为状态空间上的求和形式：

$$
\eta(\tilde{\pi}) = \eta(\pi) + \sum_s \rho_{\tilde{\pi}}(s) \sum_a \tilde{\pi}(a|s) A_\pi(s, a)
$$

这个公式说明：只要新策略在每个状态的**期望优势**非负，就能保证性能提升。

### 2.4 局部近似函数 $L_\pi(\tilde{\pi})$

由于 $\rho_{\tilde{\pi}}(s)$ 依赖于新策略 $\tilde{\pi}$，直接优化上式较难。因此引入一个**局部线性近似函数**：

$$
L_\pi(\tilde{\pi}) = \eta(\pi) + \sum_s \rho_\pi(s) \sum_a \tilde{\pi}(a|s) A_\pi(s, a)
$$

它使用旧策略的访问频率 $\rho_\pi(s)$，忽略策略变化带来的状态分布变化。

对于参数化策略 $\pi_\theta$，该近似函数满足：

- $L_{\pi_{\theta_0}}(\pi_{\theta_0}) = \eta(\pi_{\theta_0})$
- $\nabla_\theta L_{\pi_{\theta_0}}(\pi_\theta)|_{\theta=\theta_0} = \nabla_\theta \eta(\pi_\theta)|_{\theta=\theta_0}$

这说明 $L_\pi$ 在局部与 $\eta$ 一阶一致，因此在局部优化 $L_\pi$ 可以提升 $\eta$。

### 2.5 保守策略迭代（Conservative Policy Iteration）

Kakade & Langford 提出了一种策略更新方法，称为**保守策略迭代**。其更新形式为：

$$
\pi_{\text{new}}(a|s) = (1-\alpha)\pi_{\text{old}}(a|s) + \alpha \pi'(a|s)
$$

其中 $\pi' = \arg\max_{\pi'} L_{\pi_{\text{old}}}(\pi')$ 是局部最优策略。

并给出一个性能下界：

$$
\eta(\pi_{\text{new}}) \geq L_{\pi_{\text{old}}}(\pi_{\text{new}}) - \frac{2\epsilon\gamma}{(1-\gamma)^2} \alpha^2
$$

其中 $\epsilon = \max_s \left| \mathbb{E}_{a \sim \pi'}[A_{\pi}(s,a)] \right|$

这个下界说明：只要混合系数 $\alpha$ 足够小，就能保证策略提升。

### 重点总结：

- **核心思想**：通过优势函数衡量策略更新的收益，使用局部近似函数 $L_\pi$ 来指导策略更新。
- **理论保证**：保守策略迭代在特定混合策略下能提供性能下界，确保策略提升。
- **局限性**：该方法仅适用于特定混合策略类，不适用于更一般的策略更新形式，因此需要更通用的策略优化方法（TRPO 的动机）。


## 3 Monotonic Improvement Guarantee for General Stochastic Policies


### 核心理论扩展

在保守策略迭代中，[公式6](#S2.E6) 表明只要改进其右侧，就能保证真实性能 η 的提升。本节的主要理论成果是将这一改进保证扩展到**一般随机策略**，而不仅限于混合策略。这一扩展通过使用策略 π 和 π̃ 之间的**总变差散度**（Total Variation Divergence）代替 α，并适当调整常数 ϵ 来实现。

由于混合策略在实际中很少使用，因此这一扩展对于将理论保证应用到实际问题至关重要。

---

### 总变差散度定义

总变差散度定义为：

$$
D_{TV}(p\|\ q) = \frac{1}{2} \sum_i |p_i - q_i|
$$

用于衡量两个离散概率分布之间的差异。文中进一步定义：

$$
D^{\rm max}_{TV}(\pi, \tilde{\pi}) = \max_s D_{TV}(\pi(\cdot|s)\ \|\ \tilde{\pi}(\cdot|s))
$$

即在所有状态 s 中，策略 π 和 π̃ 在动作分布上的最大总变差。

---

### 定理1：改进下界

设 α = D^max_TV(π_old, π_new)，则有：

$$
\eta(\pi_{\rm new}) \geq L_{\pi_{\rm old}}(\pi_{\rm new}) - \frac{4\epsilon\gamma}{(1-\gamma)^2} \alpha^2
$$

其中：

- ϵ = max_{s,a} |A_π(s, a)|，即策略 π 的优势函数的最大绝对值；
- γ 为折扣因子；
- L_π_old(π_new) 是一个关于 π_old 和 π_new 的性能估计函数。

该定理表明，只要新旧策略之间的总变差足够小，就能保证性能 η 的提升。

---

### 与 KL 散度的关系

文中指出：

$$
D_{TV}(p\|\ q)^2 \leq D_{KL}(p\|\ q)
$$

因此可以将总变差替换为 KL 散度，得到如下改进下界：

$$
\eta(\tilde{\pi}) \geq L_{\pi}(\tilde{\pi}) - C \cdot D^{\rm max}_{KL}(\pi, \tilde{\pi})
$$

其中：

$$
C = \frac{4\epsilon\gamma}{(1-\gamma)^2}
$$

这为后续算法设计提供了基础。

---

### 算法1：保证单调提升的策略迭代算法

该算法基于上述 KL 散度形式的改进下界，采用如下策略更新方式：

$$
\pi_{i+1} = \arg\max_{\pi} \left[ L_{\pi_i}(\pi) - C \cdot D^{\rm max}_{KL}(\pi_i, \pi) \right]
$$

其中：

- L_{π_i}(π) 是一个性能估计函数；
- C 是一个与 ϵ 和 γ 相关的常数；
- D^max_KL 是策略 π_i 与 π 之间的最大 KL 散度。

该算法保证生成的策略序列满足：

$$
\eta(\pi_0) \leq \eta(\pi_1) \leq \eta(\pi_2) \leq \dots
$$

即性能单调非降。

---

### 算法性质与背景

该算法属于**最小化-最大化**（MM）算法的一种，其核心思想是通过构造一个在当前策略处与真实目标函数 η 相等且在其下方的代理函数 M_i(π)，然后最大化该代理函数来确保 η 的提升。

这种思想也与**近端梯度法**和**镜像下降法**有相似之处。

---

### 与 TRPO 的关系

下一节提出的**信任区域策略优化**（TRPO）是对该算法的一种近似实现，其核心思想是使用 KL 散度的约束（而非惩罚项）来控制策略更新的幅度，从而在保证性能提升的同时允许较大的更新步长。

---

### 总结

- 本节将保守策略迭代的性能提升保证扩展到一般随机策略；
- 使用总变差散度和 KL 散度作为策略差异的度量；
- 提出了一个保证单调提升的策略迭代算法；
- 该算法基于代理函数优化，属于 MM 算法框架；
- 为 TRPO 的提出提供了理论基础。


## 4 Optimization of Parameterized Policies


本节在前一节理论分析的基础上，探讨如何在有限样本和任意参数化策略的条件下，设计出一个实用的策略优化算法。

---

### 4.1 参数化策略与符号定义

本节考虑参数化策略 πθ(a|s)，其中 θ 是参数向量。为了方便，沿用了前一节的符号，但将其视为 θ 的函数：

- η(θ) 表示策略 πθ 的性能；
- Lθ(θ̃) 是策略 πθ 对策略 πθ̃ 的近似目标函数；
- DKL(θ || θ̃) 是两个策略之间的 KL 散度；
- θold 表示当前需要改进的旧策略参数。

---

### 4.2 理论保证下的策略更新

前一节表明，以下不等式成立：

> η(θ) ≥ Lθold(θ) − C × DKL^max(θold, θ)

其中，等号在 θ = θold 时成立。因此，通过最大化右边的表达式，可以保证提升真实目标函数 η(θ)：

> **maximizeθ [Lθold(θ) − C × DKL^max(θold, θ)]**

然而，理论推荐的惩罚系数 C 通常会导致更新步长过小，影响学习效率。

---

### 4.3 使用 KL 散度约束的策略更新（信任域方法）

为了解决步长过小的问题，提出使用 KL 散度约束的优化问题，即信任域方法：

> **maximizeθ Lθold(θ)**  
> **s.t. DKL^max(θold, θ) ≤ δ**

该问题要求在每个状态下的 KL 散度都不超过 δ。虽然有理论支持，但由于约束太多，实际中难以求解。

---

### 4.4 实用策略更新：平均 KL 散度约束

为了解决最大 KL 散度约束的计算难题，提出使用平均 KL 散度作为替代：

> D̄KL^ρ(θ1, θ2) := 𝔼s∼ρ [DKL(πθ1(⋅|s) || πθ2(⋅|s))]

从而得到一个更实用的优化问题：

> **maximizeθ Lθold(θ)**  
> **s.t. D̄KL^{ρθold}(θold, θ) ≤ δ**

这个方法在实际中更容易求解，并且在经验表现上与最大 KL 散度约束相当。

---

### 4.5 与已有工作的联系

类似的方法在之前的研究中也有提出（如 Bagnell & Schneider, 2003；Peters & Schaal, 2008b；Peters et al., 2010），本文在第7节和第8节中将对这些方法进行比较，并展示实验结果。

---

**重点总结：**

- 本节核心是将理论上的策略更新转化为实际可行的优化问题；
- 从惩罚项到 KL 散度约束（信任域）的转变是为了提升更新效率；
- 最终采用平均 KL 散度约束，兼顾了理论保证和实际可行性；
- 所提出的方法与已有策略优化方法有联系，并在实验中表现良好。


## 5 Sample-Based Estimation of the Objective and Constraint


本节讨论如何通过蒙特卡洛模拟来近似目标函数和约束函数。这是对第4节中提出的约束优化问题（公式12）的扩展，目标是优化期望总奖励的估计值 η𝜂\eta，同时限制每次更新中策略的变化。

### 优化问题的重构

我们希望解决以下优化问题（公式13）：

- **目标函数**：最大化 ∑sρθold(s)∑aπθ(a|s)Aθold(s,a)  
- **约束条件**：D¯KLρθold(θold,θ)≤δ

通过以下步骤对目标函数进行重构：

1. 将状态求和转换为期望形式：1/(1−γ)⋅E[s∼ρθold][...]。
2. 将优势函数 Aθold 替换为 Q 值 Qθold，这只会改变目标函数的一个常数项。
3. 使用重要性采样估计动作的求和项。

最终得到等价的期望形式（公式14）：

- **目标函数**：最大化 E[s∼ρθold, a∼q][πθ(a|s)/q(a|s)⋅Qθold(s,a)]
- **约束条件**：E[s∼ρθold][DKL(πθold(⋅|s) || πθ(⋅|s))] ≤ δ

接下来只需将期望替换为样本均值，并用经验估计替代 Q 值。

### 两种采样方法

本节介绍了两种不同的采样方法来估计目标函数和约束：

---

### 5.1 单路径方法（Single Path）

**核心内容**：

- **采样方式**：从初始状态 s0∼ρ0 开始，使用策略 πθold 模拟生成轨迹 s0,a0,s1,a1,…,sT。
- **采样分布**：q(a|s) = πθold(a|s)，即使用旧策略进行动作采样。
- **Q 值估计**：在每个状态动作对 (st,at) 上，通过轨迹的折扣奖励和来估计 Qθold(st,at)。

**特点**：
- 简单易实现，常用于策略梯度估计。
- 适用于无法重置状态的物理系统。

---

### 5.2 藤蔓方法（Vine）

**核心内容**：

- **采样流程**：
  1. 生成若干轨迹，从中选取 N 个状态作为“rollout set”。
  2. 对每个状态 sn，从其出发，使用采样分布 q(⋅|sn) 生成 K 个动作，并对每个动作执行一次 rollout（即短轨迹）。
  3. 使用**共同随机数**（CRN）减少不同 rollout 之间的 Q 值估计方差。

- **Q 值估计**：Q^θi(sn, an,k) 是从 sn 和 an,k 出发的 rollout 的折扣奖励和。

- **目标函数估计**：
  - 在小动作空间中，对所有动作进行 rollout，使用公式：
    Ln(θ) = ∑k=1^K πθ(ak|sn)⋅Q^(sn, ak)
  - 在大或连续动作空间中，使用**自归一化重要性采样估计器**：
    Ln(θ) = [∑k=1^K (πθ(an,k|sn)/πθold(an,k|sn)) ⋅ Q^(sn, an,k)] / [∑k=1^K (πθ(an,k|sn)/πθold(an,k|sn))]

**特点**：
- **优势**：相比单路径方法，在相同 Q 值样本数下，目标函数估计的方差更低，优势值估计更准确。
- **劣势**：
  - 需要多次调用模拟器。
  - 要求系统可以重置到任意状态，因此不适用于物理系统。

---

### 总结对比

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 单路径 | 简单，无需重置状态 | 方差大 | 物理系统、无法重置的环境 |
| 藤蔓 | 方差小，估计更准确 | 需多次调用模拟器，需重置状态 | 模拟环境、可重置系统（如机器人仿真） |

图1展示了两种方法的示意图：单路径方法生成完整轨迹，藤蔓方法则在某些状态“分支”出多个 rollout，形成类似藤蔓的结构。


## 6 Practical Algorithm


本章基于前文的理论思想，提出了两个实用的策略优化算法，分别使用**单路径（single path）**或**藤本（vine）**采样方法进行实现。算法的核心流程如下：

---

### 1. 算法流程概述

1. **数据收集**  
   使用单路径或藤本方法收集状态-动作对，并计算每个状态-动作对的蒙特卡洛Q值估计。

2. **目标函数与约束估计**  
   通过对样本的平均，构建目标函数和约束条件的估计值（参考第5章中的公式14）。

3. **求解约束优化问题以更新策略参数**  
   使用**共轭梯度法结合线搜索**来近似求解该优化问题。这种方法的计算成本仅略高于计算梯度本身。具体实现细节见附录C。

---

### 2. Fisher信息矩阵的构造改进

在步骤3中，作者改进了Fisher信息矩阵（FIM）的构造方式：

- **传统方法**：通过策略梯度的协方差矩阵来估计FIM。
- **本文方法**：通过KL散度的解析二阶导数来估计FIM，即：
$$
A_{ij} = \frac{1}{N} \sum_{n=1}^{N} \frac{\partial^2}{\partial \theta_i \partial \theta_j} D_{\rm KL}\left(\pi_{\theta_{\rm old}}(\cdot|s_n) \| \pi_{\theta}(\cdot|s_n)\right)
$$

  该方法不依赖于实际采样的动作 $a_n$，而是对每个状态 $s_n$ 的动作空间进行积分。

- **优势**：  
  - 减少了对密集Hessian矩阵或所有策略梯度的存储需求，适合大规模应用（见附录C）。
  - 实验表明其在策略改进速度上与经验FIM相当。

---

### 3. 理论与算法的联系

本节简要说明了第3章理论与当前实用算法之间的关系：

- **KL散度惩罚 vs 硬性约束**  
  - 理论上使用KL散度作为惩罚项，但惩罚系数过大导致步长过小。
  - 实际中采用**硬性约束**代替惩罚项，约束KL散度不超过一个固定值 $\delta$。

- **最大KL散度 vs 平均KL散度**  
  - 理论中使用最大KL散度 $D^{\rm max}_{\rm KL}$，但难以优化和估计。
  - 实践中使用平均KL散度 $\overline{D}_{\rm KL}$ 作为替代。

- **优势函数估计误差**  
  - 理论部分忽略了优势函数的估计误差。
  - 虽然Kakade & Langford (2002) 的分析考虑了该误差，但本文为简化起见省略了这部分内容。

---

### 总结

本章提出了一种基于TRPO理论的实用策略优化算法，结合了高效的采样方法（单路径或藤本）和优化技术（共轭梯度+线搜索），并通过改进Fisher信息矩阵的构造方式提升了计算效率。同时，算法设计在理论与实践之间做了合理权衡，如用硬性约束代替惩罚项，用平均KL散度代替最大KL散度等，增强了算法的实用性与稳定性。


## 7 Connections with Prior Work

本节主要探讨了TRPO（信任区域策略优化）方法与之前提出的多种策略更新方法之间的关系，指出TRPO提供了一个统一的视角来看待这些方法。

---

### 7.1 自然策略梯度（Natural Policy Gradient）

- **核心内容**：自然策略梯度方法（Kakade, 2002）可以看作是TRPO中策略更新公式的一个特例。
- **实现方式**：在TRPO的公式（12）中，如果对目标函数使用线性近似，对KL散度约束使用二次近似，就得到了自然策略梯度的更新形式（见公式17）。
- **更新公式**：  
  $$
  \theta_{\text{new}} = \theta_{\text{old}} + \frac{1}{\lambda} A(\theta_{\text{old}})^{-1} \nabla_\theta L(\theta)|_{\theta=\theta_{\text{old}}}
  $$
  其中 $ A(\theta_{\text{old}}) $ 是Fisher信息矩阵。
- **关键区别**：自然策略梯度将步长 $ \frac{1}{\lambda} $ 作为参数手动设置，而TRPO则通过约束来自动控制更新幅度，这种差异在实际应用中显著提升了算法在大规模问题上的表现。

---

### 7.2 标准策略梯度（Standard Policy Gradient）

- **核心内容**：标准策略梯度方法也可以通过TRPO框架推导出来。
- **实现方式**：在TRPO的优化问题中，若将KL散度约束替换为ℓ₂范数约束（即对参数更新幅度进行限制），就得到了标准策略梯度的更新形式（见公式18）。

---

### 7.3 策略迭代（Policy Iteration）

- **核心内容**：策略迭代方法同样可以看作是TRPO的一种特例。
- **实现方式**：通过求解无约束优化问题：
  $$
  \max_\pi L_{\pi_{\text{old}}}(\pi)
  $$
  其中 $ L $ 的定义见第2节公式（3），即可得到策略迭代的更新形式。

---

### 7.4 与其它方法的比较

- **REPS（Relative Entropy Policy Search）**：
  - REPS通过限制状态-动作联合分布 $ p(s,a) $ 来控制策略更新。
  - TRPO则限制条件分布 $ p(a|s) $。
  - TRPO相比REPS更高效，因为它不需要在内层循环中进行复杂的非线性优化。

- **Levine and Abbeel (2014)**：
  - 同样使用KL散度约束，但其目的是防止策略远离动力学模型估计准确的区域。
  - TRPO不依赖于显式建模系统动力学。

- **Pirotta et al. (2013)**：
  - 基于Kakade和Langford的工作进行了扩展和推广。
  - 推导出的算法与TRPO不同，但理论基础相似。

---

### 总结

本节通过将TRPO与自然策略梯度、标准策略梯度、策略迭代、REPS等方法进行对比，展示了TRPO在统一框架下的优势。TRPO通过精确控制策略更新的“信任区域”，在保证稳定性的前提下提升了算法性能，尤其适用于大规模问题。同时，TRPO在实现效率和理论一致性方面也优于其他类似方法。


## 8 Experiments


### 8.1 模拟机器人运动实验

**实验目标：**
- 评估 TRPO 的单路径（single path）和藤蔓（vine）采样方法的性能。
- 比较 TRPO 与先前策略优化方法（如自然策略梯度）的差异，尤其是 TRPO 使用固定 KL 散度而非固定惩罚系数的影响。
- 验证 TRPO 在大规模问题（如机器人运动控制）上的有效性。

**实验设置：**
- 使用 MuJoCo 模拟器进行实验，测试三种机器人模型：
  1. **Swimmer（游泳者）**：10 维状态空间，奖励函数为前进速度减去关节力矩的惩罚。
  2. **Hopper（跳跃者）**：12 维状态空间，奖励函数类似游泳者，加上保持非终止状态的 +1 奖励。
  3. **Walker（行走者）**：18 维状态空间，额外对脚部撞击地面进行惩罚，鼓励平稳行走。
- 所有实验中 KL 散度阈值 δ=0.01。
- 使用神经网络表示策略，结构如图3所示。
- 对比算法包括：
  - TRPO 的单路径和藤蔓变体
  - 无梯度方法：CEM、CMA
  - 自然梯度法（使用固定惩罚系数）
  - 其他变体：经验 Fisher 信息矩阵（FIM）、最大 KL 散度约束

**实验结果：**
- **TRPO 的单路径和藤蔓方法**在所有任务中表现最佳，成功学习了游泳、跳跃和行走的策略。
- **自然梯度法**在简单任务（Swimmer）表现良好，但在 Hopper 和 Walker 上未能学会有效运动。
- **无梯度方法（CEM、CMA）**在参数较多的任务上表现差，样本复杂度高。
- **最大 KL 方法**学习速度较慢，但验证了平均 KL 散度约束的有效性。
- TRPO 使用通用策略和简单奖励函数，无需手动设计策略结构，优于以往依赖专家知识的方法。

---

### 8.2 图像输入游戏实验

**实验目标：**
- 验证 TRPO 在高维、部分可观测任务（Atari 游戏）中的性能。
- 比较 TRPO 与其他强化学习方法（如深度 Q 学习）在图像输入任务上的表现。

**实验设置：**
- 使用 Arcade Learning Environment 测试 7 款 Atari 游戏（如 Breakout、Pong、Q\*bert 等）。
- 输入为原始图像，预处理方式与 Mnih 等人（2013）一致。
- 策略由卷积神经网络表示（两层卷积 + 一层全连接），参数约 33,500。
- TRPO 的单路径和藤蔓方法与以下方法对比：
  - 人类专家表现
  - 深度 Q 学习（Mnih et al., 2013）
  - UCC-I（Guo et al., 2014，结合蒙特卡洛树搜索与监督训练）

**实验结果：**
- TRPO 在多个游戏中表现良好，如 Q\*bert 和 Seaquest 上得分较高。
- 虽然在部分游戏上未超越深度 Q 学习，但 TRPO 无需任务特定设计，展示了其通用性。
- TRPO 在机器人运动和图像游戏任务中均有效，证明其适用于多种复杂任务。

---

### 总结

本章通过模拟机器人运动和 Atari 游戏两个任务，全面评估了 TRPO 的性能：

- **TRPO 的单路径和藤蔓方法**在复杂控制任务中表现优异，尤其在 KL 散度约束下比自然梯度法更稳定高效。
- **TRPO 在大规模问题中表现良好**，能够从零开始学习高质量的运动控制器和图像输入游戏策略。
- **TRPO 的通用性**是其显著优势，适用于从机器人控制到视觉游戏的广泛任务，而无需任务特定设计。

这些实验验证了 TRPO 在策略优化中的有效性、鲁棒性和泛化能力。


## 9 Discussion


本节主要讨论了作者提出并分析的信任区域方法在优化随机控制策略中的应用，以及该方法在理论和实践上的意义。

### 理论分析与算法优势
作者首先强调了他们提出的算法具有**单调改进**的性质。该算法通过反复优化策略的局部回报近似函数，并加入KL散度惩罚项，从而保证策略更新的稳定性。此外，作者还提出了一种该方法的近似版本，使用KL散度约束代替惩罚项，在多个具有挑战性的策略学习任务中表现出色，**优于先前方法**。

同时，该分析提供了一个统一的视角，将**策略梯度方法**和**策略迭代方法**统一起来，表明它们是该算法在特定限制条件下的特殊情况。这为理解不同策略优化方法之间的关系提供了理论支持。

### 实验应用与成果
在**机器人运动控制**方面，作者成功地在物理模拟器中训练出了游泳、行走和跳跃的控制器，使用的是通用神经网络和信息量极少的奖励信号。据作者所知，这是**首次使用通用策略搜索方法和非人工设计的策略表示**完成这些任务的研究。

在**游戏策略学习**方面，作者训练了以原始图像为输入的卷积神经网络策略。这类任务需要优化**极高维的策略空间**，目前仅有两种先前方法报告了成功结果。

### 未来展望与潜在应用
由于该方法具有良好的**可扩展性**和**坚实的理论基础**，作者希望它能成为未来训练大规模、复杂函数逼近器的基础。

在两个实验领域的交汇点上，该方法有望用于训练**基于视觉和原始传感器输入的机器人控制策略**，从而实现感知与控制的统一训练框架。

此外，使用更复杂的策略结构，如**带有隐藏状态的循环策略**，可以在部分可观测环境中将状态估计与控制统一到一个策略中。

结合**模型学习**的方法，还可以显著降低该方法的样本复杂度，使其适用于现实中样本获取成本较高的场景。


## Appendix A Proof of Policy Improvement Bound

### 1. 引言与概述
本附录的证明借鉴了 Kakade & Langford (2002) 中定理4.1的证明方法，并将其扩展到本文所讨论的更一般性随机策略场景。  
核心思想是通过“耦合”（coupling）技术，联合定义策略 π 和 π'，使得它们以高概率（1−α）选择相同动作。  
目标是分析策略性能差异 η(π̃)−η(π)，并建立一个与策略差异 α 相关的上界。

---

### 2. 关键引理

#### **引理1（策略性能差异的分解）**
该引理表明，两个策略 π 和 π̃ 的性能差异可以分解为每一步状态动作对的优势函数期望值之和：

$$
\eta(\tilde{\pi}) = \eta(\pi) + \mathbb{E}_{\tau \sim \tilde{\pi}}\left[\sum_{t=0}^{\infty} \gamma^t A_\pi(s_t, a_t)\right]
$$

**重点说明：**
- 这是策略优化理论中的一个基础性结果。
- 它将策略性能差异与优势函数联系起来，为后续分析提供了基础框架。

---

#### **引理2（优势函数的期望上界）**
定义 $\bar{A}(s)$ 为在状态 s 下 π̃ 相对于 π 的平均优势：

$$
\bar{A}(s) = \mathbb{E}_{a \sim \tilde{\pi}(\cdot|s)}[A_\pi(s, a)]
$$

**结论：**
- 若 π 和 π̃ 是 α-coupled 策略，则：

$$
|\bar{A}(s)| \leq 2\alpha \max_{s,a} |A_\pi(s,a)|
$$

**重点说明：**
- 该引理量化了策略差异 α 对平均优势的影响。
- 它是后续误差分析的关键工具。

---

#### **引理3（不同策略下状态分布差异的上界）**
考虑在时间步 t 下，策略 π 和 π̃ 生成状态 s_t 的期望差异：

$$
\left|\mathbb{E}_{s_t \sim \tilde{\pi}}[\bar{A}(s_t)] - \mathbb{E}_{s_t \sim \pi}[\bar{A}(s_t)]\right|
$$

**结论：**
- 该差异的上界为：

$$
\leq 4\alpha(1 - (1-\alpha)^t) \max_{s,a} |A_\pi(s,a)|
$$

**重点说明：**
- 该引理揭示了策略差异随时间步 t 的累积效应。
- 用于后续对策略性能差异的总和分析。

---

### 3. 性能差异的总和分析

结合引理1-3，我们对时间步 t 求和，得到策略性能差异的总上界：

$$
|\eta(\tilde{\pi}) - L_\pi(\tilde{\pi})| \leq \sum_{t=0}^{\infty} \gamma^t \cdot 4\epsilon\alpha(1 - (1-\alpha)^t)
$$

其中 $\epsilon = \max_{s,a} |A_\pi(s,a)|$

**推导结果：**
- 最终得到：

$$
|\eta(\tilde{\pi}) - L_\pi(\tilde{\pi})| \leq \frac{4\alpha^2 \gamma \epsilon}{(1-\gamma)^2}
$$

**重点说明：**
- 该结果表明策略性能差异与 α² 成正比，即策略差异越小，误差越小。
- 这是定理1的核心结论。

---

### 4. 与总变差散度（TV散度）的关系

最后，将 α 替换为策略之间的总变差散度（Total Variation Divergence）：

$$
D_{TV}(\pi(\cdot|s) \| \tilde{\pi}(\cdot|s)) \leq \alpha
$$

根据概率论中的耦合定理（Levin et al., 2009），可以构造一个 α-coupled 策略对，使得其边缘分布为 π 和 π̃。

**结论：**
- 将 α 替换为 TV 散度后，定理1成立。

---

### 总结

本附录通过耦合技术，将策略性能差异与策略之间的动作选择差异（α）联系起来，并最终推导出一个与 α² 成正比的性能差异上界。  
主要步骤如下：

1. **引理1**：将策略性能差异表示为优势函数的期望和。
2. **引理2**：分析平均优势函数的上界。
3. **引理3**：分析不同策略下状态分布差异的上界。
4. **求和分析**：对时间步求和，得到总性能差异的上界。
5. **与TV散度联系**：将 α 替换为策略之间的 TV 散度，完成定理证明。

**核心贡献：**
- 提供了策略改进的理论保证，即只要策略更新的 TV 散度较小，性能提升是有界的。
- 为 TRPO 等策略优化算法提供了理论依据。


## Appendix B Perturbation Theory Proof of Policy Improvement Bound


### 1. 基本定义与符号设定

- 定义 $ G = (1 - \gamma P_\pi)^{-1} $ 和 $ \tilde{G} = (1 - \gamma P_{\tilde{\pi}})^{-1} $，分别表示策略 $\pi$ 和 $\tilde{\pi}$ 的状态转移的无穷级数展开。
- 定义 $ \Delta = P_{\tilde{\pi}} - P_\pi $，表示策略变化带来的状态转移矩阵的扰动。
- 策略性能函数 $ \eta(\pi) = r G \rho_0 $，表示策略 $\pi$ 在初始状态分布 $\rho_0$ 下的期望回报。

目标是分析策略变化带来的性能差异：  
$$
\eta(\tilde{\pi}) - \eta(\pi) = r(\tilde{G} - G)\rho_0
$$

---

### 2. 扰动展开与性能差异表达式

通过扰动理论推导出：
$$
\tilde{G} = G + \gamma G \Delta \tilde{G}
$$
进一步展开得到：
$$
\tilde{G} = G + \gamma G \Delta G + \gamma^2 G \Delta G \Delta \tilde{G}
$$
代入性能差异公式，得到：
$$
\eta(\tilde{\pi}) - \eta(\pi) = \gamma r G \Delta G \rho_0 + \gamma^2 r G \Delta G \Delta \tilde{G} \rho_0
$$

---

### 3. 主要项分析：$\gamma r G \Delta G \rho_0$

- $ rG = v $：表示状态值函数（state-value function）。
- $ G \rho_0 = \rho_\pi $：表示策略 $\pi$ 下的状态分布。
- 所以该主项可写为：
  $$
  \gamma v \Delta \rho_\pi
  $$
- 证明该表达式等于优势函数的期望：
  $$
  L_\pi(\tilde{\pi}) - L_\pi(\pi) = \sum_{s,a} \rho_\pi(s) (\tilde{\pi}(a|s) - \pi(a|s)) A_\pi(s,a)
  $$
  通过推导，最终得出：
  $$
  \gamma v \Delta \rho_\pi = L_\pi(\tilde{\pi}) - L_\pi(\pi)
  $$

---

### 4. 二阶项（高阶扰动项）的上界分析

- 二阶项为：
  $$
  \gamma^2 r G \Delta G \Delta \tilde{G} \rho
  $$
- 分析其上界时，使用了以下工具：
  - **无穷范数**（$\|\cdot\|_\infty$）：用于衡量优势函数的差异。
  - **$\ell_1$ 范数**：用于衡量状态分布的扰动。
- 得到上界为：
  $$
  \frac{4 \gamma \epsilon}{(1 - \gamma)^2} \alpha^2
  $$
  其中：
  - $\epsilon = \max_{s,a} |A_\pi(s,a)|$：最大优势值。
  - $\alpha$：策略变化的总变分距离（Total Variation Divergence）。

---

### 5. 总结

- 通过扰动理论，将策略变化带来的性能提升分解为两个部分：
  1. **主项**：等于策略优势函数的期望，表示策略改进的主要来源。
  2. **二阶项**：表示高阶扰动影响，其上界与策略变化的平方成正比，且受折扣因子 $\gamma$ 和最大优势值 $\epsilon$ 的影响。
- 最终结果与定理 1 一致，验证了 TRPO 的单调改进性质。

---

### 重点内容总结

- **核心思想**：将策略变化视为状态转移矩阵的扰动，利用扰动理论展开分析。
- **主项意义**：对应策略优势函数的期望，是策略改进的主要来源。
- **高阶项控制**：通过范数分析，证明其上界与策略变化的平方成正比，保证了策略改进的稳定性。

---

### 非重点内容精简

- 矩阵展开和代数推导过程（如 $ G^{-1} - \tilde{G}^{-1} = \gamma \Delta $）是标准扰动理论步骤，略去详细推导。
- 向量与对偶向量的区分（如 $\rho$ 为向量，$r$ 为对偶向量）是为了数学严谨性，不影响最终结论。


## Appendix C Efficiently Solving the Trust-Region Constrained Optimization Problem


### 概述

本节介绍如何高效地近似求解 TRPO 算法每一步迭代中需要解决的如下约束优化问题：

$$
\text{最大化 } L(\theta) \quad \text{满足 } \overline{D}_{\text{KL}}(\theta_{\text{old}}, \theta) \leq \delta.
$$

该问题的目标是最大化目标函数 $ L(\theta) $，同时保证新旧策略之间的 KL 散度不超过一个给定的阈值 $ \delta $。为高效求解该问题，作者提出了一种两步方法：

1. **计算搜索方向**：使用目标函数的线性近似和约束的二次近似；
2. **线搜索**：在该方向上进行线搜索，确保目标函数提升并满足非线性约束。

---

### C.1 计算 Fisher 向量积（Fisher-Vector Product）

### 核心内容

为了进行共轭梯度法（Conjugate Gradient, CG），需要能够高效地计算 Fisher 信息矩阵与任意向量的乘积（即 Fisher 向量积）。

#### 1. KL 散度与 Fisher 信息矩阵的关系

对于给定输入 $ x $，策略的 KL 散度可以表示为：

$$
D_{\text{KL}}(\pi_{\theta_{\text{old}}}(\cdot|x) \parallel \pi_{\theta}(\cdot|x)) = \text{kl}(\mu_{\theta}(x), \mu_{\text{old}})
$$

其中 $ \mu_{\theta}(x) $ 是策略输出的分布参数。

对 KL 散度进行两次求导后，得到 Fisher 信息矩阵的形式为：

$$
A = J^T M J
$$

其中：

- $ J = \frac{\partial \mu_a(x)}{\partial \theta_i} $ 是 Jacobian 矩阵；
- $ M = \text{kl}''_{ab}(\mu_{\theta}(x), \mu_{\text{old}}) $ 是分布参数空间下的 Fisher 信息矩阵。

#### 2. Fisher 向量积的高效计算

Fisher 向量积的形式为：

$$
y \rightarrow A y = J^T M J y
$$

- $ Jy $ 和 $ J^T v $ 可以通过自动微分工具高效实现（如前向传播和反向传播）；
- $ M $ 的形式对大多数常见分布都比较简单，可以手动推导实现。

#### 3. 数据平均与计算效率

- Fisher 向量积可以对多个输入 $ x $ 进行平均，这在实际中非常高效；
- 计算一次 Fisher 向量积的成本与计算一个目标函数梯度相当；
- 每次共轭梯度迭代需要一次 Fisher 向量积，通常进行 10 次左右的 CG 迭代即可；
- 通过**对数据进行子采样**（如只使用 10% 的数据），可以显著降低计算负担，而不会严重影响最终结果。

---

### 总结结构

### 1. 信任域优化问题的求解方法

- 使用线性目标 + 二次约束近似，求解方向 $ s \approx A^{-1}g $；
- 利用 $ s^T A s $ 计算最大步长 $ \beta = \sqrt{2\delta / s^T A s} $；
- 使用线搜索确保目标函数提升并满足非线性约束。

### 2. Fisher 向量积的高效实现（C.1）

- Fisher 信息矩阵可表示为 $ A = J^T M J $；
- 利用自动微分和手动推导结合，实现 $ y \rightarrow A y $；
- 通过子采样数据降低计算成本，使自然梯度计算几乎不增加额外开销。

---

### 重点内容强调

- **Fisher 向量积的高效计算** 是整个 TRPO 算法可行的关键，避免了显式构造 Fisher 矩阵；
- **共轭梯度法** 是解决大规模优化问题的核心工具；
- **线搜索** 是保证算法稳定性的必要步骤；
- **数据子采样** 是提升效率的重要技巧，显著减少了计算资源消耗。

---

### 简要总结

本附录详细介绍了 TRPO 中信任域优化问题的高效求解方法，重点在于：

- 利用共轭梯度法求解搜索方向；
- 通过 Fisher 向量积避免显式构建 Fisher 矩阵；
- 使用线搜索确保非线性约束满足；
- 通过数据子采样大幅降低计算成本。

这些技术使得 TRPO 在大规模策略优化中具有良好的可扩展性和稳定性。


## Appendix D Approximating Factored Policies with Neural Networks


本节介绍了如何使用神经网络对策略进行参数化，以在不同类型的动作空间中进行建模，包括**连续动作空间**和**离散动作空间**（如Atari游戏）。以下是各部分内容的总结：

---

### 1. 策略的基本参数化方式

- 策略 πθ(a|s) 是一个条件概率分布，表示在状态 s 下采取动作 a 的概率。
- 该策略通过一个**确定性神经网络**进行参数化：输入状态 s，输出一个向量 μ，该向量定义了动作空间上的分布。
- 通过 μ 可以计算动作的似然 p(a|μ)，并从中采样动作 a。

---

### 2. 连续动作空间的建模（如机器人控制）

- 使用**高斯分布**建模动作分布，协方差矩阵为**对角矩阵**，且与状态无关。
- 神经网络由多个全连接层组成，输入为状态 s，输出为高斯分布的**均值**。
- 每个动作维度的**对数标准差**由一个独立参数向量 r 表示。
- 策略形式为：
  
  $$
  \pi_{\theta}(a|s) = \mathcal{N}\left(\text{mean}=\text{NeuralNet}(s; \{W_i, b_i\}_{i=1}^L),\ \text{stdev}=\exp(r)\right)
  $$

- μ 向量包含均值和标准差：μ = [mean, stdev]。

> **重点**：这种参数化方式在连续控制任务中非常常见，便于梯度优化和采样。

---

### 3. 离散动作空间的建模（如Atari游戏）

- 使用**因子化的离散动作空间**，每个因子对应一个**分类分布**。
- 动作 a 是一个元组 (a₁, a₂, ..., aₖ)，其中每个 aₖ 是一个整数，表示第 k 个因子的动作。
- 每个因子的分布由一个概率向量 μₖ = [p₁, p₂, ..., pₙ] 表示。
- 所有因子的概率向量拼接成一个整体参数向量 μ = [μ₁, μ₂, ..., μₖ]。
- μ 的维度为所有因子动作数之和：dim(μ) = ∑ₖ Nₖ。
- 具体实现：神经网络输出原始值，然后对每个因子对应的输出部分应用 **Softmax**，得到归一化的概率分布。

> **重点**：这种因子化方式可以建模复杂动作组合，适用于多因素决策任务（如Atari游戏中的多个按键组合）。

---

### 总结

- 本节详细介绍了如何用神经网络参数化策略，分别适用于**连续动作空间**（高斯分布）和**离散动作空间**（因子化分类分布）。
- 核心思想是：将状态 s 映射为一个参数向量 μ，该向量定义了动作分布，从而实现策略的建模与采样。
- 两种建模方式都便于梯度优化，适用于强化学习中的策略梯度方法。


## Appendix E Experiment Parameters


本附录提供了在不同任务和算法中使用的实验参数，分为**连续控制任务参数**和**Atari 游戏域参数**两部分。

---

### 表 2：连续控制任务参数（Swimmer、Hopper、Walker）

#### 1. 环境参数
- **状态空间维度（State space dim.）**：Swimmer（10）、Hopper（12）、Walker（20），反映任务复杂度逐步增加。
- **控制空间维度（Control space dim.）**：分别为 2、3、6，表示动作空间的自由度。
- **策略参数总数（Total num. policy params）**：从 Swimmer 到 Walker 显著增加（364 → 8206），说明策略复杂度提升。

#### 2. 训练设置
- **每轮模拟步数（Sim. steps per iter.）**：Swimmer 为 50K，Hopper 和 Walker 为 1M，说明后两者需要更多数据。
- **策略迭代次数（Policy iter.）**：均为 200，统一训练轮数。
- **KL 散度步长（Stepsize (D̄KL)）**：统一为 0.01，控制策略更新的保守程度。
- **隐藏层大小（Hidden layer size）**：Swimmer 为 30，Hopper 和 Walker 为 50，匹配任务复杂度。
- **折扣因子（Discount γ）**：统一为 0.99，强调长期回报。

#### 3. Vine 算法参数
- **Rollout 长度**：Swimmer 为 50，Hopper 和 Walker 为 100。
- **每状态 rollout 数量**：均为 4。
- **每批次 Q 值数量**：Swimmer 500，Hopper 和 Walker 2500。
- **采样时的 rollout 数量与长度**：均为 16 次，每次 1000 步。
- **计算时间**：Swimmer（2 分钟）、Hopper（14 分钟）、Walker（40 分钟），反映任务复杂度对计算资源的需求。

#### 4. 单路径算法（SP）参数
- **路径数量（num. path）**：Swimmer（50）、Hopper（1000）、Walker（10000），逐步增加。
- **路径长度（path len.）**：均为 1000。
- **计算时间**：Swimmer（5 分钟）、Hopper（35 分钟）、Walker（100 分钟），与 Vine 相比，SP 在复杂任务中耗时更长。

> **重点总结**：随着任务复杂度（Swimmer → Hopper → Walker）提升，策略参数、模拟步数、路径数量和计算时间均显著增加，体现出算法对不同任务的适应性调整。

---

### 表 3：Atari 游戏域参数（所有游戏）

#### 1. 策略与训练设置
- **策略参数总数**：统一为 33500，适用于所有 Atari 游戏。
- **每轮模拟步数**：
  - Vine：400K
  - SP：100K
- **策略迭代次数**：500 次，比连续控制任务更多，说明 Atari 需要更长时间训练。
- **KL 散度步长与折扣因子**：与连续控制任务一致（0.01 和 0.99）。

#### 2. Vine 算法设置
- **每状态 rollout 数量**：约为 4。
- **计算时间**：约为 30 小时。

#### 3. SP 算法设置
- **计算时间**：也约为 30 小时，与 Vine 相当。

> **重点总结**：Atari 游戏中 Vine 和 SP 的计算时间相近，但 Vine 每轮模拟步数更多，说明其在更高数据效率下保持了训练稳定性。

---

### 总体总结

- 本附录提供了 Vine 和 SP 两种算法在**连续控制任务**和**Atari 游戏**中的详细参数设置。
- 参数随任务复杂度递增而调整，如策略参数、模拟步数、路径数量等。
- Vine 在复杂任务中计算时间更长，但数据效率更高；SP 则在 Atari 中与 Vine 时间相当，但在连续控制任务中耗时更多。
- 所有任务中，KL 散度步长和折扣因子保持一致，体现了算法设计的通用性。


## Appendix F Learning Curves for the Atari Domain


本节内容主要展示了 Atari 游戏领域中模型训练过程中的学习曲线。这些曲线通过实验数据反映智能体在不同游戏环境下的学习表现。

### 图5：Atari 领域的学习曲线  
- 本图由多个子图组成，展示了多个 Atari 游戏环境下智能体的训练过程。
- 图中横轴表示训练步数（或时间），纵轴表示“cost”（代价），其中 **cost = -reward**（奖励的负值）。因此，曲线下降表示智能体表现提升（奖励增加）。
- 这些学习曲线用于评估不同算法或模型在 Atari 游戏中的收敛速度和最终性能。
- 由于历史原因，使用“cost”而非“reward”进行展示，需注意理解其含义。

### 重点内容：
- 学习曲线展示了智能体在多个 Atari 游戏中的训练过程，反映了算法在不同任务上的表现。
- 曲线趋势可用于分析算法的稳定性、学习效率以及是否出现过拟合或收敛困难等问题。
- 通过对比不同子图中的曲线，可以初步判断某些游戏任务对智能体来说更具挑战性。

### 简要说明：
该附录主要提供实验数据的可视化结果，未涉及新的方法或理论推导，主要用于支持主文中的实验分析。
