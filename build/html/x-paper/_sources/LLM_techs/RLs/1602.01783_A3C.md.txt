# 1602.01783_A3C: Asynchronous Methods for Deep Reinforcement Learning

* 首页: <https://arxiv.org/abs/1602.01783>
* PDF: <https://arxiv.org/pdf/1602.01783>
* 引用: 13981
* 组织: 
    * 1 Google DeepMind
    * 2 University of Montreal(蒙特利尔大学)

## 总结
**总结**
* A3C: asynchronous advantage actor-critic


**A3C**
* 本文提出了一种全新的深度强化学习范式：异步并行执行多个代理（agents），在多个环境实例中同时运行
* 表现最突出的是异步优势演员-评论家算法（A3C）
* 优势
    * 支持广泛的在线策略算法（on-policy algorithms），如 Sarsa、n-step 方法、actor-critic 方法；
    * 也适用于离策略算法如 Q-learning；


## Abstract

本论文提出了一种**概念简单且轻量级的深度强化学习框架**，该框架使用**异步梯度下降**来优化深度神经网络控制器。

作者开发了**四种标准强化学习算法的异步版本**，并通过实验表明，**使用并行的执行器-学习器（actor-learners）可以稳定训练过程**，使得这四种方法都能成功训练神经网络控制器。

其中表现最好的方法是**异步版本的Actor-Critic算法**，它在Atari游戏任务上**超越了当前最先进的算法**，而且训练时间仅为原来的一半，仅使用**单个多核CPU**而非GPU。

此外，该方法还成功应用于多种**连续动作控制问题**，以及一个新任务：**通过视觉输入在随机生成的3D迷宫中导航**。


## 1 Introduction

本节介绍了深度强化学习（Deep Reinforcement Learning, Deep RL）的发展背景与挑战，并提出了一种新的并行强化学习范式。

### 1.1 深度神经网络与强化学习的结合

深度神经网络能够提供丰富的特征表示，使得强化学习算法在复杂任务中表现良好。然而，早期人们认为将简单的在线强化学习算法与深度网络结合会导致训练不稳定。为了解决这个问题，研究者提出了多种稳定训练的方法（如Riedmiller, 2005；Mnih等，2013、2015；Van Hasselt等，2015；Schulman等，2015a）。

这些方法的核心思想是：**在线强化学习代理所遇到的数据序列是非平稳且高度相关的**。通过引入经验回放（experience replay）机制，将数据存储并进行批量处理或随机采样，可以降低数据的非平稳性并减少更新之间的相关性。但这种方法也限制了只能使用**离策略（off-policy）**算法。

### 1.2 经验回放的局限性

虽然基于经验回放的深度强化学习在Atari 2600等复杂任务中取得了成功，但它也存在以下缺点：

- **内存和计算开销大**：每次真实交互后需要存储大量数据；
- **依赖离策略算法**：必须使用能够处理旧策略生成数据的算法。

### 1.3 并行异步强化学习的新范式（重点）

本文提出了一种**全新的深度强化学习范式**：**异步并行执行多个代理（agents）**，在多个环境实例中同时运行。这种并行机制自然地使数据更平稳、更新更去相关，从而避免了经验回放的必要。

该方法的优势包括：

- 支持**广泛的在线策略算法**（on-policy algorithms），如 Sarsa、n-step 方法、actor-critic 方法；
- 同样适用于**离策略算法**如 Q-learning；
- 实现简单，**仅需一台标准多核CPU的单机设备**，无需依赖GPU或大规模分布式架构。

### 1.4 实验结果与A3C的优势（重点）

在多个 Atari 2600 游戏中，异步强化学习方法在**更短时间**内取得了**优于GPU算法**的结果，且资源消耗远低于分布式方法。

其中表现最突出的是**异步优势演员-评论家算法（A3C）**，它不仅在多种游戏中表现出色，还成功应用于：

- 连续动作控制任务；
- 从视觉输入中学习探索3D迷宫的策略；
- 可训练前馈网络和循环网络。

作者认为，A3C 是目前**最通用、最成功的强化学习代理**，适用于2D/3D游戏、离散/连续动作空间，并能处理不同类型神经网络结构。


## 2 Related Work


### Gorila 架构
本节首先介绍了 **Gorila 架构**（Nair et al., 2015），它是一种用于分布式环境下异步训练强化学习智能体的通用架构。Gorila 的核心结构包括：

- 每个进程中包含一个 **actor**（在独立的环境副本中执行动作）、一个 **replay memory**（经验回放缓冲区）和一个 **learner**（从缓冲区采样数据并计算 DQN 损失的梯度）。
- 计算出的梯度通过异步方式发送到一个 **中央参数服务器**，该服务器负责更新全局模型。
- 更新后的策略参数会以固定时间间隔发送回各个 actor-learner。

Gorila 使用了 100 个 actor-learner 进程和 30 个参数服务器，总共 130 台机器，在 49 个 Atari 游戏中显著优于 DQN，许多游戏中达到 DQN 成绩的速度快了 20 倍以上。此外，Chavez 等人（2015）也提出了类似的 DQN 并行方法。

---

### 早期并行强化学习方法
接下来介绍了几种 **早期的并行强化学习方法**：

- **Li & Schuurmans（2011）**：使用 MapReduce 框架并行化基于线性函数逼近的批量强化学习方法。并行主要用于加速矩阵运算，而非经验收集或稳定学习过程。
- **Grounds & Kudenko（2008）**：提出了一种并行 Sarsa 算法，多个 actor-learner 独立学习，并通过点对点通信定期发送显著变化的权重更新以加速训练。

---

### 异步 Q-learning 的收敛性分析
本节还提到了 **异步 Q-learning 的理论分析**：

- **Tsitsiklis（1994）**：研究了异步优化下 Q-learning 的收敛性，证明只要过时信息最终会被丢弃，并满足一些技术条件，Q-learning 仍能保证收敛。
- 更早的工作 **Bertsekas（1982）** 探讨了分布式动态规划的相关问题。

---

### 并行进化方法
最后介绍了 **并行进化方法** 在强化学习中的应用：

- 进化算法天然适合并行化，因为可以将适应度评估分布在多个机器或线程上（Tomassini, 1999）。
- 近年来，这类方法被应用于视觉强化学习任务。例如：
  - **Koutník 等人（2014）**：在 TORCS 驾驶模拟器中，使用 8 个 CPU 核并行评估适应度，演化出卷积神经网络控制器。

---

### 总结
本节系统回顾了多种强化学习的并行化方法，包括 Gorila 架构、早期的 MapReduce 和 Sarsa 并行实现、异步 Q-learning 的理论基础，以及并行进化算法的应用。其中，Gorila 是重点，展示了大规模分布式训练在 DQN 上的显著性能提升。其他方法则作为背景补充，强调了并行化在不同强化学习范式中的广泛应用。


## 3 Reinforcement Learning Background


### 3.1 基本设置

本节介绍了标准的**强化学习框架**：智能体在离散时间步中与环境交互。在每个时间步 t，智能体接收状态 sₜ，根据策略 π 选择动作 aₜ，然后环境返回下一个状态 sₜ₊₁ 和一个标量奖励 rₜ。这个过程持续到智能体到达终止状态后重新开始。

目标是最大化从每个状态 sₜ 出发的**期望回报**，其中回报定义为折扣奖励的总和：  
Rₜ = Σ γᵏ rₜ₊ₖ，其中 γ ∈ (0,1] 是折扣因子。

> **重点**：回报的定义是强化学习的核心，它决定了智能体如何权衡当前奖励与未来奖励。

---

### 3.2 价值函数

- **动作价值函数 Q^π(s,a)**：表示在状态 s 下执行动作 a，并按照策略 π 执行下去的期望回报。
- **最优动作价值函数 Q*(s,a)**：所有策略中能获得的最大 Q 值。
- **状态价值函数 V^π(s)**：表示在状态 s 下遵循策略 π 的期望回报。

> **重点**：Q 函数和 V 函数是强化学习中两个基本的评估指标，Q 函数考虑动作，V 函数只考虑状态。

---

### 3.3 基于价值的无模型方法

这类方法使用函数逼近器（如神经网络）来近似 Q 函数，记为 Q(s,a;θ)，其中 θ 是参数。

- **Q-learning** 是一个典型例子，其目标是逼近最优 Q 函数 Q*(s,a)。
- 使用**单步 Q-learning**，通过最小化如下损失函数来更新参数 θ：

  Lᵢ(θᵢ) = 𝔼[(r + γ maxₐ' Q(s',a';θᵢ₋₁) − Q(s,a;θᵢ))²]

  其中 s' 是执行动作 a 后的状态。

> **重点**：Q-learning 是一种 off-policy 方法，使用目标策略和行为策略分离的思想，具有良好的理论保证。

---

### 3.4 单步方法的局限性

单步方法（如 Q-learning）只将 Q 值更新到一步回报（r + γ max Q(s',a')），这意味着一个奖励只直接影响导致它的那个状态-动作对，其他状态-动作对只能通过后续更新间接影响。

> **重点**：这会导致学习过程缓慢，因为需要多次更新才能将奖励传播到前面的状态。

---

### 3.5 n 步回报方法

为加快奖励传播，可以使用**n 步 Q-learning**，其中 Q 值更新到 n 步回报：

Rₙ = rₜ + γ rₜ₊₁ + ... + γⁿ⁻¹ rₜ₊ₙ₋₁ + γⁿ maxₐ Q(sₜ₊ₙ, a)

> **重点**：这种方法可以让一个奖励直接影响前面 n 个状态-动作对，从而加快学习过程。

---

### 3.6 基于策略的无模型方法

与基于价值的方法不同，**策略梯度方法**直接参数化策略 π(a|s;θ)，并通过近似梯度上升来最大化期望回报 𝔼[Rₜ]。

- **REINFORCE 算法** 是一类典型的策略梯度方法，其更新方向为：

  ∇θ log π(aₜ|sₜ;θ) · Rₜ

  这是对 ∇θ 𝔼[Rₜ] 的无偏估计。

- 为了降低方差，可以引入**基线函数 bₜ(sₜ)**，更新变为：

  ∇θ log π(aₜ|sₜ;θ) · (Rₜ - bₜ(sₜ))

> **重点**：使用状态价值函数作为基线可以显著降低方差，提高策略梯度估计的稳定性。

---

### 3.7 优势函数与 Actor-Critic 架构

- 当使用价值函数估计作为基线时，Rₜ - bₜ(sₜ) 可以看作是对当前动作优势的估计，即：

  A(aₜ, sₜ) = Q(aₜ, sₜ) - V(sₜ)

- 这种方法被称为**Actor-Critic 架构**：
  - **Actor**：策略 π，负责选择动作；
  - **Critic**：价值函数估计 bₜ，负责评估当前策略的好坏。

> **重点**：Actor-Critic 是结合策略梯度和价值函数估计的混合方法，兼顾了策略更新的稳定性和效率。

---

### 总结

本章系统介绍了强化学习的基本概念、价值函数、Q-learning、n 步方法、策略梯度算法以及 Actor-Critic 框架。核心内容包括：

- 回报定义与价值函数（Q 和 V）是强化学习的基础；
- Q-learning 是经典的无模型价值方法；
- 单步方法传播慢，n 步方法更高效；
- 策略梯度方法直接优化策略，REINFORCE 是代表；
- 引入基线函数可降低方差，Actor-Critic 是其典型实现。

> **重点总结**：本章为后续章节打下理论基础，涵盖了强化学习的主要方法论框架。


## 4 Asynchronous RL Framework



### 4 异步 RL 框架（Asynchronous RL Framework）

本节介绍了四种异步强化学习算法的多线程变体：一步 Sarsa、一步 Q-learning、n 步 Q-learning 和优势 Actor-Critic（A3C）。设计这些方法的目的是在不依赖大量资源的情况下，稳定地训练深度神经网络策略。

#### 核心设计思想

1. **异步 Actor-Learner 架构**  
   - 类似于 Gorila 框架，但使用单机多线程而非分布式参数服务器。
   - 采用 Hogwild! 风格的更新方式，避免了跨机器通信开销，提升训练效率。

2. **多样化的探索策略**  
   - 多个线程并行运行，各自使用不同的探索策略（如不同 ϵ 的 ε-greedy）。
   - 这种多样性减少了更新之间的相关性，从而替代了经验回放（experience replay）在 DQN 中的稳定作用。

#### 异步方法的优势

- **训练效率提升**：训练时间大致与线程数成线性关系。
- **支持 On-policy 方法**：不再依赖经验回放，使得 Sarsa 和 Actor-Critic 等 on-policy 方法也能稳定训练。

---

### 异步一步 Q-learning（Asynchronous one-step Q-learning）

- **伪代码见 Algorithm 1**。
- 每个线程独立与环境交互，计算 Q-learning 的梯度。
- 使用共享的目标网络（target network）和累积梯度更新（类似 mini-batch），提升稳定性。
- **关键改进**：
  - 定期异步更新全局参数。
  - 每个线程使用不同的探索策略（如随机 ϵ 值）以增强探索多样性。

---

### 异步一步 Sarsa（Asynchronous one-step Sarsa）

- 与异步一步 Q-learning 类似，区别在于目标值的计算方式。
- 使用当前策略选择下一个动作（on-policy），即目标值为：  
  $ r + \gamma Q(s', a'; \theta^-) $，其中 $ a' $ 是下一状态实际采取的动作。

---

### 异步 n 步 Q-learning（Asynchronous n-step Q-learning）

- **伪代码见 Supplementary Algorithm S2**。
- 使用前向视角（forward view）计算 n 步回报，而非常见的反向视角（如资格迹）。
- 在每线程中执行最多 $ t_{max} $ 步，收集多个状态-动作对的回报，然后进行一次梯度更新。
- 适用于使用动量优化和 BPTT 的神经网络训练。

---

### 异步优势 Actor-Critic（Asynchronous Advantage Actor-Critic, A3C）

- **伪代码见 Supplementary Algorithm S3**。
- 同时维护策略函数 $ \pi(a_t|s_t; \theta) $ 和价值函数估计 $ V(s_t; \theta_v) $。
- 使用前向视角，基于 n 步回报更新策略和价值函数。
- **关键设计**：
  - 每 $ t_{max} $ 步或遇到终止状态后进行一次更新。
  - 优势函数估计为：  
    $ A(s_t, a_t) = \sum_{i=0}^{k-1} \gamma^i r_{t+i} + \gamma^k V(s_{t+k}) - V(s_t) $
  - 策略和价值函数共享部分网络参数（如卷积层）。
  - **加入策略熵（entropy）正则化项**，防止策略过早收敛到次优确定性策略。

---

### 优化方法比较（Optimization）

- 测试了三种优化器：带动量的 SGD、不共享统计量的 RMSProp、共享统计量的 RMSProp。
- 实验表明，**共享统计量的 RMSProp** 在 Atari 游戏任务中表现更稳健。
- 公式如下（非中心 RMSProp）：
  $$
  g = \alpha g + (1 - \alpha) (\Delta \theta)^2, \quad \theta \leftarrow \theta - \eta \frac{\Delta \theta}{\sqrt{g + \epsilon}}
  $$
- 更多细节见补充材料 Section 7。

---

### 总结

本节提出了一种高效的异步强化学习框架，通过多线程异步更新和多样化探索策略，实现了对多种 RL 方法（包括 on-policy 和 off-policy）的稳定训练。该框架在减少训练时间的同时，也避免了经验回放机制，适用于深度神经网络策略的训练。


## 5 Experiments


### 5.1 Atari 2600 游戏

**重点内容：**
- **学习速度对比**：图1展示了DQN（GPU训练）与四种异步方法（CPU训练）在五款Atari游戏中的学习速度对比。结果显示，异步方法在16个CPU核心上训练，学习速度普遍快于DQN，其中n-step方法比one-step方法更快，而A3C（异步优势Actor-Critic）表现最优。
- **A3C在57款游戏上的表现**：A3C在仅使用16个CPU核心、训练时间仅为其他方法一半的情况下，显著优于当时最先进的方法（如DQN、Double DQN等）。训练1天即可达到Dueling Double DQN的平均得分，4天后得分进一步提升。使用LSTM的A3C模型表现更优。
- **结果对比表格**：表1展示了不同方法在57款Atari游戏上的平均和中位人类归一化得分。A3C在训练时间更短的情况下，得分显著优于其他方法。

**非重点内容精简：**
- 实验设置细节（如网络结构、超参数调优）在补充材料中，未在本节详细展开。

---

### 5.2 TORCS 汽车竞速模拟器

**重点内容：**
- 在TORCS 3D赛车游戏中，A3C表现最佳，训练约12小时后在四种配置下达到人类测试者75%-90%的得分。
- A3C在视觉输入和奖励机制下成功学习赛车控制策略。

**非重点内容精简：**
- 网络结构与Atari实验相同，未做详细说明。
- 实验设置（如对手机器人）简要提及。

---

### 5.3 使用MuJoCo物理模拟器进行连续动作控制

**重点内容：**
- A3C在MuJoCo物理模拟任务中表现优异，使用状态或像素输入，均能在24小时内找到良好解决方案。
- 视频展示了成功策略的学习过程。

**非重点内容精简：**
- 实验细节（如具体任务）在补充材料中。

---

### 5.4 Labyrinth（迷宫探索）

**重点内容：**
- A3C在Labyrinth环境中学习探索随机生成的3D迷宫，使用84×84 RGB图像作为输入，最终平均得分约50，表明其学习到了有效的探索策略。
- 任务目标为寻找苹果和传送门，最优策略为先找到传送门并重复使用。

**非重点内容精简：**
- 环境细节（如奖励机制）简要描述。

---

### 5.5 可扩展性与数据效率

**重点内容：**
- 表2展示了不同线程数下四种异步方法的训练加速效果。所有方法在16个线程下均实现至少10倍加速，验证了框架的可扩展性。
- 令人意外的是，one-step方法在更多线程下不仅加速，还提升了数据效率，可能是因为多线程减少了偏差。

**非重点内容精简：**
- 图3和图4展示了不同线程数下的数据效率和训练速度对比，作为补充说明。

---

### 5.6 鲁棒性与稳定性

**重点内容：**
- 图2展示了A3C在50种不同学习率和初始化下的得分分布，表明其对学习率和初始化具有较强鲁棒性。
- 所有方法在合理学习率范围内均能稳定训练，未出现崩溃或发散现象。

**非重点内容精简：**
- 其他三种方法的图表在补充材料中，未在本节展开。

---

### 总结

本章通过多个实验平台（Atari、TORCS、MuJoCo、Labyrinth）全面评估了异步深度强化学习方法（尤其是A3C）的性能。实验结果表明：
- A3C在多种任务中表现优异，尤其在Atari游戏中显著优于现有方法；
- 异步方法在多线程环境下具有良好的可扩展性和数据效率；
- A3C对学习率和初始化具有较强鲁棒性，训练稳定；
- 所有方法在合理设置下均可有效训练，适用于视觉输入和连续动作控制等复杂任务。


## 6 Conclusions and Discussion


本章节总结了作者提出的四种标准强化学习算法的异步版本，并展示了它们在多种任务中稳定训练神经网络控制器的能力。以下是该章节内容的结构化总结：

---

### **主要结论**

- 作者提出了四种标准强化学习算法的**异步版本**，包括基于值函数（value-based）和基于策略（policy-based）的方法，适用于**离散与连续动作空间**。
- 实验结果表明，这些异步方法在多个任务中都能实现**稳定训练**，并且在Atari游戏任务中，使用16个CPU核心的异步A3C算法训练速度**超过了使用Nvidia K40 GPU的DQN**，且A3C在**一半训练时间内就超过了当前的最先进水平**。

---

### **异步方法的稳定性**

- 一个关键发现是：**使用多个并行的actor-learner（执行者-学习者）来更新共享模型**，对三种基于值函数的方法起到了**稳定学习过程**的作用。
- 这表明，即使**不使用经验回放机制**（如DQN中所用），也可以实现稳定的在线Q学习。
- 但作者也指出，经验回放仍然具有**提升数据效率**的潜力，尤其是在与异步框架结合时，可以**重复利用旧数据**，从而加快训练速度（例如在TORCS等环境交互成本较高的任务中）。

---

### **未来改进方向：算法层面**

作者提出了多个可以结合现有强化学习方法进行改进的方向：

1. **n步方法的改进**：
   - 当前的n步方法采用的是*Sutton & Barto*提出的“**前向视角**”（forward view）。
   - 未来可以尝试使用“**后向视角**”（backward view）结合**资格迹**（eligibility traces）来隐式融合不同步长的回报。

2. **优势函数估计的改进**：
   - 异步优势Actor-Critic（A3C）方法可以结合**广义优势估计**（Generalized Advantage Estimation, GAE）来提升性能。

3. **减少Q值高估偏差**：
   - 可以引入如**Double Q-learning**或**Distributional RL**等技术来减少Q值估计的高估问题。

4. **在线时序差分方法的结合**：
   - 探索将**True Online TD方法**与非线性函数逼近结合，可能带来新的突破。

---

### **未来改进方向：网络结构层面**

作者还提出了一些神经网络架构上的改进方向：

1. **Dueling网络结构**：
   - 通过将状态价值和优势函数分开建模，可以提升Q值估计的准确性。

2. **空间Softmax（Spatial Softmax）**：
   - 这种结构有助于网络更好地表示特征坐标，从而提升基于值函数和策略的方法的表现。

---

### **致谢（Acknowledgments）**

- 作者感谢多位DeepMind的研究人员对论文的讨论、建议和反馈。
- 同时感谢DeepMind的评估团队为实验环境搭建所做的工作。

---

### 总结

本章节强调了异步强化学习方法在稳定性和训练效率上的优势，并提出了多个未来研究方向，包括算法改进（如优势估计、经验回放、资格迹）和网络结构优化（如Dueling网络、空间Softmax）。这些方向为异步强化学习的进一步发展提供了明确的路径。


## 7 Optimization Details


本节主要讨论了在异步框架下使用的两种优化算法：**随机梯度下降（SGD）** 和 **RMSProp**，并比较了它们在不同设置下的性能表现，尤其是对学习率和网络初始化的鲁棒性。

---

### Momentum SGD

- **实现方式**：在异步环境下，Momentum SGD 的实现较为简单且已有研究基础。每个线程独立维护自己的梯度和动量向量。
- **更新公式**：
  - 动量更新：$ m_i = \alpha m_i + (1 - \alpha)\Delta\theta_i $
  - 参数更新：$ \theta \leftarrow \theta - \eta m_i $
- **特点**：不使用任何锁机制，以提高多线程下的吞吐量。

---

### RMSProp

- **背景**：RMSProp 在深度学习中广泛使用，但在异步优化环境下的研究较少。
- **标准更新公式**：
  - 平方梯度移动平均：$ g = \alpha g + (1 - \alpha)\Delta\theta^2 $
  - 参数更新：$ \theta \leftarrow \theta - \eta \frac{\Delta\theta}{\sqrt{g + \epsilon}} $
- **异步设置下的两种变体**：
  1. **RMSProp（每线程维护 g）**：每个线程维护自己的平方梯度统计量 $ g $。
  2. **Shared RMSProp（共享 g）**：所有线程共享一个 $ g $ 向量，并异步更新，不加锁。
     - 优点：减少内存占用（每个线程少存一份参数）。
     - 潜在优势：通过共享统计信息，可能提升算法鲁棒性。

---

### 算法比较

- **比较维度**：不同学习率和网络初始化下的**性能**与**鲁棒性**。
- **实验设置**：
  - 使用两种强化学习方法（Async n-step Q 和 Async Advantage Actor-Critic）。
  - 在四个 Atari 游戏（Breakout, Beamrider, Seaquest, Space Invaders）上进行测试。
  - 每种方法运行 50 次实验，对应 50 组随机学习率和初始化。
- **评估方式**：
  - x轴：模型按最终平均得分排序后的排名。
  - y轴：模型最终平均得分。
  - 更好的算法：在 y 轴上得分更高（性能好），曲线更平缓（鲁棒性强）。
- **结论**：
  - **Shared RMSProp > RMSProp > Momentum SGD**
  - Shared RMSProp 表现出最强的鲁棒性，其次是 RMSProp，Momentum SGD 最弱。

---

### 总结

本节重点在于：
- 异步环境下 Momentum SGD 和 RMSProp 的实现方式；
- RMSProp 的两种变体及其优劣；
- 通过大量实验验证 Shared RMSProp 在鲁棒性和性能上的优势。

非重点内容（已精简）：
- 具体数学公式推导；
- 图表细节（如图 S5 的具体数据分布）。


## 8 Experimental Setup


本节详细描述了在 Atari 游戏和 TORCS 实验中所使用的统一实验设置，主要包括以下几个方面：

---

### 1. **实验平台与并行设置**
- 所有实验均使用**单台机器运行16个actor-learner线程**，**不使用GPU**。
- 所有方法每执行5个动作（`t_max=5`）进行一次更新，优化器使用**共享RMSProp**。

---

### 2. **网络结构与输入处理**
- **Atari实验**：
  - 输入预处理与Mnih等人（2015）相同，动作重复（action repeat）为4。
  - 使用Mnih等人（2013）提出的网络结构：
    - 第一层：16个8×8卷积核，步长4；
    - 第二层：32个4×4卷积核，步长2；
    - 第三层：256个单元的全连接层；
    - 每层后接ReLU激活函数。
  - **价值方法**：每个动作对应一个线性输出单元（表示Q值）。
  - **Actor-Critic方法**：输出包括：
    - softmax输出（每个动作的概率）；
    - 一个线性输出表示状态价值函数。

---

### 3. **训练参数与优化设置**
- 折扣因子 γ = 0.99，RMSProp衰减因子 α = 0.99。
- **探索策略（价值方法）**：
  - ε 从三个值中采样（ε₁, ε₂, ε₃），概率分别为0.4、0.3、0.3；
  - 这些值在前四百万帧中分别从1退火到0.1、0.01、0.5。
- **Actor-Critic方法**：
  - 使用熵正则化，权重 β = 0.01。

---

### 4. **超参数搜索与评估协议**
- 对**5个Atari游戏**和**每个TORCS关卡**进行了**50次实验**，每次使用不同的随机初始化和初始学习率。
- 初始学习率从 LogUniform(10⁻⁴, 10⁻²) 中采样，并在训练过程中退火至0。
- **与先前工作的对比**（见表格5.1）中使用了**固定超参数**以遵循标准评估协议。

---

### 总结
本节提供了实验的统一设置，强调了**异步多线程架构**、**网络结构一致性**、**探索策略与正则化机制**，以及**超参数搜索与评估标准**。这些设置为后续实验结果的可比性和稳定性提供了保障。


## 9 Continuous Action Control Using the MuJoCo Physics Simulator


### 1. 简介与背景
本章主要探讨如何将**异步优势演员-评论家（A3C）算法**应用于 MuJoCo 任务。与离散动作空间的设置几乎相同，但重点在于连续动作空间的实现差异。任务的物理模型和目标与 Lillicrap 等人（2015）的研究相似，但由于 MuJoCo 开发者对接触模型的修改，导致奖励和性能指标不可直接比较。

---

### 2. 输入与网络结构

#### 2.1 输入设置
- **物理状态输入**：包括关节位置、速度，以及任务目标位置（如需要）。
- **RGB 像素输入**：在部分任务（如 pendulum、pointmass2D、gripper）中，直接使用像素输入进行训练。

#### 2.2 网络结构
- **物理状态输入处理**：通过一个包含 200 个 ReLU 单元的隐藏层。
- **像素输入处理**：使用两层空间卷积（无非线性或池化操作）。
- **编码器输出**：输入到 128 个 LSTM 单元的循环层。

#### 2.3 策略网络输出层（重点）
- **与离散动作空间的主要区别**：
  - 输出为两个实数向量，分别表示多维正态分布的均值 μ 和标量方差 σ²。
  - 采样动作时，根据 μ 和 σ² 构建的正态分布进行采样。
  - μ 由线性层建模，σ² 通过 SoftPlus 激活函数（log(1 + exp(x))）计算。
- **策略网络与价值网络参数不共享**，但该细节对性能影响不大。
- **更新方式**：由于每轮训练通常只有几百步，未使用引导（bootstrapping），而是将整个 episode 作为一个更新批次。

---

### 3. 探索机制与算法表现

#### 3.1 熵成本（Entropy Cost）
- 在连续控制中，使用正态分布的微分熵作为探索成本：
  - 公式：−1/2 (log(2πσ²) + 1)
  - 所有任务统一使用 10⁻⁴ 作为乘数。

#### 3.2 A3C 算法表现
- A3C 成功解决了所有 MuJoCo 任务。
- **学习曲线**显示，大多数任务在几小时内即可解决。
- **从像素输入训练**：即使使用像素输入，也能在 24 小时内找到稳定解。
- **学习率影响**：散点图显示，大多数任务在较宽的学习率范围内都能取得良好表现。

---

### 4. 算法伪代码（补充）

#### 4.1 异步 n 步 Q 学习（Algorithm S2）
- 每个线程独立运行环境，定期与全局参数同步。
- 使用 n 步回报更新 Q 值。
- 包含目标网络（θ⁻）用于稳定训练。

#### 4.2 异步优势演员-评论家（A3C，Algorithm S3）
- 使用策略 π(at|st; θ') 选择动作。
- 价值函数 V(st; θv') 用于优势估计。
- 同时更新策略网络和价值网络的梯度。

---

### 5. 实验结果与对比

#### 5.1 优化方法对比（Figure S5）
- 对比了 Momentum SGD、RMSProp、共享 RMSProp。
- 使用 Async n 步 Q 和 A3C 算法在 Breakout、Beamrider、Seaquest 和 Space Invaders 上测试。
- **结论**：共享 RMSProp 在不同学习率和初始化下更稳健。

#### 5.2 TORCS 赛车模拟器实验（Figure S6）
- 测试了四种算法（one-step Q、one-step Sarsa、n-step Q、A3C）。
- 多步算法（n-step Q、A3C）比单步算法更快收敛到更优策略。

#### 5.3 MuJoCo 连续动作任务表现（Figure S7 - S8）
- **学习率影响**：大多数任务在 10⁻⁵ 到 10⁻¹ 的学习率范围内表现良好。
- **训练时间**：得分随时间变化的曲线显示，A3C 在多个任务上快速提升。

#### 5.4 并行训练效率（Figure S9 - S10）
- **数据效率**：随着并行线程数增加，Sarsa 的数据利用率提高。
- **训练速度**：更多并行线程显著加快训练速度。

#### 5.5 算法鲁棒性（Figure S11）
- 对比 one-step Q、one-step Sarsa、n-step Q 在多个游戏上的表现。
- 所有算法在不同学习率和初始化下都表现出一定鲁棒性。

---

### 6. 补充表格与数据（Table S3）

- 提供了 DQN、Double DQN、Dueling、Prioritized 等算法在人类起始条件下的原始得分（30 分钟模拟时间）。
- 数据来源：Nair et al. (2015)、Van Hasselt et al. (2015)、Wang et al. (2015)、Schaul et al. (2015)。

---

### 总结
本章详细介绍了 A3C 算法在 MuJoCo 连续动作控制任务中的应用，重点在于策略网络输出层的设计（正态分布参数化）、探索机制（熵成本）以及异步更新机制。实验结果表明，A3C 在物理状态和像素输入下均能高效学习，且对学习率具有较强鲁棒性。此外，多步算法在 TORCS 和 Atari 游戏中表现优于单步方法，而并行训练显著提升了训练效率和数据利用率。
