# ❇️1707.06347_PPO: Proximal Policy Optimization Algorithms

* 首页: <https://arxiv.org/abs/1707.06347>
* PDF: <https://arxiv.org/pdf/1707.06347>
* 引用: 32180(2025-11-18)
* 组织:
    * OpenAI




## 总结

### 关键定义

* 状态价值函数 $V(s)$： 预测从状态 $s$ 开始，未来能获得的总回报的平均值。它回答了“这个状态总体上看有多好？”
* 动作价值函数 $Q(s, a)$： 预测在状态 $s$ 下采取动作 $a`，然后遵循当前策略，能获得的总回报。它回答了“在这个状态下做这个特定动作有多好？”
* 优势函数 $\hat{A}_t$ 衡量的是在状态 $s_t$ 下采取动作 $a_t$，相对于在该状态下采取平均动作而言，要好多少。
    * 在 PPO 中，我们不知道真实的 $A(s, a)$，所以需要使用经验数据来估计它，这就是 $\hat{A}_t$。
    * 优势函数就是它们的差，公式: $A(s, a) = Q(s, a) - V(s)$
        * 如果 $A(s, a) > 0$：说明动作 $a$ 优于 平均水平，应该被鼓励。
        * 如果 $A(s, a) < 0$：说明动作 $a$ 差于 平均水平，应该被抑制。
        * 如果 $A(s, a) = 0$：说明动作 $a$ 就是平均水平。

* 重要性采样比率： π_θ / π_θ_old 这个比值衡量了新策略相对于旧策略对某个动作（在这里是生成某个词元）的偏好变化。如果比值>1，说明新策略更倾向于这个动作；反之则相反。
* 优势函数 Â_t： 它衡量的是在某个状态下生成某个词元，相比平均情况要好多少。Â_t > 0 是好事，应该鼓励；Â_t < 0 是坏事，应该抑制。
  - 裁剪的作用：
    - 当 Â_t > 0（应鼓励该动作）时，我们希望增大 π_θ / π_θ_old。但PPO通过 clip 将其上限限制在 1+ε，防止因为这个动作太好而被过度优化，从而忽略了其他可能性。
    - 当 Â_t < 0（应抑制该动作）时，我们希望减小 π_θ / π_θ_old。同样，clip 将其下限限制在 1-ε，防止因为这个动作太差而被一棍子打死，完全不再采样。
  - 最终，PPO目标是在裁剪后的目标和未裁剪的目标中取最小值，形成一个悲观的估计，从而进一步约束更新幅度。



### 三行摘要（MoonLight）

1. 🌟 本文提出了一种名为近端策略优化（PPO）的新型策略梯度方法，旨在结合信赖域策略优化（TRPO）的稳定性和数据效率，同时简化实现并提高泛化能力。
2. 💡 PPO通过在与环境交互采样数据后，使用多个小批量更新周期来优化一个新颖的“替代目标函数”（特别是带有裁剪概率比率的目标），从而在不限制策略变化过大的前提下实现高效更新。
3. 🚀 实验结果表明，PPO在连续控制和Atari游戏等基准任务上，相比其他在线策略梯度方法具有更优的性能和样本效率，并在实现复杂度、通用性和训练时间之间取得了良好平衡。

### 摘要（MoonLight）

这篇论文提出了一系列名为近端策略优化（Proximal Policy Optimization, PPO）的强化学习策略梯度方法。这些方法通过与环境交互采样数据，然后使用随机梯度上升优化一个“替代（surrogate）”目标函数，以此在采样和优化之间交替进行。与标准策略梯度方法每次数据采样只执行一次梯度更新不同，PPO引入了一种新颖的目标函数，允许对同一批采样数据进行多轮（multiple epochs）小批量（minibatch）更新。PPO 方法融合了信赖域策略优化（Trust Region Policy Optimization, TRPO）的一些优点，但实现起来更简单、更通用，并且在经验上具有更好的样本效率。论文在模拟机器人运动和Atari游戏等基准任务上测试了PPO，结果表明PPO优于其他在线策略梯度方法，并在样本效率、实现简易性和运行时间之间取得了良好的平衡。

**2 背景：策略优化**

**2.1 策略梯度方法**
策略梯度方法通过计算策略梯度的估计量并将其代入随机梯度上升算法进行优化。最常用的梯度估计量形式为：
$$ \hat{g} = \hat{E}_t[\nabla_\theta \log \pi_\theta(a_t | s_t) \hat{A}_t] $$
其中 $\pi_\theta$ 是随机策略，$\hat{A}_t$ 是在时间步 $t$ 的优势函数（advantage function）估计量。$\hat{E}_t[. . .]$ 表示对有限批次样本的经验平均。使用自动微分软件时，通常构造一个目标函数，其梯度就是策略梯度估计量：
$$ L^{PG}(\theta) = \hat{E}_t[\log \pi_\theta(a_t | s_t) \hat{A}_t] $$
虽然对同一轨迹数据多次优化这个损失函数 $L^{PG}$ 很有吸引力，但这缺乏充分的理论依据，并且在实践中常常导致破坏性过大的策略更新。



**2.2 信赖域方法**
TRPO 方法通过最大化一个“替代”目标函数，同时对策略更新的大小施加约束。具体来说，TRPO解决以下优化问题：
$$ \text{maximize}_\theta \hat{E}_t\left[\frac{\pi_\theta(a_t | s_t)}{\pi_{\theta_{old}}(a_t | s_t)} \hat{A}_t\right] $$
$$ \text{subject to } \hat{E}_t[KL[\pi_{\theta_{old}}(\cdot | s_t), \pi_\theta(\cdot | s_t)]] \leq \delta $$
其中 $\theta_{old}$ 是更新前的策略参数。这个问题可以通过共轭梯度算法进行线性近似目标和二次近似约束来近似高效求解。
TRPO的理论依据实际上建议使用惩罚项而非硬约束，即求解无约束优化问题：
$$ \text{maximize}_\theta \hat{E}_t\left[\frac{\pi_\theta(a_t | s_t)}{\pi_{\theta_{old}}(a_t | s_t)} \hat{A}_t - \beta KL[\pi_{\theta_{old}}(\cdot | s_t), \pi_\theta(\cdot | s_t)]\right] $$
对于某个系数 $\beta$。然而，TRPO选择硬约束是因为很难选择一个在不同问题或学习过程中始终表现良好的固定 $\beta$ 值。因此，简单地选择固定 $\beta$ 并用SGD优化带惩罚项的目标函数不足以模拟TRPO的单调改进特性，需要额外的修改。

**3 剪裁的替代目标函数**
令 $r_t(\theta) = \frac{\pi_\theta(a_t | s_t)}{\pi_{\theta_{old}}(a_t | s_t)}$ 为概率比率，则 $r_t(\theta_{old}) = 1$。TRPO最大化的替代目标函数为 $L^{CPI}(\theta) = \hat{E}_t[r_t(\theta) \hat{A}_t]$。在没有约束的情况下，最大化 $L^{CPI}$ 会导致过大的策略更新。
论文提出的主要目标函数是：
$$ L^{CLIP}(\theta) = \hat{E}_t[\min(r_t(\theta) \hat{A}_t, \text{clip}(r_t(\theta), 1 - \epsilon, 1 + \epsilon) \hat{A}_t)] $$
其中 $\epsilon$ 是一个超参数，例如 $\epsilon = 0.2$。这个目标的动机如下：
1.  `min` 函数内的第一项是 $L^{CPI}$。
2.  第二项 $\text{clip}(r_t(\theta), 1 - \epsilon, 1 + \epsilon) \hat{A}_t$ 通过剪裁概率比率 $r_t(\theta)$ 到 $[1 - \epsilon, 1 + \epsilon]$ 区间内来修改替代目标，从而消除了将 $r_t$ 推到该区间之外的动机。
3.  最终，取剪裁和未剪裁目标之间的最小值，使得最终目标成为未剪裁目标的一个下界（即一个悲观界）。
这种机制下，当概率比率的变化能改善目标时，它只在一定范围内（由 $\epsilon$ 决定）被考虑；而当它使目标恶化时，则会完全计入。这意味着该目标函数限制了策略更新的大小，以避免过大的更新，同时仍然允许在合理范围内进行改进。在 $\theta$ 接近 $\theta_{old}$（即 $r=1$）的一阶近似下，$L^{CLIP}(\theta) = L^{CPI}(\theta)$，但当 $\theta$ 远离 $\theta_{old}$ 时，它们会变得不同。

**4 自适应KL惩罚系数**
另一种方法是使用KL散度惩罚项，并自适应地调整惩罚系数，以使每次策略更新的KL散度达到目标值 $d_{targ}$。虽然实验发现KL惩罚的表现不如剪裁替代目标，但它是一个重要的基线。
该算法的简化实现步骤如下：
*   使用多轮小批量SGD优化KL惩罚目标函数：
    $$ L^{KLPEN}(\theta) = \hat{E}_t\left[\frac{\pi_\theta(a_t | s_t)}{\pi_{\theta_{old}}(a_t | s_t)} \hat{A}_t - \beta KL[\pi_{\theta_{old}}(\cdot | s_t), \pi_\theta(\cdot | s_t)]\right] $$
*   计算 $d = \hat{E}_t[KL[\pi_{\theta_{old}}(\cdot | s_t), \pi_\theta(\cdot | s_t)]]$。
    *   如果 $d < d_{targ}/1.5$，则更新 $\beta \leftarrow \beta/2$。
    *   如果 $d > d_{targ} \times 1.5$，则更新 $\beta \leftarrow \beta \times 2$。
更新后的 $\beta$ 用于下一次策略更新。

**5 算法**
PPO可以很容易地集成到典型的策略梯度实现中。对于使用自动微分的框架，只需构造 $L^{CLIP}$ 或 $L^{KLPEN}$ 替代 $L^{PG}$，并在此目标函数上执行多步随机梯度上升。
为了计算方差缩减的优势函数估计量，通常会利用学习到的状态值函数 $V(s)$，例如广义优势估计（Generalized Advantage Estimation, GAE）。如果策略和值函数共享神经网络参数，则需要一个结合策略替代损失和值函数误差项的损失函数。为了鼓励探索，还可以添加一个熵奖励项。综合这些项，每次迭代近似最大化的目标函数为：
$$ L^{CLIP+VF+S}(\theta) = \hat{E}_t[L^{CLIP}(\theta) - c_1 L^{VF}(\theta) + c_2 S[\pi_\theta](s_t)] $$
其中 $c_1, c_2$ 是系数，$S$ 是熵奖励项，$L^{VF}_t$ 是均方误差损失 $(V_\theta(s_t) - V^{targ}_t)^2$。
算法1展示了PPO的Actor-Critic风格实现，该算法使用固定长度的轨迹片段。在每次迭代中，N个（并行）Actor收集T个时间步的数据。然后，利用这NT个时间步的数据构建替代损失函数，并通过K轮（epochs）小批量SGD（通常使用Adam优化器）进行优化。

**6 实验**
**6.1 替代目标函数的比较**
实验首先比较了 $L^{CLIP}$ 及其变体和消融版本，包括“无剪裁或惩罚”、“剪裁”（不同 $\epsilon$ 值）、“KL惩罚”（固定 $\beta$ 或自适应 $d_{targ}$）。在7个MuJoCo模拟机器人任务上进行了一百万时间步的训练。结果表明，“剪裁，$\epsilon=0.2$”的表现最佳，平均归一化得分最高。无剪裁或惩罚的设置表现最差，因为它可能导致非常负的得分。

**6.2 与连续域中其他算法的比较**
PPO（使用剪裁替代目标，$\epsilon=0.2$）与TRPO、交叉熵方法（CEM）、带自适应步长的Vanilla策略梯度、A2C和带信赖域的A2C进行了比较。实验结果（如图3所示）表明，PPO在几乎所有连续控制环境中都优于这些现有方法。

**6.3 连续域中的展示：Humanoid奔跑与转向**
为了展示PPO在高维连续控制问题上的性能，论文在涉及3D人形机器人的任务上进行了训练，包括RoboschoolHumanoid（仅向前移动）、RoboschoolHumanoidFlagrun（目标位置随机变化）和RoboschoolHumanoidFlagrunHarder（机器人会被方块击打且需要从地面站起）。PPO在这些任务上都展现了强大的学习能力。

**6.4 与Atari域中其他算法的比较**
PPO还在Arcade Learning Environment基准上与A2C和ACER进行了比较。在49款游戏上的比较结果（见表2）显示，在“训练期间平均每集奖励”指标上，PPO在30款游戏中胜出，ACER在18款中胜出。在“最后100集平均每集奖励”指标上，ACER在28款游戏中胜出，PPO在19款中胜出。这表明PPO在学习速度上具有优势，而ACER在最终性能上略有优势，尽管PPO实现更简单。

**7 结论**
论文引入了近端策略优化（PPO）算法族，这是一种在每次策略更新中使用多轮随机梯度上升的策略优化方法。PPO具有信赖域方法的稳定性和可靠性，但实现起来要简单得多，仅需对Vanilla策略梯度实现进行几行代码的修改，并且适用于更通用的设置（例如，策略和值函数使用联合架构），总体性能也更好。


## From DeepSeek

FROM: <https://chat.deepseek.com/a/chat/s/c8a81059-899d-4ba1-b9b1-bbbd232690e3>

PPO 是 OpenAI 在 2017 年提出的一种强化学习算法，它迅速成为了**最流行、最实用的强化学习算法之一**，广泛应用于从游戏 AI（如 Dota 2、星际争霸）到机器人控制等各种领域。


### 背景

核心思想：在稳定性和效率之间取得平衡

要理解 PPO，首先要明白它要解决什么问题。在 PPO 之前，主流的策略梯度算法（如 TRPO）存在一些痛点：

*   **策略更新步长难以确定**：步长太小，学习速度太慢；步长太大，一次糟糕的更新就可能让策略性能崩溃，且难以恢复。
*   **样本效率低**：在on-policy学习中，每次策略更新后，之前收集的数据就作废了，需要重新采样。

PPO 的核心目标就是：**如何以一种简单、高效且稳定的方式，进行大步长的策略优化。**

---

### 2. 关键创新：Clipped Surrogate Objective

PPO 通过一个“裁剪”的替代目标函数来限制策略的更新幅度，确保新策略（$\pi_{\theta}$）不会偏离旧策略（$\pi_{\theta_{old}}$）太远。

#### 2.1 核心概念：概率比

首先，定义一个**概率比**：
$$r_t(\theta) = \frac{\pi_{\theta}(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t)}$$

*   如果 $r_t(\theta) > 1$，表示新策略选择这个动作的概率比旧策略**更高**。
*   如果 $r_t(\theta) < 1$，表示新策略选择这个动作的概率比旧策略**更低**。

在标准的策略梯度中，我们通过这个比值来调整策略，使其倾向于选择能带来更高回报的动作。

#### 2.2 替代目标函数

PPO 的核心是优化下面的替代目标函数：
$$L^{CLIP}(\theta) = \mathbb{E}_t [ \min( r_t(\theta) \hat{A}_t, \text{clip}(r_t(\theta), 1-\epsilon, 1+\epsilon) \hat{A}_t ) ]$$

这里：
*   $\hat{A}_t$ 是**优势函数**，衡量在状态 $s_t$ 下执行动作 $a_t$ 比平均情况好多少。如果 $\hat{A}_t$ 为正，说明这个动作是好的；为负则说明是坏的。
*   $\epsilon$ 是一个超参数（例如 0.2），定义了**裁剪的范围**。

#### 2.3 “裁剪”如何工作？

这个 `min` 和 `clip` 操作是 PPO 的精髓，它巧妙地防止了策略的剧烈变化。我们分两种情况来理解：

1.  **当优势 $\hat{A}_t$ 为正时（好动作）**：
    *   我们希望**增加**这个动作的概率，即让 $r_t(\theta)$ 变大。
    *   目标函数的第一项 $r_t(\theta)\hat{A}_t$ 会鼓励 $r_t(\theta)$ 增大。
    *   但第二项 $\text{clip}(r_t(\theta), 1-\epsilon, 1+\epsilon)\hat{A}_t$ 会将 $r_t(\theta)$ **限制在** $1+\epsilon$ 以内。
    *   `min` 操作会在这两者中取**较小值**，从而防止因为 $r_t(\theta)$ 变得过大而导致策略更新步长过大。

    

2.  **当优势 $\hat{A}_t$ 为负时（坏动作）**：
    *   我们希望**减少**这个动作的概率，即让 $r_t(\theta)$ 变小。
    *   目标函数的第一项 $r_t(\theta)\hat{A}_t$（此时 $\hat{A}_t$ 为负）会鼓励 $r_t(\theta)$ 减小。
    *   第二项会将 $r_t(\theta)$ **限制在** $1-\epsilon$ 以上。
    *   `min` 操作同样会取较小值，防止 $r_t(\theta)$ 变得过小。

    

**总结来说**：Clipping 机制就像一个“安全阀”，无论动作是好是坏，它都阻止新策略在单次更新中相对旧策略发生超过 $\epsilon$ 的变化。这保证了训练的稳定性。

---

### 3. PPO 的算法流程

一个标准的 PPO 算法流程（通常指 PPO-Clip）如下：

1.  **初始化** 策略网络参数 $\theta$ 和价值网络参数 $\phi$。
2.  **循环**，直到收敛：
    *   a. **收集数据**：使用当前策略 $\pi_{\theta}$ 与环境交互，收集一定数量的轨迹数据（状态、动作、奖励）。
    *   b. **计算优势估计**：基于收集的数据，使用 GAE 等方法计算每个时间步的优势值 $\hat{A}_t$。
    *   c. **优化**：在收集到的这批数据上，进行多轮（例如 K=3 到 10 轮）小批量梯度下降，优化以下**组合目标函数**：
        $$L^{TOTAL}(\theta) = \mathbb{E}_t [ L^{CLIP}(\theta) - c_1 L^{VF}(\phi) + c_2 S[\pi_{\theta}](s_t) ]$$
        *   $L^{CLIP}(\theta)$： 上文介绍的核心裁剪目标。
        *   $L^{VF}(\phi)$： **价值函数损失**（通常是均方误差），用于训练价值网络来更准确地估计状态价值，从而更好地计算优势。
        *   $S$： **策略熵**，用于鼓励探索。熵越大，策略的随机性越强。
        *   $c_1, c_2$： 控制各项权重的系数。
3.  用优化后的新策略 $\pi_{\theta}$ 替换旧策略 $\pi_{\theta_{old}}$，回到步骤 2。

**注意**：PPO 通过在**同一批数据上多次更新**，大大提高了样本利用效率。

---

### 4. PPO 的优点与缺点

#### 优点：

1.  **易于实现**： 相比 TRPO（需要使用复杂的共轭梯度法），PPO 只需要标准的一阶梯度下降，非常容易编码。
2.  **样本效率高**： 通过 epoch 机制重复利用数据。
3.  **稳健性强**： Clipping 机制使其对超参数（尤其是学习率）不那么敏感，训练过程非常稳定，不容易崩溃。
4.  **性能出色**： 在多种任务上都表现出了强大且一致的性能。

#### 缺点：

1.  **超参数调优**： 虽然相对稳健，但 $\epsilon$, 学习率, epoch 数等超参数仍然需要针对具体任务进行调整。
2.  **并非最优**： 在某些问题上，其性能可能不如 TRPO 等更复杂的算法。
3.  **敏感性问题**： 对价值函数损失的权重 $c_1$ 和优势函数的估计方法比较敏感。

---

### 5. 总结

**Proximal Policy Optimization (PPO)** 成功地将稳健的理论思想（限制策略更新幅度）与简洁实用的工程实现（Clipping 目标函数）相结合。它通过一个巧妙的目标函数设计，解决了强化学习训练中的稳定性和样本效率两大核心难题，使其成为一个“开箱即用”效果就不错的通用强化学习算法，这也是它能够如此流行的根本原因。

对于任何想进入深度强化学习领域的学习者和实践者来说，PPO 都是一个必须深入理解和掌握的基础算法。

---

## 示例-FromDeepseek
 
### 场景设定

想象一个简单的游戏：
- **状态 (s)**: 小球在某个位置
- **动作 (a)**: 机器人可以选择 **“向左用力”**、**“向右用力”** 或 **“轻轻向右”**
- **目标**: 让小球到达目标点

假设在某个状态 `s` 下，旧策略 `π_old` 对三个动作的概率分布是：
- 向左用力: 0.2
- 向右用力: 0.7
- 轻轻向右: 0.1

现在，我们收集到一条数据：在状态 `s` 下，我们**实际执行**了动作 **“向右用力”** (`a`)，并且计算出的**优势值 `Â` 为 +0.5**。这意味着“向右用力”是一个比平均情况要好的动作。

---

### 1. 计算概率比 (r_tθ)

首先，新策略（我们正在训练的网络）也会对状态 `s` 输出一个概率分布。假设新策略的输出是：
- 向左用力: 0.1
- 向右用力: 0.8
- 轻轻向右: 0.1

我们关注的是实际执行的动作 **“向右用力”**。

- **旧策略** 选择“向右用力”的概率： `π_old(a|s) = 0.7`
- **新策略** 选择“向右用力”的概率： `π_θ(a|s) = 0.8`

所以，**概率比** `r_t(θ)` 为：
`r_t(θ) = 0.8 / 0.7 ≈ 1.14`

这个比值大于1，说明新策略比旧策略更倾向于选择这个好的动作。

---

### 2. 应用 PPO 的 Clipping 机制

PPO 的目标函数是：
`L = min( r_t(θ) * Ât, clip(r_t(θ), 1-ε, 1+ε) * Ât )`

假设我们设置 PPO 的超参数 `ε = 0.2`。

- **第一项（无裁剪）**: `r_t(θ) * Ât = 1.14 * 0.5 = 0.57`
- **第二项（有裁剪）**: 
    - `clip(r_t(θ), 1-ε, 1+ε) = clip(1.14, 0.8, 1.2) = 1.14`
    - （因为 1.14 在 [0.8, 1.2] 区间内，所以不被裁剪，保持不变）
    - `clip(...) * Ât = 1.14 * 0.5 = 0.57`

- **最终目标值**: `min(0.57, 0.57) = 0.57`

**情况分析**：由于概率比 `1.14` 没有超过上限 `1.2`，所以 clipping 没有生效。优化过程会正常地**鼓励新策略增加**对这个好动作的选择概率。损失函数为 `-0.57`（因为我们要最大化 `L`，通常等同于最小化 `-L`），梯度下降会更新网络参数，使得 `π_θ(“向右用力”|s)` 变得更大。

---

### 3. Clipping 起作用的场景

现在，假设在另一次更新中，新策略变得“过于激进”，它认为“向右用力”这个动作非常好，于是将其概率提到了一个非常高的值，比如：
- 新策略 `π_θ(“向右用力”|s) = 0.95`

我们重新计算概率比：
`r_t(θ) = 0.95 / 0.7 ≈ 1.36`

现在这个值超过了我们设定的上限 `1.2`。

再次计算目标函数：
- **第一项（无裁剪）**: `1.36 * 0.5 = 0.68`
- **第二项（有裁剪）**: 
    - `clip(1.36, 0.8, 1.2) = 1.2`
    - `1.2 * 0.5 = 0.6`

- **最终目标值**: `min(0.68, 0.6) = 0.6`

**情况分析**：Clipping 机制生效了！虽然新策略“想”把目标值提升到 `0.68`，但 PPO 将其限制在了 `0.6`。这意味着，当新策略过于偏离旧策略时，PPO 会**阻止它进一步朝这个方向更新**。

**为什么这样做？** 因为策略的剧烈变化是危险的。虽然当前数据表明“向右用力”是好的，但可能在某些类似状态下一味地“向右用力”会导致失败。PPO 相信旧策略（之前验证过的策略）是相对可靠的，所以不允许新策略在一次更新中就变得面目全非。这就像给优化过程加了一个“阻尼器”，防止振荡和崩溃。

---

### 另一个例子：处理坏动作

如果动作是一个坏动作（`Â = -0.5`），而新策略将其概率从 `0.2` 降到了 `0.05`。
- `r_t(θ) = 0.05 / 0.2 = 0.25`
- 下限是 `1 - ε = 0.8`
- **第一项**: `0.25 * (-0.5) = -0.125`
- **第二项**: `clip(0.25, 0.8, 1.2) * (-0.5) = 0.8 * (-0.5) = -0.4`
- **最终目标值**: `min(-0.125, -0.4) = -0.4`

同样，Clipping 阻止了新策略将这个动作的概率降得过低（从 `0.2` 降到 `0.05` 的幅度太大了），将其更新幅度限制在了相当于概率比为 `0.8` 的水平。

### 总结示例

通过这个例子，你可以看到 PPO 的 Clipping 机制就像一个**智能的、自动的“学习率调节器”**：

- 当策略更新幅度在安全范围内（`r_t(θ)` 在 `[0.8, 1.2]` 之间），它不干涉。
- 当策略试图进行过于激进的更新时（`r_t(θ)` 超出 `[0.8, 1.2]`），它会“踩刹车”，将更新效果限制在安全范围内。

这种机制确保了整个训练过程的平滑和稳定，使其不容易崩溃，这也是 PPO 如此强大和流行的关键原因。




















