# ❇️2506.07398_G-Memory: Tracing Hierarchical Memory for Multi-Agent Systems

* 首页: <https://arxiv.org/abs/2506.07398>
* PDF: <https://arxiv.org/pdf/2506.07398>
* 引用: 14(2025-11-22)
* 组织:
    * 1NUS(National University of Singapore)
    * 2Tongji University
    * 3UCLA(University of California, Los Angeles)
    * 4A*STAR(Agency for Science, Technology and Research，即新加坡科技研究局)
    * 5NTU(Nanyang Technological University)
* GitHub: <https://github.com/bingreeky/GMemory>


## 总结

**标签**
* tag: multi-agent
* remark: prompt(代表论文中有好的 prompt)

**总结**
* 数据集：
    * （附录 A.1）
    * 5个用于测试智能体能力的基准数据集
        * FEVER 和 HotpotQA：使用精确匹配准确率(exact match accuracy)
        * ScienceWorld 和 PDDL：使用进度率(progress rate)
        * ALFWorld：使用成功率(success rate)
* 对比Agent
    * Voyager: 源自《我的世界》游戏智能体
    * MemoryBank: 模仿人类记忆行为，会选择性保留和遗忘信息
    * Generative: 包含两种记忆：1. 原始观察记忆；2. 反思记忆
    * MetaGPT-M: 只关注任务内记忆，即多个智能体在解决单个任务过程中内部存储的信息
    * ChatDev-M: 包含任务内和跨任务两种记忆。但它的跨任务记忆相对简单
    * MacNet-M: 任务内记忆仅包含上一轮产生的最终答案
* 智能体框架
    * AutoGen
    * DyLAN: 一个辩论式框架，类似“LLM辩论”
    * MacNet: 探索去中心化、可扩展的多智能体系统



**背景**

核心问题：为什么多智能体系统需要更好的记忆？

1.  **能力远超单体，但进化不足**：LLM驱动的多智能体系统在认知和执行能力上远超单个智能体，但其**自我进化能力** 受限于**简陋的记忆架构**。
2.  **现有记忆机制的两大缺陷**：
    - **过于简单**：完全忽略了智能体之间**微妙复杂的协作轨迹**。
    - **缺乏定制**：没有跨任务和针对特定智能体的记忆定制，与单体智能体丰富多样的记忆机制形成鲜明对比。
3.  **直接移植单体记忆行不通**：多智能体交互的轨迹非常长（可达单体的10倍），直接将整个长上下文喂给模型不仅效率低下，而且缺乏从协作视角进行的抽象，收益甚微。


**G-Memory 的工作流程**
1.  **粗粒度记忆检索**：基于语义相似度，从查询图中找到一组与当前任务最相关的历史查询节点。
2.  **双向记忆遍历**：这是核心创新。
    - **向上遍历**：从查询图到洞察图，检索与当前任务相关的**高层通用洞察**（例如，协作策略、失败教训）。这能让系统利用跨任务的通用知识。
    - **向下遍历**：从查询图到交互图，利用LLM对原始的、冗长的交互图进行**稀疏化**，提取出与当前任务最相关的**核心协作轨迹子图**。这能紧凑地编码过去的协作经验，避免信息过载。
3.  **记忆增强**：将检索到的高层洞察和核心轨迹，根据每个智能体的**特定角色**进行个性化过滤和初始化，注入到各自的记忆状态中，为其参与后续推理提供相关的历史上下文。
4.  **分层记忆更新**：任务执行完成后，根据环境反馈（成功/失败），更新整个记忆层次结构。
    - **交互图**：记录本次任务的完整对话轨迹。
    - **查询图**：创建一个新的查询节点，并将其与相关的历史查询和洞察节点连接。
    - **洞察图**：从本次任务中总结出新的洞察，并与相关的旧洞察建立连接。

**贡献**：
1.  **识别瓶颈**：首次系统性地指出并分析了MAS自我进化能力的瓶颈在于记忆架构。
2.  **提出方案**：设计了G-Memory，一个基于三层图层次结构的、代理感知的MAS记忆系统。
3.  **充分验证**：通过大量实验证明了其有效性和高效性。

核心价值：G-Memory使多智能体系统从一个需要手动设计或一次性优化的静态架构，向一个能够从过去的协作经验中持续学习、反思并自我进化的动态有机体迈出了关键一步。



**G-Memory 分层记忆架构**

G-Memory的灵感来源于**组织记忆理论**，它通过一个**三层图结构**来管理冗长的MAS交互历史：

1.  **交互图**：
    - **最底层**，存储**最细粒度**的原始数据。
    - 节点：单个**话语**（哪个智能体说了什么）。
    - 边：话语之间的**时序关系**。

2.  **查询图**：
    - **中间层**，存储任务级别的元信息。
    - 节点：**历史查询任务**（包含原始问题、任务状态-成功/失败、以及对应的交互图）。
    - 边：查询任务之间的**语义关联**。

3.  **洞察图**：
    - **最高层**，存储从历史经验中**抽象出的通用化洞察和策略**。
    - 节点：**洞察**（洞察内容 + 支持该洞察的查询任务集合）。
    - 边：洞察之间通过特定查询任务建立的**上下文关联**。






### 摘要(From Moonlight)

**三行摘要**
1. 🤖 现有的大语言模型多智能体系统（MAS）的记忆机制过于简化，未能有效捕捉复杂的智能体间协作轨迹和跨试验知识，严重阻碍了其自我演化能力。
2. 🧠 本文提出了G-Memory，一个受组织记忆理论启发的分层式智能体记忆系统，通过洞察图、查询图和交互图三层图结构管理MAS的冗长交互历史。
3. 🚀 G-Memory通过双向记忆遍历提供定制化的高级洞察和细粒度协作经验，并在任务执行后持续进化，显著提升了多项基准测试中MAS的成功率和准确率，最高分别达到20.89%和10.12%。


G-Memory 是一项旨在解决大型语言模型（LLM）驱动的多智能体系统（MAS）在自进化能力方面受限于其不完善的记忆架构的问题的研究。现有 MAS 的记忆机制过于简化，未能捕捉到智能体之间协作轨迹的细微之处，并且缺乏跨任务（cross-trial）和针对特定智能体的定制化能力。为了弥补这一鸿沟，该论文引入了 G-Memory，一个受组织记忆理论启发的分层、智能体化记忆系统，用于管理 MAS 复杂且冗长的交互历史。

**核心方法（Core Methodology）**

G-Memory 通过一个三层图结构来管理 MAS 的记忆：

1.  **Interaction Graph (交互图)**：对于每个用户查询 $Q$，其交互轨迹被表示为一个图 $G(Q)_{\text{inter}} = (U(Q), E(Q)_u)$。节点 $U(Q) = \{u_i\}$ 代表原子级别的“话语”（utterances），每个 $u_i = (A_i, m_i)$ 包含说话的智能体 $A_i \in V$ 和其文本内容 $m_i$。边 $E(Q)_u \subseteq U(Q) \times U(Q)$ 遵循时间关系，表示话语之间的启发和传递。
2.  **Query Graph (查询图)**：该图存储了以往处理过的查询及其元数据，表示为 $G_{\text{query}} = (Q, E_q) = \left\{ (Q_i, \Psi_i, G(Q_i)_{\text{inter}}) \Big|_{i=1}^{|Q|}, E_q \right\}$。节点 $q_i = (Q_i, \Psi_i, G(Q_i)_{\text{inter}})$ 包含原始查询 $Q_i$、任务状态 $\Psi_i \in \{\text{Failed, Resolved}\}$ 及其关联的交互图 $G(Q_i)_{\text{inter}}$。边 $E_q \subseteq Q \times Q$ 编码查询之间的语义关系，从而支持超越简单嵌入相似度的检索。
3.  **Insight Graph (洞察图)**：最高层的洞察图表示为 $G_{\text{insight}} = (I, E_i) = \left\{ \langle \kappa_k, \Omega_k \rangle \Big|_{k=1}^{|I|}, E_i \right\}$。节点 $I = \{\iota_k\}$ 代表提炼出的洞察（insights），每个节点 $\iota_k$ 由洞察内容 $\kappa_k$ 和一组支持该洞察的查询 $\Omega_k \subseteq Q$ 组成。边 $E_i \subseteq I \times I \times Q$ 形成超连接，表示洞察 $\iota_m$ 通过查询 $q_j$ 为洞察 $\iota_n$ 提供上下文。

**G-Memory 的工作流程**包括三个阶段：

1.  **粗粒度记忆检索 (Coarse-grained Memory Retrieval)**：当接收到新的用户查询 $Q$ 时，G-Memory 首先在查询图 $G_{\text{query}}$ 上执行基于相似度的检索，获取初步相关的查询集合 $Q_S$。
    $$Q_S = \arg \max_{q_i \in Q, |Q_S|=k} \left( \frac{v(Q) \cdot v(q_i)}{|v(Q)| |v(q_i)|} \right)$$
    其中 $v(\cdot)$ 将查询映射到固定长度的嵌入。为了扩大相关范围并捕获拓扑关系，G-Memory 进一步通过在查询图上进行跳（hop）扩展来扩充相关集合 $\tilde{Q_S}$，通常是 1 跳邻居。

2.  **双向记忆遍历 (Bi-directional Memory Traversal)**：
    *   **向上遍历 (Upward Traversal)**：从 $\tilde{Q_S}$ 向上遍历到洞察图 $G_{\text{insight}}$，检索提供高层指导的洞察节点 $I_S$。
        $$I_S = \Pi_{Q \to I}(\tilde{Q_S}), \quad \Pi_{Q \to I}(S_q) \triangleq \{\iota_k \in I \mid \Omega_k \cap S_q \neq \emptyset\}$$
        这些洞察封装了可能与当前任务相关的通用知识。
    *   **向下遍历 (Downward Traversal)**：从 $\tilde{Q_S}$ 向下遍历到交互图 $G_{\text{interaction}}$，利用 LLM 驱动的图稀疏器 $S_{\text{LLM}}(\cdot, \cdot)$ 提取最相关的历史查询对应的核心交互子图 $\{\hat{G}_{Q_i}^{\text{inter}}\}_{i=1}^M$。
        $$\{\hat{G}_{Q_i}^{\text{inter}}\}_{i=1}^M = \left\{ S_{\text{LLM}}(G(Q_j)_{\text{inter}}, Q) \Big| q_j \in \arg \max_{q'_k \in \tilde{Q_S}} R_{\text{LLM}}(Q, q'_k), |\cdot|=M \right\}$$
        其中 $R_{\text{LLM}}(Q, q_j)$ 评估历史查询与当前查询的相关性，$S_{\text{LLM}}$ 构建一个稀疏图 $\hat{G}(Q_j)_{\text{inter}}$，保留关键对话元素。
    *   **记忆增强 (Memory Augmentation)**：根据检索到的通用洞察 $I_S$ 和细粒度协作轨迹 $\{\hat{G}_{Q_i}^{\text{inter}}\}_{i=1}^M$，G-Memory 为 MAS 中每个智能体 $C_i$ 提供专门的记忆支持。
        $$\text{Mem}_i \leftarrow \Phi(I_S, \{\hat{G}_{Q_i}^{\text{inter}}\}_{i=1}^M; \text{Role}_i, Q), \quad \forall C_i = (\text{Base}_i, \text{Role}_i, \text{Mem}_i, \text{Plugin}_i) \in V$$
        操作符 $\Phi(\cdot; \cdot)$ 评估每个记忆元素的效用和相关性，并初始化智能体的内部记忆状态 $\text{Mem}_i$。

3.  **分层记忆更新 (Hierarchy Memory Update)**：在任务完成后，G-Memory 根据环境反馈（如执行状态 $\Psi_i$）更新其分层记忆架构：
    *   **交互层**：构建新的交互图 $G(Q)_{\text{inter}}$ 并存储。
    *   **查询层**：创建新的查询节点 $q_{\text{new}} = (Q, \Psi, G(Q)_{\text{inter}})$ 并添加到查询图 $G_{\text{query}}$。新节点与相关历史查询以及支持当前任务所用洞察的查询建立边。
        $$q_{\text{new}} \leftarrow (Q, \Psi, G(Q)_{\text{inter}})$$
        $$N_{\text{conn}} \leftarrow Q_R \cup \left( \bigcup_{\iota_k \in I_S} \Omega_k \right)$$
        $$E_{\text{new}} \leftarrow \{(q_n, q_{\text{new}}) \mid q_n \in N_{\text{conn}}\}$$
        $$G_{\text{next}}^{\text{query}} \leftarrow (Q \cup \{q_{\text{new}}\}, E_q \cup E_{\text{new}})$$
    *   **洞察层**：生成总结本次经验的新洞察 $\iota_{\text{new}} = (J(G(Q)_{\text{inter}}, \Psi), \{q_{\text{new}}\})$，并与之前使用的洞察建立连接。同时，更新所用洞察的支持查询集 $\Omega_k$，以反映它们与本次任务的相关性。
        $$\iota_{\text{new}} = (J(G(Q)_{\text{inter}}, \Psi), \{q_{\text{new}}\})$$
        $$E_{i, \text{new}} \leftarrow \{(\iota_k, \iota_{\text{new}}, q_{\text{new}}) \mid \iota_k \in I_S\}$$
        $$I_{\text{next}} \leftarrow (I \setminus I_{\text{ret}}) \cup \{(\kappa_k, \Omega_k \cup \{q_{\text{new}}\}) \mid \iota_k = (\kappa_k, \Omega_k) \in I_{\text{ret}}\} \cup \{\iota_{\text{new}}\}$$
        $$G_{\text{next}}^{\text{insight}} \leftarrow (I_{\text{next}}, E_i \cup E_{i, \text{new}})$$

**实验结果**

G-Memory 在五个基准测试（ALFWorld、SciWorld、PDDL、HotpotQA、FEVER）、三个 LLM 后端（GPT-4o-mini, Qwen-2.5-7b, Qwen-2.5-14b）和三个流行 MAS 框架（AutoGen, DyLAN, MacNet）上进行了广泛实验。

*   **性能提升**：G-Memory 显著提升了性能，在具身行动任务中成功率最高提升 20.89%，在知识问答任务中准确率最高提升 10.12%，且无需修改原始 MAS 框架。它在所有任务领域和 MAS 框架上都表现出一致的性能提升。
*   **资源友好**：G-Memory 在实现高性能的同时，保持了与主流记忆设计相当甚至更低的 token 消耗。例如，在 PDDL+AutoGen 任务中，G-Memory 实现了 10.32% 的性能提升，而 token 消耗仅增加了 $1.4 \times 10^6$。
*   **敏感性分析**：实验表明，1 跳扩展通常能取得最佳或接近最佳的性能，过度的跳扩展可能引入不相关的洞察。相似地，最优的 $k$ 值（相关查询数量）在 {1, 2} 之间，过大的 $k$ 值会引入任务无关的噪音。
*   **消融研究**：高层洞察模块和细粒度交互模块都对 G-Memory 的性能有贡献，移除任一部分都会导致性能下降，其中交互信息的影响略大于洞察信息。

**贡献与局限**

*   **贡献**：
    1.  识别了现有 MAS 自进化能力中的根本瓶颈，即过于简化的记忆架构。
    2.  提出了 G-Memory，一个分层智能体化记忆架构，通过三层图结构（洞察图、查询图、交互图）建模复杂的 MAS 协作。
    3.  通过广泛实验证明 G-Memory 具有高性能和资源友好的特性。
*   **局限**：尽管 G-Memory 已在三个领域和五个基准上进行了评估，未来工作还需在更多样化的任务（如医学问答）上进行验证，以增强其通用性。



## 1. Introduction

![](https://img.zhaoweiguo.com/uPic/2025/11/aq9P4K.jpg)

Figure 1: (Left) We report the token cost of several single-agent and MAS baselines on ALFWorld benchmark; (Right) The overview of G-Memory’s three-tier hierarchical memory architecture, en-compassing the insight graph, query graph and interaction (utterance) graph.

### 1. 研究背景与现状

*   **LLM智能体的强大能力**：由大型语言模型驱动的智能体在感知、规划、推理和行动方面表现出色，并在代码生成、数据分析等领域取得进展。
*   **多智能体系统的潜力**：将多个智能体组织成一个系统，可以通过合作或竞争，产生“集体智能”，超越单个智能体的能力局限。
*   **“自我进化”是关键特征**：LLM智能体的一个突出特点是能够通过与环境的交互不断学习和改进。这背后的核心驱动力是**记忆机制**（类似于人类的经验和知识积累）。
    *   **单次任务记忆**：在解决一个任务过程中保留的上下文。
    *   **跨任务记忆**：在多个任务中积累的经验。

### 2. 核心问题：多智能体系统缺乏“自我进化”能力

作者指出，尽管单个智能体已经通过复杂的记忆机制实现了自我进化，但**多智能体系统在这方面严重落后**。

*   **现状**：现有的多智能体系统大多依赖**手动预定义的工作流程或通信拓扑**（如MetaGPT, ChatDev）。即使有些系统能自动优化结构，最终也往往变得庞大、笨重，无法灵活地根据积累的合作经验进行自我调整。
*   **根本原因**：缺乏专门为多智能体系统设计的记忆机制。
    *   **现有MAS记忆过于简单**：它们可能包含记忆设计，但通常仅限于“单次任务记忆”。即使有“跨任务记忆”，也往往只是传递**过度浓缩的成果**（如最终方案或结果），无法从详细的协作经验中进行有意义的学习。
    *   **无法直接套用单智能体记忆**：多智能体系统的交互轨迹**极其冗长**（比单智能体长10倍以上）。如果不对这些冗长的历史记录进行**抽象和提炼**，直接塞给模型是低效甚至无益的。

### 3. 提出的解决方案：G-Memory

为了解决上述问题，作者提出了 **G-Memory**（基于图的多智能体记忆机制）。

**G-Memory 的核心思想**：使用一个**三层级的图结构**来分层管理复杂冗长的多智能体交互历史。

这三个层级分别是：
1.  **洞察图**：从历史经验中**抽象出可泛化的、高级别的洞察和教训**（例如，“执行动作前后要验证对象状态”）。
2.  **查询图**：编码**任务查询的元信息**以及不同查询之间的关联。
3.  **交互图**：存储智能体之间**细粒度的、详细的文本通信记录**（对话内容）。

**工作流程**：
*   **当新任务到来时**：G-Memory会执行**双向记忆检索**。
    *   **向上检索**：从查询图找到相关任务记录，然后追溯到洞察图，获取相关的**高级别洞察**来指导宏观策略。
    *   **向下检索**：从查询图找到相关任务记录，然后深入到交互图，找出与当前任务最相关的**核心交互子图**，提供具体的协作范例。
*   **当任务完成后**：系统会以智能的方式更新所有三个层级的记忆，吸收新的洞察、丰富查询记录、存储详细的交互轨迹，并建立它们之间的关联。

**优势**：G-Memory是一个**即插即用**的模块，可以无缝嵌入到主流的多智能体框架中，赋能其进化性的协作和集体智能。

### 4. 总结的贡献

1.  **瓶颈识别**：系统地分析了现有MAS，指出了其自我进化能力的根本瓶颈在于过于简化的记忆架构。
2.  **实用方案**：提出了G-Memory，一个用于MAS的分层记忆架构。
3.  **实验评估**：在五个基准测试上的大量实验表明，G-Memory：
    *   **高性能**：在具身行动和知识问答任务上，将最先进MAS的性能分别提升了高达20.89%和10.12%。
    *   **资源友好**：与主流记忆设计相比，保持了相当甚至更低的计算资源消耗。

**总而言之，这篇论文瞄准了多智能体系统发展的一个关键障碍，并提出了一个结构精巧、逻辑清晰的图结构记忆系统来解决它，旨在让多智能体团队能够像人类团队一样，从过去的合作经验中学习和进化。**


## 2 Related Works

### 1. 单智能体记忆

这部分讲述了为**单个AI智能体**设计的内存系统是如何发展的。

*   **核心作用**：记忆让智能体能够积累经验，从而更好地解决问题和进行社交模拟。
*   **早期阶段（局限）**：早期研究只是为了解决LLM（大语言模型）上下文窗口长度的限制。比如MemoryBank, ChatDB等，它们的技术核心是**RAG**，即根据文本相似度来检索记忆片段。
*   **当前发展（进步）**：后来的研究开始构建更复杂、更接近人类认知的记忆架构，主要体现在三个方面：
    1.  **范围扩展**：从“任务内记忆”扩展到“跨任务记忆”，让智能体能从过去的任务中学习。
    2.  **应用拓宽**：从简单的聊天，应用到控制电脑、实体行动、科学发现等多个领域。
    3.  **管理技术进化**：从简单的文本相似度匹配，升级为对知识和经验进行**抽象和总结**，使得记忆更精炼、更有用。

### 2. 多智能体系统中的记忆

*   **核心问题**：为**多智能体系统**设计的记忆机制**严重缺乏探索**。
*   **现有系统的不足**：
    *   **完全缺失**：一些有名的多智能体框架（如LLM-Debate）根本没有记忆组件。
    *   **过于简单**：另一些框架只采用了最简单的“任务内记忆”，和早期的单智能体一样。
    *   **处理粗糙**：即使有跨任务记忆的系统，也只是把最终结果压缩存储，完全忽略了智能体之间**复杂的互动过程**。
*   **结论**：目前迫切需要一个**有原则的记忆架构**，能够专门捕捉、组织和检索多智能体在协作解决问题时产生的复杂互动过程。


### 3. 基于LLM的多智能体系统

这部分从更宏观的视角，说明了多智能体系统本身存在的另一个关键问题：**缺乏持续进化能力**。

*   **核心对比**：单智能体可以通过与环境互动不断进化，但多智能体系统往往缺乏这种能力。
*   **早期系统**：如AutoGen等，完全依赖**预先定义好的工作流程**，非常死板。
*   **近期进展**：一些新系统引入了“适应性”，可以根据环境反馈动态生成多智能体团队。
*   **但仍有局限**：这种进化通常是“一次性”的。例如，一个系统可以为某个特定任务精心组建一个团队，但这个团队**无法随着处理任务越来越多而变得更强**，也**不能把学到的经验迁移到其他类型的任务中**。
*   **最终结论**：因此，构建一个真正具有**自我进化能力**的多智能体系统，是一个尚未解决且充满挑战的研究前沿。

### 总结

1.  **它指出了两个关键问题**：
    *   问题一：多智能体系统缺乏一个**有效的、能记录复杂互动过程的记忆机制**。
    *   问题二：多智能体系统普遍缺乏**持续自我进化的能力**。

2.  **提出的解决方案**：
    *   *为多智能体系统设计一个新型的记忆架构**。这个架构不仅能存储任务结果，更能捕捉智能体间的协作过程，并通过跨任务的经验积累，最终使整个多智能体系统获得**真正的、持续性的自我进化能力**。

简单来说，这篇论文旨在为多智能体系统装上“团队记忆”和“学习能力”，让它们从一个临时小组，升级成一个能不断从经验中学习、越变越强的“超级组织”。


## 3 Preliminary

### **第一部分：多智能体系统公式**

这部分的目标是用数学语言精确地描述一个多智能体系统是如何工作和协作的。

**1. 系统基础结构**
- **系统比喻**： 把整个多智能体系统想象成一个**公司的组织架构图**。
- **图定义**： 系统被定义为一个**有向图 G = (V, E)**。
    - `V` 是所有的**智能体（Agent）**，就像公司的员工。总共有N个员工。
    - `E` 是智能体之间的**沟通渠道**，就像组织架构图中的汇报线。如果有一条从Agent A指向Agent B的边，意味着A可以把信息传递给B。

**2. 单个智能体的构成**
每个智能体 `Ci` 就像一个员工，有他的基本资料：
- **`Basei`**： 他使用的“大脑”或核心AI模型（例如GPT-4）。
- **`Rolei`**： 他的**职位和职责**（例如：会计师、营销专家）。这决定了他会如何思考和回答问题。
- **`Memi`**： 他的**个人记忆和知识库**，记录了他过去的对话和经验。
- **`Plugini`**： 他的**工具集**（例如：计算器、搜索引擎），让他能执行特定任务。

**3. 系统工作流程（处理一个用户问题Q）**
系统不是一次性给出答案，而是进行多轮（`T`轮）的讨论和迭代。

- **步骤1：排序**
    - 在每个讨论轮次`t`的开始，系统会根据沟通图`G`计算一个**拓扑排序** `π`。
    - **核心作用**： 这个排序确保了一个智能体**必须等到所有给他提供信息的“前辈”智能体都发言后，他才能发言**。这避免了循环等待，保证了信息流动的有序性。
    - **比喻**： 在公司里，项目经理必须等市场调研和工程师给出数据后，才能开始写项目报告。

- **步骤2：个体处理与响应**
    - 每个智能体 `Ci` 按照排序`π`依次工作。他生成响应 `r_i^(t)` 时，会综合考虑：
        - `P_sys^(t)`： **全局指令和角色定义**（像是公司的工作手册和每个人的岗位说明书）。
        - `Q`： **用户最初的问题**。
        - `{r_j^(t)}`： **所有“前辈”智能体（他的入边邻居）在当前轮次的最新回复**。
    - **比喻**： 一个员工在写报告时，会参考老板的指令、最初的项目要求，以及其他同事刚刚提交给他的部分。

- **步骤3：全局聚合**
    - 当一轮中所有智能体都发言完毕后，需要一个**聚合操作 `A`** 来整合所有人的意见，形成一个**临时共识答案 `a^(t)`**。
    - **常见的聚合方式**：
        - **投票**： 大家投票选出一个最佳答案。
        - **总结**： 指定一个“会议纪要员”（聚合智能体）来总结所有人的发言。
        - **终审**： 直接采用最后一个智能体（例如一个“主审官”角色）的输出作为答案。

- **步骤4：迭代直至结束**
    - 系统会重复步骤1-3，进行多轮（`T`轮）讨论。
    - 迭代会在达到预设轮数上限或满足**提前终止条件**（例如，大家达成一致，认为答案已经足够好）时停止。
    - 最终的答案就是最后一轮聚合的结果 `a^(T)`。

**第一部分小结**： 这一部分定义了一个**有序、迭代、协作**的多智能体系统。它通过拓扑排序管理信息流，通过聚合操作整合集体智慧，最终目标是逐步优化对用户问题的解答。

---

### **第二部分：G-Memory 分层内存架构**

这部分介绍了G-Memory如何像一个大图书馆一样，分三层来存储和管理整个系统在运行过程中产生的所有知识和经验。

**1. 交互图 - 最底层：记录“一次对话的完整笔录”**
- **内容**： 针对**某一个具体问题Q**，记录解决它的**完整对话过程**。
- **节点 `U(Q)`**： 每一次**原子发言**。每个节点包含：`谁说的（Ai）` 和 `说了什么（mi）`。
- **边 `E_u^(Q)`**： 发言之间的**时间与启发关系**。如果发言A启发了发言B，就有一条从A指向B的边。
- **比喻**： 就像一份**详细的会议记录**，记录了针对项目Q的整个头脑风暴过程，谁在什么时候说了什么，谁的想法激发了谁。

**2. 查询图 - 中间层：记录“所有处理过的问题档案”**
- **内容**： 一个存储了**所有历史查询**及其元数据的图。
- **节点 `Q`**： 每一个**处理过的问题**。每个节点包含三部分：
    1. **原始问题 `Qi`**
    2. **任务状态 `Ψi`**： 这个问题是`已解决`还是`已失败`？
    3. **关联的交互图 `G_inter^(Qi)`**： 指向解决这个问题时产生的完整“会议记录”。
- **边 `Eq`**： 问题之间的**语义关联**（例如，问题A和问题B是关于同一个主题的）。
- **作用**： 当遇到新问题时，系统不仅可以靠简单的语义相似度匹配，还能通过这个图的拓扑结构，找到在**逻辑上真正相关**的历史问题及其完整解决方案。

**3. 洞察图 - 最高层：提炼“公司的知识库和最佳实践”**
- **内容**： 从海量的具体问题和对话中，**提炼出的抽象知识、规律和洞察**。
- **节点 `I`**： 每一个**洞察**。每个节点包含：
    - **洞察内容 `κk`**： 提炼出的核心知识或结论（例如：“客户在雨季更偏好X产品”）。
    - **支持查询集 `Ωk`**： 这个洞察是从哪些具体问题（查询图的节点）中总结出来的。提供了**溯源依据**。
- **边 `Ei`**： 这是一个**超图连接**，边可以连接多个洞察，并且边上还标注了是**通过哪个具体问题（qj）** 建立了这种上下文关联。
    - **例子**： `(洞察A, 洞察B, 问题123)` 表示在解决问题123的过程中，我们发现洞察A为理解洞察B提供了重要背景。
- **比喻**： 就像公司基于所有项目经验编写的**“白皮书”或“最佳实践指南”**。它不再是具体的项目记录，而是升华后的战略知识。

---

### **总结**

这段文字描述了一个高度结构化的多智能体系统：
1.  **运作层面**： 系统通过**有序的、多轮的智能体协作**来解决问题，每一轮都整合集体智慧并迭代优化。
2.  **记忆层面**： 系统通过G-Memory的**三层图结构**来积累和复用知识：
    - **交互图**记录“过程”（怎么做）。
    - **查询图”** 记录“案例”（做过什么）。
    - **洞察图”** 记录“智慧”（学到了什么）。

这种设计使得系统不仅能解决当前问题，还能像人类组织一样，不断从经验中学习，形成长期、结构化、可追溯的知识体系，从而变得越来越聪明。



## 4 G-Memory

![](https://img.zhaoweiguo.com/uPic/2025/11/l4SxyG.png)

Figure 2: The overview of our proposed G-Memory.

**G-Memory** (群体记忆管理系统)的工作流程。

核心思想是模仿人类组织的“集体记忆”，让一个多智能体系统能够从过去的经验中学习，从而更高效地解决新问题。

为了帮你更好地理解，我们可以将其比喻成一个**公司的知识管理体系**：

*   **新任务** = 一个新的客户项目（查询 Q）
*   **基层员工** = 各个智能体，他们有自己的专业领域（角色 Role）
*   **项目档案** = 细粒度的交互图，记录了之前项目中的所有对话和决策过程（G_interaction）
*   **项目清单** = 查询图，记录了公司做过的所有项目的基本信息（G_query）
*   **经验总结/方法论** = 洞察图，是从成功/失败项目中提炼出的高级别策略和原则（G_insight）

下面我们来分步解析这个工作流程：

### **G-Memory 整体工作流程（对应第4节开头）**

当一个新任务（查询 Q）到来时，G-Memory 的工作分为三步：
1.  **粗粒度记忆检索**：快速找到与新任务相关的“历史项目档案”。
2.  **双向分层记忆遍历**：从这些相关档案中，一方面向上提炼“经验总结”，另一方面向下提取具体的“操作流程”。
3.  **分层记忆更新**：任务完成后，将这次的新经验更新到知识库中，实现“知识制度化”。

---

### **4.1 粗粒度记忆检索**

**目标**：快速、粗略地找到与新任务相关的历史记录。

1.  **语义相似性搜索**：首先，系统将新任务 Q 和历史任务都转换成数学向量，然后通过计算向量之间的相似度，找出最相似的 top-k 个历史任务，形成一个初始集合 Q_S。
    *   *好比：用关键词在公司项目库中搜索，找到名字或描述最像的项目。*

2.  **关联扩展**：仅仅语义相似可能不够。系统还会在“项目关系网”（查询图）中，找到这些初始项目集合的“邻居”（直接相关联的其他项目），将他们也纳入考虑范围，形成一个扩大的相关集合 ˜Q_S。
    *   *好比：不仅看最像的项目，还把与这些项目有直接关联的其他项目也找出来，因为它们可能也相关。*

3.  **问题**：不能直接把这一大堆原始记录塞给所有“员工”（智能体），因为信息太多且不专注。所以需要下一步的精细处理。

---

### **4.2 双向记忆遍历**

**目标**：从扩大的相关任务集合 ˜Q_S 中，提取不同粒度的知识。

1.  **向上遍历：获取“战略洞察”**
    *   **行动**：从查询图上升到洞察图。找出那些基于 ˜Q_S 中历史任务所总结出的“经验洞察”集合 I_S。
    *   **产出**：得到一些高度概括的战略性指导原则。
    *   *好比：从相关历史项目中，找出我们曾经总结过的“成功十大法则”或“常见陷阱”。*

2.  **向下遍历：获取“具体操作流程”**
    *   **行动**：从查询图下降到交互图。使用大语言模型作为“精华提取器”，从最相关的几个历史任务的详细对话记录中，抽取出核心的、关键的协作子图 {ˆG_Qi_inter}。
    *   **产出**：得到浓缩的、具体的协作对话记录，展示了当时是谁、在什么情况下、说了什么关键话才解决了问题。
    *   *好比：不是把整个项目会议记录都给人看，而是只提取出其中最关键的几个决策讨论片段和最终执行方案。*

3.  **个性化记忆分发**
    *   **行动**：通过一个操作符 Φ，根据每个智能体自身的“岗位职责”和新任务的具体内容，对上面获取的“战略洞察”和“具体操作流程”进行筛选和整合，为每个智能体初始化其专属的“工作记忆” Mem_i。
    *   *好比：给项目经理分发“战略洞察”和“项目统筹片段”，给技术工程师分发“技术难点洞察”和“代码讨论片段”。*

---

### **4.3 分层记忆更新**

**目标**：任务完成后，将这次的新经验固化到知识库中，让系统变得更聪明。

任务执行完毕后，会收到环境反馈（成功/失败、资源消耗等）。

1.  **更新交互层**：将本次任务中所有智能体的对话记录构建成一个新的交互图 G^(Q)_inter，存入数据库。
    *   *好比：把这次项目的完整会议记录和聊天记录归档。*

2.  **更新查询层**：
    *   创建一个新的查询节点 q_new，包含任务描述、结果和对应的交互图。
    *   将这个新节点与两类旧节点连接：
        a. 在解决本任务时参考过的那些最相关的历史任务节点。
        b. 产出本次所用“战略洞察”的那些历史任务节点。
    *   *好比：在公司项目清单里新建一个项目条目，并把它和它参考过的老项目、以及它印证了其方法论的老项目关联起来。*

3.  **更新洞察层**：
    *   **生成新洞察**：基于本次任务的对话记录和最终结果，让大语言模型总结出一条新的经验教训 ι_new（例如：“对于A类问题，采用B策略配合C工具成功率更高”）。
    *   **链接新洞察**：将这条新洞察与之前启发本次任务的旧洞察连接起来，形成知识网络。
    *   **更新旧洞察**：让那些被本次任务成功应用的旧洞察，其支持案例集合里加入这个新任务节点，证明其普适性。
    *   *好比：根据本次项目经验，写了一条新的“方法论”并存入公司知识库，同时更新了之前参考的旧“方法论”，注明它又一次被成功应用。*

### **核心价值总结**

G-Memory 的本质是为一个多智能体系统赋予 **“记忆”** 和 **“学习”** 能力。它通过一个分层的知识结构（具体操作 -> 项目索引 -> 战略洞察），实现了：
*   **高效检索**：快速定位相关知识。
*   **知识抽象**：从具体案例中提炼可复用的策略。
*   **个性化**：为不同角色的智能体提供最相关的信息。
*   **持续进化**：系统能够从每一次成功或失败中学习，不断丰富和修正其集体知识库，从而越用越聪明。



## 5 Experiment

**结论**
* G-Memory 很强大：它显著提升了多智能体系统的性能。
* G-Memory 很高效：它不以浪费大量资源为代价。
* G-Memory 设计合理：它的两个核心组件（高级见解和细粒度交互）都不可或缺，且参数设置稳定。
* 专门设计很重要：多智能体系统的记忆不能简单照搬单智能体的方法，必须考虑协作、角色分工等特性。


![](https://img.zhaoweiguo.com/uPic/2025/11/aiAbey.png)

Figure 5: Case study of G-Memory.


例子1（ALFWorld）：当前任务是“把一块干净的布放在台面上”。G-Memory 成功回忆起一个类似的历史任务“把干净的鸡蛋放进微波炉”。它不仅找到了这个任务，还提取了关键教训：当时有个智能体试图在没洗鸡蛋之前就把它放进微波炉，被另一个智能体制止了。这个“协作轨迹”直接指导了当前任务：必须先确保布是干净的。

例子2（HotpotQA）：在知识推理任务中，G-Memory 提供的高级见解是“警惕错误指代”，这帮助智能体避免把名字相似的不同人物搞混，从而正确回答问题。



## 6 Conclusion & Limitation

### 核心内容总结

1.  **问题**：作者指出，现有的多智能体系统（MAS）内存架构设计得**过于简单**，这限制了系统自我进化的能力。
2.  **解决方案**：为了解决这个问题，他们提出了一个名为 **G-Memory** 的新框架。
3.  **G-Memory 是什么**：
    *   **本质**：一个**分层的记忆框架**。
    *   **核心结构**：使用一个**三层图结构**来组织智能体之间复杂且长期的交互轨迹：
        *   **洞察图**：存储**抽象的、可概括的**见解。
        *   **查询图**
        *   **交互图**：存储**细粒度的、对任务至关重要的**协作片段。
    *   **工作方式**：它为每个智能体提供**定制化的、分层的记忆线索**（从抽象到具体），并且其知识库会随着任务进程**动态演化**。
4.  **成果**：
    *   **兼容性强**：可以轻松集成到当前最先进的多智能体系统框架中。
    *   **效果显著**：**极大地提升了系统的自我进化能力**。文中举了一个具体例子：在具身动作任务上，性能提升了**高达20.89%**。

### 局限性

作者也客观地指出了研究的不足之处：
*   **验证范围有待扩大**：虽然已经在三个领域、五个基准测试上进行了评估，但其结论的普适性还需要在**更多样化的任务**（例如，医疗问答）上进行验证。
*   **未来工作**：将针对上述局限性，在更多任务上验证G-Memory的稳健性。


## A Experimental Details


### 核心内容概览

这段附录主要描述了为了进行实验所准备的四个核心要素：
1.  **用了哪些数据集**（A.1）
2.  **如何评估性能**（A.1末尾）
3.  **和哪些现有方法进行比较**（A.2）
4.  **在什么样的多智能体系统里运行**（A.3）

---

### A.1 数据集描述

这部分介绍了5个用于测试智能体能力的基准数据集。

| 数据集名称 | 类型与描述 | 评估能力 |
| :--- | :--- | :--- |
| **ALFWorld** | 文本化具身环境。智能体在家庭环境中导航，通过自然语言指令与物体互动，完成家务任务。 | **导航与交互** |
| **ScienceWorld** | 文本化具身环境。智能体在房间中导航并进行科学实验。 | **程序推理与科学探索** |
| **PDDL** | 战略游戏数据集。智能体使用PDDL（一种人工智能规划语言）表达式来完成复杂任务。 | **复杂任务规划** |
| **HotpotQA** | 多跳问答数据集。要回答一个问题，需要串联多个来源的事实进行推理。 | **信息检索与综合推理** |
| **FEVER** | 事实核查数据集。智能体需要利用网络搜索API来验证一个声称的真伪。 | **证据推理与事实核查** |

**评估指标**：
- **FEVER** 和 **HotpotQA**：使用**精确匹配准确率**。
- **ScienceWorld** 和 **PDDL**：使用**进度率**。
- **ALFWorld**：使用**成功率**。

---

### A.2 基线模型设置

这部分介绍了用来与作者提出的新方法进行对比的6种现有的“记忆”设计。**“记忆”在这里指的是智能体如何存储、管理和利用过去的信息和经验。**

| 基线模型 | 核心思想与特点 |
| :--- | :--- |
| **Voyager** | 源自《我的世界》游戏智能体。记忆是智能体进化的核心。本文将其从**单智能体**设定适配到了**多智能体**场景。 |
| **MemoryBank** | 模仿人类记忆行为，会**选择性保留和遗忘**信息。其遗忘机制受“艾宾浩斯遗忘曲线”启发，根据时间推移和信息重要性来强化或丢弃记忆。 |
| **Generative** | 包含两种记忆：1. **原始观察记忆**；2. **反思记忆**（智能体通过反思产生的抽象思想），更结构化。 |
| **MetaGPT-M** | 只关注**任务内记忆**，即多个智能体在解决**单个任务**过程中内部存储的信息。 |
| **ChatDev-M** | 包含**任务内**和**跨任务**两种记忆。但它的跨任务记忆相对简单（如存储过去的解决方案），在本文的复杂协作任务中效果不佳。 |
| **MacNet-M** | 任务内记忆仅包含上一轮产生的**最终答案**，所有智能体之间的**互动对话过程**会被完全丢弃。 |

---

### A.3 多智能体系统设置

这部分介绍了实验采用的三个多智能体协作框架。

#### A.3.1 AutoGen
- **特点**：一个流行的多智能体**编排框架**，用于协调不同特长的智能体解决问题。
- **本文采用的结构**：A3:决策制定
    - **求解器**：负责生成解决方案。
    - **真值代理**：根据标准答案，批判性地评估求解器的输出，找出错误。
    - **执行器**：将验证通过的方案转化为可执行的命令。
- **形象理解**：像一个**分工明确的公司团队**，有生产、质检和执行部门。

#### A.3.2 DyLAN
- **特点**：一个**辩论式**框架，类似“LLM辩论”。
- **关键创新**：引入了**基于智能体重要性得分的早期停止机制**。它会通过一个预实验来识别对特定任务贡献最大的智能体，从而在辩论中更高效地做出决策。
- **本文实现**：使用3个智能体进行辩论，外加1个**排序器**智能体来评估它们的重要性。

#### A.4 MacNet
- **特点**：探索**去中心化、可扩展**的多智能体系统。
- **关键创新**：**没有中央调度员**。它引入了**边缘智能体**，这些智能体在交互过程中被调用，根据上一个智能体的输出，为下一个智能体提供行动指令。
- **本文实现**：采用了MacNet中的**随机图拓扑**结构（证明在各种场景下都很鲁棒），并使用5个智能体外加边缘智能体。

### 总结

这段附录清晰地勾勒出了实验的舞台：
- **战场**：5个不同侧重点的数据集。
- **裁判**：根据数据集特性定制的评估指标。
- **对手**：6种具有不同记忆管理策略的现有方法。
- **竞技场**：3种不同协作范式（模块化分工、辩论、去中心化网络）的多智能体系统。


## B Additional Experiment Results

![](https://img.zhaoweiguo.com/uPic/2025/11/qexdbi.jpg)


G-Memory 是一种非常有效的记忆架构，它在多个测试基准、多个多智能体框架和多个大语言模型上，都显著提升了性能，且成本增加微乎其微。


附录分为三个主要部分
* B.1 RQ1结果：G-Memory 如何提升任务成功率？
* B.2 RQ2结果：G-Memory 的成本（Token消耗）如何？
* B.3 案例研究：G-Memory 内部是如何工作的？

### B.3 Case Study

#### **洞察图**

*   **洞察图是什么？**：G-Memory 会从过去的任务执行经验中总结出高级别的、可重用的“洞察”（Insight），这些洞察以图结构连接起来。
*   **关键发现**：
    *   **密集的类别内连接**：相同类型的任务（例如“找东西”、“用东西”）产生的洞察会紧密地连接在一起。这说明系统能很好地归纳同类任务的经验。
    *   **有意义的类别间连接**：不同类别的任务洞察之间也会产生连接。这说明系统发现了**可跨领域迁移的模式**。例如，在“找东西”任务中学到的策略，可能对“用东西”的任务有启发。


#### **查询图**

*   **查询图是什么？**：当智能体遇到一个新任务（查询）时，G-Memory 会构建一个图，将当前查询与历史上相似的查询连接起来。图中的有向边表示一个查询的执行轨迹能为另一个查询提供有用的指导。
*   **关键发现**：
    *   **涌现的聚类模式**：语义上相似的查询会自然地聚集成**密集连接的子图**。
    *   **稀疏的集群间连接**：这些连接捕捉了**跨任务的灵感**。
*   **意义**：这展示了 G-Memory 能够通过结构化的记忆推理，有效地组织和关联不同智能体的协作经验，从而在面对新问题时能快速找到相关的解决方案。


## C Prompt Set

### 查询相关性过滤

系统提示词：
```
你是一个被设计用来评估两段文本之间相关性的智能体。
```

用户提示词：
```
你将看到一个你成功完成任务的案例。
然后，你将看到一个正在进行中的任务。
请不要总结这两个案例，而是评估成功案例对于进行中任务的相关性和帮助程度，评分范围为 1-10 分。

成功案例：
{trajectory}

进行中任务：
{query_scenario}

评分：
```

### 图稀疏化(Graph Sparsifier)


系统提示词：
```
你是一个擅长提取关键点的智能体。
给定一个任务和一个成功的执行轨迹，你的工作是识别完成任务所需的关键步骤，同时过滤掉不重要的步骤。
```

用户提示词：
```
注意：
- 严格遵循原始轨迹；绝对不要添加轨迹中不存在的步骤。
- 即使在成功的轨迹中，也可能存在一些错误的步骤。请特别注意那些对应“无事发生”观察结果的动作，这些动作很可能是错误的。请为我过滤掉这些动作。
- 你需要确保每个步骤都具有最细的粒度。
- 你应严格遵循示例中的输出格式。

## 以下是任务：
### 任务
{task}

### 轨迹
{trajectory}

### 输出
```


### Inisght Summarization Function


#### 对比分析（成功 vs 失败）

系统提示词：
```
你是一个专注于从经验中学习的分析型智能体。
你将获得：
- 一个失败的轨迹及其结果，
- 一个完成类似任务的成功轨迹。

你的任务是分析这两个轨迹，并生成清晰、可操作的洞察。
你的洞察应重点说明失败轨迹遗漏了什么，以及成功轨迹是如何解决或避免这些陷阱的。

## 要求：
- 所有洞察必须直接来源于对两个轨迹的对比。
- 不要推测或引入成功示例中未支持的步骤。
- 专注于两个案例之间**具体的行为或策略差异**。
- 保持每个洞察简洁且具有影响力。

输出格式：
- 直接以编号列表开始。
- 不要有引言或解释。
- 严格使用以下格式：
1. 洞察 1
2. 洞察 2
3. 洞察 3
...
```


用户提示词：
```
## 成功轨迹
{true_traj}

## 失败轨迹
### 轨迹
{false_traj}

你的输出：
```

#### 从所有成功案例中学习


系统提示词：
```
你是一个专注于从成功中学习的分析型智能体。
你将获得一组完成类似任务的成功轨迹。

你的目标是分析这些成功示例，并提取清晰、可操作的洞察，以捕捉促成它们成功的因素。这些洞察将为未来处理类似任务的智能体提供指导。

## 要求：
- 所有洞察必须基于在成功轨迹中观察到的模式或策略。
- 不要推测或引入所提供的示例中未反映的步骤。
- 专注于那些持续带来积极结果的共同行为、策略或决策。
- 保持每个洞察简洁、具体且具有影响力。

输出格式：
- 直接以编号列表开始。
- 不要有引言或解释。
- 严格使用以下格式：
1. 洞察 1
2. 洞察 2
3. 洞察 3
...
```

用户提示词：
```
## 成功轨迹
{true_trajs}

你的输出：
```

#### 合并规则提示词


系统提示词：
```
你是一个擅长总结和提炼洞察的智能体。
你将会得到一个先前从类似任务中提取的洞察列表。这些洞察可能存在冗余或重叠。

你的工作是**合并和整合相似的洞察**，并输出一个**清晰、可操作、简洁**的精炼版本。

注意：
- 所有合并后的洞察**必须严格基于给定的输入**。你**不允许编造**或推断任何新信息。
- 输出应易于阅读和理解。

输出格式：
- 直接以编号列表开始你的回复，不要有任何前言或解释。
- 每个洞察应该是一个短句。
- 严格使用以下格式：
1. 洞察 1
2. 洞察 2
3. 洞察 3
...
```


用户提示词：
```
## 以下是需要合并的当前洞察：
{current_rules}

## 请将它们合并并重写为**不超过 {limited_number} 条**精炼后的洞察。
作为总结智能体，请去除冗余，合并相似的想法，并确保清晰度。

你的输出：
```


### 定制记忆

系统提示词：
```
你是一个深思熟虑且具有上下文意识的智能体。
你将获得一个成功执行的轨迹、一个特定的智能体**角色**，以及一套适用于所有角色的**通用洞察**。

你的任务是**将这些通用洞察适配**成**个性化的洞察**，这些洞察是专门为给定的角色及其轨迹量身定制的。这些个性化的洞察应通过符合其独特背景、职责和视角来帮助该智能体提高未来的表现。

请确保你的输出能反映对角色上下文的理解，并提供可操作的、与角色相关的建议。

注意 - 你的输出必须严格遵循以下格式：
1. 洞察 1
2. 洞察 2
3. 洞察 3
...
```


用户提示词：
```
### 轨迹
{trajectory}

### 智能体角色：
{role}

### 通用洞察：
{insights}

### 你的输出（针对此角色的个性化洞察）：
```

## D Discussion with Related Works

讨论G-Memory与几种最新的Agent记忆框架之间的关系。

对于A-Mem，虽然A-Mem和G-Memory都旨在增强LLM（Large Language Model，大型语言模型） Agent的记忆能力，但它们在两个关键方面有所不同。
* 首先，A-Mem是为单Agent场景量身定制的，而G-Memory旨在处理MAS（Multi-Agent System，多Agent系统）的冗长而细致的交互轨迹。
* 其次，A-Mem强调用于聊天机器人式交互的原子记忆构建，而G-Memory则侧重于从协作任务执行中提取可重用的策略，在这种情况下，细粒度的原子性既不需要也没有益处。

对于Mem0，虽然它也采用了基于图的结构，但它仍然属于聊天机器人的范畴。
* 它的图更接近于知识图谱，其中节点代表事实实体，边代表关系，这与G-Memory以Agent为中心的记忆图有着根本的不同，后者编码了Agent之间的轨迹、决策和协调模式。








