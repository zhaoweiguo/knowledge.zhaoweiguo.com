# 2512.18746_MemEvolve: Meta-Evolution of Agent Memory Systems

* 首页: <https://arxiv.org/abs/2512.18746>
* 引用:
    * 0(2026-01-09)
* 组织:
    * OPPO AI Agent Team, LV-NUS lab



## From Moonlight

### 三句摘要

1. 💡 针对大型语言模型(LLM)智能体记忆系统无法随任务上下文动态调整其架构的局限性，本文提出了MemEvolve元进化框架。
2. ⚙️ MemEvolve通过双层优化过程，联合进化智能体的经验知识和记忆架构，并借助EvolveLab将记忆系统分解为Encode、Store、Retrieve和Manage四个可演化模块。
3. 📈 在四项挑战性基准测试中，MemEvolve显著提升了智能体性能，并展现出强大的跨任务、跨LLM及跨框架泛化能力，其自动进化的记忆系统在实践中表现高效。

![](https://img.zhaoweiguo.com/uPic/2026/01/NvwVK7.jpg)

Figure 2 The paradigm of agent self-evolution admits a natural analogy to human learning. 


![](https://img.zhaoweiguo.com/uPic/2026/01/YUAOgZ.jpg)

Figure 3 The overview of our proposed MemEvolve.


### 关键词

- MemEvolve: MemEvolve 是一个元进化框架，它能够同时进化智能体的经验知识和其底层的记忆系统架构。该框架旨在解决当前记忆系统静态的局限性，使记忆系统不仅能够积累经验，还能逐步优化学习经验的机制，从而适应不同的任务上下文，实现更优异的性能和泛化能力。
- EvolveLab: EvolveLab 是一个统一的、模块化的代码库和设计空间，它将十二种代表性的自进化记忆系统提炼为四个核心组件：编码（Encode）、存储（Store）、检索（Retrieve）和管理（Manage）。EvolveLab 提供了一个标准化的实现基础和公平的实验平台，用于研究自进化记忆系统，并为 MemEvolve 的进化过程提供了支持。
- Meta-evolution: 元进化（Meta-evolution）是 MemEvolve 框架的核心概念。它指的是一个双层级的进化过程：下层循环（内循环）是智能体在固定记忆架构下积累经验并优化其知识基础，而上层循环（外循环）则是在此基础上，对记忆系统本身的架构（如编码、存储、检索、管理策略）进行“元级”的进化和优化，以加速未来的学习过程。
- Agent memory systems: 智能体记忆系统（Agent memory systems）是指能够持续捕获智能体与环境交互信息，并将其提炼为知识和技能的系统。这些系统使基于大型语言模型（LLM）的智能体能够不断地在任务解决和环境探索中自我进化。论文主要关注其中的“自进化记忆系统”（self-improving memory systems），这些系统旨在通过持续交互来提升智能体的性能。
- Modular design space: 模块化设计空间（Modular design space）是将复杂的记忆系统分解为四个功能独立但相互关联的核心组件的抽象框架：编码（Encode）、存储（Store）、检索（Retrieve）和管理（Manage）。这种模块化设计使得研究人员能够系统地分析、实现和进化各种记忆架构，为 MemEvolve 的元进化过程提供了结构化的基础。
- Encode: 编码（Encode）是模块化记忆设计空间中的一个组件。它的作用是将原始经验（如轨迹片段、工具输出、自我批评等）转化为结构化的表示形式，以便存储和后续处理。编码过程的复杂性可以从简单的原始轨迹压缩到提取可泛化的经验教训。
- Store: 存储（Store）是模块化记忆设计空间中的一个组件。它的作用是将编码后的经验信息整合到持久化的记忆库中。存储方式可以多种多样，例如向量数据库、知识图谱或其他数据结构。
- Retrieve: 检索（Retrieve）是模块化记忆设计空间中的一个组件。它的作用是根据任务的上下文、查询和当前状态，从记忆库中查找并返回相关的记忆内容。检索到的信息用于指导智能体的策略决策。
- Manage: 管理（Manage）是模块化记忆设计空间中的一个组件。它负责执行离线和异步的操作，例如记忆的巩固、抽象或选择性遗忘，以维持记忆库的长效质量和效率。
- Dual-evolution process: 双进化过程（Dual-evolution process）是 MemEvolve 框架的核心机制。它包含两个嵌套的循环：内循环（Experience Evolution）负责在给定的记忆架构下，智能体通过与环境交互来填充和更新其记忆状态（经验知识）；外循环（Architectural Evolution）则基于内循环的性能反馈，对记忆架构本身进行进化和优化。这个过程实现了经验知识和记忆架构的共同进化。
- Memory architecture: 记忆架构（Memory architecture）是指智能体记忆系统的组织结构和功能组件（如编码、存储、检索、管理策略的具体实现方式）。与传统的固定记忆架构不同，MemEvolve 框架能够通过元进化过程动态地设计和优化记忆架构，使其更能适应特定的任务或环境。
- Adaptive learner: 自适应学习者（Adaptive learner）是论文中用来类比 MemEvolve 目标的一个概念。它指的是人类学习者不仅能够积累经验（像熟练学习者），还能动态地调整其学习策略和方法，根据学习内容的特点选择最有效的学习方式。MemEvolve 的目标就是让智能体记忆系统能够实现这种自适应学习能力。
- Diagnose-and-Design Evolution: 诊断与设计进化（Diagnose-and-Design Evolution）是 MemEvolve 元进化（外循环）的具体实现方式。它包含两个阶段：首先，“诊断”阶段会分析高性能记忆系统的失败模式和瓶颈；然后，“设计”阶段基于诊断结果，在模块化设计空间内，通过修改特定组件（编码、存储、检索、管理）来生成新的、经过改进的记忆架构。


### 摘要

《MemEvolve: Meta-Evolution of Agent Memory Systems》提出了一种元演化框架MemEvolve，旨在解决大型语言模型（LLM）代理记忆系统静态性带来的局限性。现有记忆系统虽然能帮助代理从经验中学习并演化，但其自身的架构是固定的，无法根据任务上下文进行自适应调整。MemEvolve通过共同演化代理的经验知识及其记忆架构，使代理系统不仅能积累经验，还能逐步优化其学习方式。

该研究将自演化记忆系统分解为四个模块化组件：♣ Encode（感知和格式化经验）、♦ Store（存储信息）、♥ Retrieve（上下文感知检索）和♠ Manage（整合和遗忘）。为支持MemEvolve，作者引入了EvolveLab，一个统一的自演化记忆代码库，将十二种代表性记忆系统归纳为上述模块化设计空间，提供了标准化的实现基础和公平的实验环境。

**核心方法：MemEvolve的元演化过程**

MemEvolve的核心是一个双层优化过程：

1.  **内层循环（经验演化）：** 对于每个候选记忆系统 $\Omega^{(k)}_j$ (在第k次演化迭代中)，代理在固定记忆系统指导下适应新的任务流。记忆状态 $M^{(k)}_{t,j}$ 从空记忆开始，并通过与环境和任务经验的交互进行更新：
    $$M^{(k)}_{t+1,j} = \Omega^{(k)}_j(M^{(k)}_{t,j}, \epsilon_\tau), \quad \epsilon_\tau \in E^{(k)}_j(\tau)$$
    其中 $E(\cdot)$ 是经验提取操作符，将轨迹 $\tau$ 映射到经验单元集合。代理使用 $\Omega^{(k)}_j$ 在任务批次 $T^{(k)}_j$ 上执行，生成每个轨迹 $\tau$ 的反馈向量 $f_j(\tau) \in \mathbb{R}^3$，包含任务成功率、token消耗和延迟。通过聚合操作符 $S$，总结出每个候选记忆系统的内层循环结果：
    $$F^{(k)}_j = S(\{f_j(\tau)\}_{\tau \in T^{(k)}_j})$$

2.  **外层循环（架构演化）：** 根据内层循环的结果 $\{F^{(k)}_j\}_{j \in J^{(k)}}$ 更新记忆架构集合。元演化操作符 $F$ 选择高性能候选者并提出新的变体，生成下一迭代的候选集：
    $$\{\Omega^{(k+1)}_{j'}\}_{j' \in J^{(k+1)}} = F(\{\Omega^{(k)}_j\}_{j \in J^{(k)}}, \{F^{(k)}_j\}_{j \in J^{(k)}})$$
    具体来说，操作符 $F$ 包含两个协调组件：
    *   **架构选择 (Architectural Selection)：** 根据每个候选记忆系统的摘要向量 $F^{(k)}_j \triangleq (\text{Perf}^{(k)}_j, -\text{Cost}^{(k)}_j, -\text{Delay}^{(k)}_j)$ 进行排序。首先通过Pareto非支配排序获得Pareto排名 $\rho^{(k)}_j$，然后在同一Pareto排名内按主要性能指标 $\text{Perf}^{(k)}_j$ 进一步排序。选择前 K 个候选者作为父代集合 $P^{(k)}$。
    *   **诊断与设计演化 (Diagnose-and-Design Evolution)：** 对于每个父代架构 $\Omega^{(k)}_p \in P^{(k)}$，通过两阶段过程生成 $S$ 个后代 $\Omega^{(k+1)}_{p,s}$：
        *   **诊断 (Diagnosis)：** 使用来自执行批次 $T^{(k)}_p$ 的轨迹级别证据检查每个父代架构。代理提供结果统计信息（如成功指标、token成本）和结构化的任务查询描述。通过回放接口检查记忆行为，识别检索失败、无效抽象或存储效率低下等架构瓶颈，生成缺陷概况 $D(\Omega^{(k)}_p)$，描述在四个记忆组件 (E, U, R, G) 上的瓶颈。
        *   **设计 (Design)：** 根据缺陷概况 $D(\Omega^{(k)}_p)$，通过修改模块化接口中允许的实现点来构建重新设计的架构，生成 $S$ 个变体：
            $$\Omega^{(k+1)}_{p,s} = \text{Design}(\Omega^{(k)}_p, D(\Omega^{(k)}_p), s), \quad s \in \{1, \dots, S\}$$
            这些变体在编码策略、存储规则、检索约束或管理策略上有所不同。

通过迭代这个双重演化过程，代理不仅仅是在固定记忆系统中积累经验；记忆库和管理记忆的架构共同演化，从而随着时间推移产生更具适应性和资源意识的记忆驱动行为。

**实验评估**

研究在四个挑战性代理基准测试上进行了广泛评估：GAIA、WebWalkerQA、xBench-DeepSearch (xBench-DS) 和 TaskCraft。结果显示：

1.  **显著的性能提升：** MemEvolve使得Flash-Searcher和SmolAgent等框架的性能提升高达17.06%。
2.  **强大的跨任务和跨LLM泛化能力：** 在TaskCraft上演化出的记忆架构能够有效地迁移到未见的基准测试和骨干模型上，性能提升2.0%至9.09%。即使是使用GPT-5-Mini演化出的记忆系统，也能在Kimi K2和DeepSeek V3.2等不同LLM骨干上实现性能提升，例如Kimi K2在WebWalkerQA上提升17.06%。
3.  **跨框架泛化：** MemEvolve发现的框架无关记忆抽象能够直接应用于不同架构的代理系统，如SmolAgent和Flash-Searcher，持续提升性能。
4.  **与现有记忆系统的比较：** 许多现有的人工设计记忆系统无法提供稳定的性能提升，甚至可能在某些任务上表现不佳。相比之下，MemEvolve在所有测试的基准上都带来了稳定且强大的性能提升（3.54%至5.0%），且未显著增加每次任务的API成本或执行延迟。
5.  **记忆演化动力学：** MemEvolve能够从如AgentKB或简单Few-shot记忆（如Lightweight）的基线架构演化出高效的记忆系统，这些演化出的记忆系统在实际任务执行中表现出强大的适应性，能够根据任务阶段提供不同粒度的指导，甚至预判信息来源（如图7所示的Lightweight系统）。

**贡献**

该研究的主要贡献包括：

1.  **统一代码库EvolveLab：** 提出了一个包含编码、存储、检索、管理四个关键组件的模块化设计空间，并提供了广泛自演化代理记忆系统的统一实现和基准测试支持。
2.  **元演化框架MemEvolve：** 提出了一个共同演化代理经验知识及其底层记忆架构的元演化框架，使代理系统能够逐步优化其学习机制。
3.  **全面的实验评估：** 在四个挑战性代理基准上进行了大量实验，证明了MemEvolve的有效性、鲁棒性和泛化能力。






