# 2510.26493_The Context of Context Engineering

* 首页: <https://arxiv.org/abs/2510.26493>
* PDF: <https://arxiv.org/pdf/2510.26493>
* 引用: 
* 组织: 
    * 1SJTU 
    * 2SII 
    * 3GAIR
* 链接
    * GitHub: <https://github.com/GAIR-NLP/Context-Engineering-2.0>
    * 首页: <https://context.opensii.ai/>

## 总结


## From Moonlight


### 三句摘要
1. 💡 这篇论文将“Context Engineering”定义为一种长期演进的学科，它通过降低信息熵来弥合人类意图与机器理解之间的认知鸿沟，并将其发展划分为从“Primitive Computation”到“Superhuman Intelligence”的四个阶段。
2. 🛠️ 论文详细阐述了“Context Engineering”在不同阶段的设计考量，涵盖了“Context Collection & Storage”、多种模态的“Context Management”（如分层记忆、抽象和“self-baking”），以及“Context Usage”（包括系统内外部共享、选择与主动推理）。
3. 🔮 尽管“Context Engineering”在“LLM”时代取得了显著进展，但仍面临上下文收集效率低、大规模存储管理、模型理解能力有限以及长上下文处理瓶颈等挑战，未来需要构建“Semantic Operating System”以实现终身上下文管理。

### 关键词

- Context Engineering: 上下文工程（Context Engineering）是系统性地设计和优化上下文信息的收集、存储、管理和使用，以增强机器的理解能力和任务性能的过程。它被定义为一个函数（CE），接收原始上下文信息（C）和目标任务（T），输出一个经过优化的上下文处理函数（fcontext），该函数能够转换和优化上下文表示，从而提高任务表现。fcontext 可以由各种上下文工程操作（ϕi）组合而成，这些操作可能包括收集、存储、管理、表示、处理多模态输入、整合历史上下文、选择相关元素、跨系统共享上下文以及动态适应等。其核心目标是弥合人类意图与机器理解之间的差距，尤其是在处理高熵信息时，通过“预处理”上下文，将其压缩成机器能够理解的低熵表示。
- Context: 上下文（Context）被定义为“可以用来表征与用户和应用程序之间交互相关的实体（人、地点或对象）的处境的任何信息”。具体来说，它涉及到一组对用户-应用程序交互具有相关性的实体（Erel ⊆ E）的“情境表征”（Char(e)）。一个实体（e）的情境表征是其可能描述信息空间（F）的子集（Char : E → P(F)）。因此，上下文（C）是所有相关实体（e ∈ Erel）的情境表征的集合（C = ⋃e∈ErelChar(e)）。它捕捉了与交互相关的实体所处的“情况”。
- Machine Intelligence: 机器智能（Machine Intelligence）是指机器执行通常需要人类智能才能完成的任务的能力。本文将上下文工程的演变与机器智能的四个阶段联系起来：(i) 原始计算（Primitive Computation），机器只能处理结构化输入，理解能力非常有限；(ii) 智能体中心智能（Agent-Centric Intelligence），机器能够理解自然语言并推断部分意图，如基于大型语言模型（LLM）的智能体；(iii) 人类水平智能（Human-Level Intelligence），机器在推理和理解方面接近人类；(iv) 超人类智能（Superhuman Intelligence），机器的能力超越人类。
- Entropy Reduction: 熵减少（Entropy Reduction）是上下文工程的核心理念。人类在交流时，能够依靠听者的能力主动“填补空白”，即通过共享知识、情感线索和情境意识来推断缺失的上下文，这是一种信息熵降低的过程。而机器（至少目前）缺乏这种能力。因此，上下文工程的“努力”在于将高熵的原始上下文和意图转化为低熵的、机器易于理解的表示。
- Prompt Engineering: 提示工程（Prompt Engineering）是上下文工程在大型语言模型（LLM）时代的一项重要实践。它指设计、组织和管理输入给LLM的文本提示（prompt），以指导模型产生期望的输出。这种技术通过在提示中包含指令、示例或背景信息，来影响模型的行为和性能。它是Era 2.0时期处理高熵文本信息的一种重要手段，旨在最大化LLM在有限上下文窗口内的表现。
- Retrieval-Augmented Generation (RAG): 检索增强生成（Retrieval-Augmented Generation, RAG）是一种将外部知识检索与生成模型相结合的技术。在LLM的应用中，RAG通过在生成文本之前从一个大型知识库中检索相关信息，然后将这些检索到的信息整合到输入提示中，从而增强模型的知识能力和生成内容的准确性。这有助于模型在处理特定领域或需要更新知识的任务时，克服其内部知识的局限性。
- Intelligent Agents: 智能体（Intelligent Agents）是指能够感知其环境、根据自身状态做出决策，并采取行动以实现其目标的自主实体。在本文中，智能体是Era 2.0及以后上下文工程的重要载体。它们能够理解自然语言，处理一定的歧义，并与用户进行更自然的交互。智能体通过上下文管理和利用来执行复杂任务，并在多智能体系统中进行协作。
- Human-Computer Interaction (HCI): 人机交互（Human-Computer Interaction, HCI）是研究人与计算机之间交互的学科。本文追溯了上下文工程的历史演变，指出其根源可以追溯到早期的人机交互研究。在Era 1.0时期，HCI的研究重点在于如何设计更易用的界面和交互方式，以适应当时计算机能力的局限性。例如，从命令行界面（CLI）到图形用户界面（GUI）的转变，就是为了降低用户的认知负担。
- Human-Agent Interaction (HAI): 人机交互（Human-Agent Interaction, HAI）是人与智能体（agent）之间互动过程的研究。随着智能体技术的发展，特别是Era 2.0及以后，人机交互的概念扩展到人与更高级的AI智能体之间的互动。在这种互动中，上下文扮演着至关重要的角色，因为它帮助智能体理解用户的意图、偏好和所处情境，从而提供更个性化和有效的服务。
- Ubiquitous Computing: 普适计算（Ubiquitous Computing）是指将计算能力无缝地嵌入到日常环境中，使得计算机能够“消失”在背景中，用户无需主动与之交互即可获得服务。这个概念在20世纪90年代由Mark Weiser提出，并对Era 1.0时期的上下文工程产生了深远影响。普适计算的愿景促使研究者们探索如何让系统感知用户状态、环境和任务，并据此动态调整行为，即情境感知计算。
- Context-Aware Computing: 情境感知计算（Context-Aware Computing）是指系统能够获取和利用关于用户、环境或任务的上下文信息，并根据这些信息动态调整其行为。这是Era 1.0时期上下文工程的一个关键框架。例如，一个情境感知的系统可能会根据用户当前的位置（上下文）来调整其通知设置。早期的研究，如Dey的定义，为理解和处理上下文奠定了基础。
- Multimodal Context Processing: 多模态上下文处理（Multimodal Context Processing）是指系统能够整合和处理来自多种不同来源和类型的信息，例如文本、图像、音频、视频、传感器数据和环境状态。随着AI系统与现实世界的交互日益深入，理解和融合这些不同模态的信息成为关键挑战。Era 2.0的系统通过将不同模态的输入映射到共享向量空间、使用自注意力机制联合处理或利用跨注意力机制来解决这一问题。
- Self-baking: 自我烘焙（Self-baking）是上下文工程中的一个概念，特指智能体（agent）将原始上下文信息（如对话记录、工具输出、检索到的文档）消化并转化为更紧凑、结构化的表示，以形成持久化知识结构的过程。这模仿了人类认知过程，即将情景记忆（episodic memory）提炼为语义记忆（semantic memory），或将重复性动作抽象为习惯。自我烘焙的关键在于将记忆存储与学习区分开来，使智能体能够积累知识，而不仅仅是回忆。
- Layered Architecture of Memory: 分层记忆架构（Layered Architecture of Memory）是一种管理不同时间尺度信息的方法。类似于操作系统将数据分为不同的内存层级（如RAM和硬盘），AI系统也采用分层记忆来存储和组织上下文。通常包括短期记忆（Short-term Memory），用于存储具有高时间相关性的信息；以及长期记忆（Long-term Memory），用于存储经过处理和抽象的、具有高重要性的信息。这种架构有助于系统快速访问近期相关信息，同时将宝贵知识保存在更稳定、长期的存储中，优化了响应速度和存储效率。
- Context Isolation: 上下文隔离（Context Isolation）是一种通过功能性上下文隔离来管理上下文的策略，旨在克服上下文限制并降低上下文污染的风险。在多智能体系统中，每个子智能体可以拥有自己独立的上下文窗口、系统提示和工具权限。当一个任务匹配某个子智能体的专长时，主系统可以将其委托给该子单元，使其独立运行，而不影响主对话的上下文。这种隔离可以沿着功能维度（如分析、执行）或层级（如规划、实现）进行，确保每个单元只接收其职责所需的最小权限，从而提高系统的可靠性和可解释性。
- Context Usage: 上下文使用（Context Usage）是指智能体如何利用收集、存储和管理的上下文信息来执行任务和增强智能行为。这包括如何在系统内部或跨系统共享上下文、如何选择最相关的上下文以进行理解、如何主动推断用户的潜在需求，以及如何实现上下文的终身保存和更新。上下文的有效使用是实现智能交互和任务成功的关键环节。
- Context Selection: 上下文选择（Context Selection）是指在大量可用上下文中，为当前步骤选择最相关、最有用的信息子集的过程。即使有扩展的上下文窗口，LLM也受限于输入令牌的质量。不相关或嘈杂的上下文会干扰推理并增加成本。因此，上下文选择成为一种“注意力之前的注意力”，旨在决定哪些信息值得被关注。影响选择的因素包括语义相关性、逻辑依赖性、近期性、频率、信息重叠度以及用户偏好和反馈。
- Proactive User Need Inference: 主动用户需求推断（Proactive User Need Inference）是指AI代理不被动等待用户明确表达需求，而是能够通过分析交互历史、用户数据和其他线索，主动推断用户潜在的、未明确表达的意图、偏好和目标，并据此发起有益的交互。这类似于人类助手能够学会“用户偏好视觉摘要”或“晚上适合头脑风暴”。这要求系统能够挖掘、抽象和验证累积的交互上下文，从而提供更个性化的支持。
- Lifelong Context Preservation: 终身上下文保存（Lifelong Context Preservation）是指当上下文信息具有终身性质时，如何以一种连贯、自适应且对人机都可用、可更新的方式来保存和管理。随着交互的累积，上下文的规模和复杂性呈指数级增长，传统的存储和管理方法面临存储瓶颈、处理降级、系统不稳定和评估困难等挑战。实现终身上下文保存需要设计动态、语义健壮且时间感知的记忆系统，并可能需要构建一个能够语义存储、主动管理、修改和遗忘知识的“语义操作系统”。
- Brain-Computer Interfaces (BCI): 脑机接口（Brain-Computer Interfaces, BCI）提供了一种新的上下文工程途径，通过直接捕捉神经信号来实现更高级的上下文收集。与依赖语言输入等传统方法不同，BCI能够收集更丰富的上下文维度，如注意力水平、情绪状态或认知负荷，这些信息难以仅通过外部行为观察到。它还提供了一种更便捷的上下文收集方式，减少了显式用户操作的需求。
- Era 1.0: 第1.0时代（Era 1.0）是指从20世纪90年代到2020年左右的时期，对应于“原始计算”阶段。在此阶段，机器对上下文的解释能力非常有限，只能处理结构化输入和简单的环境线索。上下文工程的实践主要依赖于用户将复杂的人类意图转换为机器可读格式。技术背景包括普适计算、情境感知系统和早期的人机交互，核心实践是传感器融合和规则触发。
- Era 2.0: 第2.0时代（Era 2.0）是指从2020年至今的时期，对应于“智能体中心智能”阶段。以大型语言模型（LLM）的出现为标志，机器智能显著提升，能够理解自然语言并处理更模糊、不完整的信息。上下文工程的重点转向提示工程、检索增强生成（RAG）和内存代理等技术，提高了上下文的容忍度，使机器能够进行更积极的理解和协作。技术背景包括LLM、智能体和提示工程，核心实践是提示、RAG和记忆代理。[Context Engineering] 上下文工程（Context Engineering）是系统性地设计和优化上下文信息的收集、存储、管理和使用，以增强机器的理解能力和任务性能的过程。它被定义为一个函数（CE），接收原始上下文信息（C）和目标任务（T），输出一个经过优化的上下文处理函数（fcontext），该函数能够转换和优化上下文表示，从而提高任务表现。fcontext 可以由各种上下文工程操作（ϕi）组合而成，这些操作可能包括收集、存储、管理、表示、处理多模态输入、整合历史上下文、选择相关元素、跨系统共享上下文以及动态适应等。其核心目标是弥合人类意图与机器理解之间的差距，尤其是在处理高熵信息时，通过“预处理”上下文，将其压缩成机器能够理解的低熵表示。
- Context: 上下文（Context）被定义为“可以用来表征与用户和应用程序之间交互相关的实体（人、地点或对象）的处境的任何信息”。具体来说，它涉及到一组对用户-应用程序交互具有相关性的实体（Erel ⊆ E）的“情境表征”（Char(e)）。一个实体（e）的情境表征是其可能描述信息空间（F）的子集（Char : E → P(F)）。因此，上下文（C）是所有相关实体（e ∈ Erel）的情境表征的集合（C = ⋃e∈ErelChar(e)）。它捕捉了与交互相关的实体所处的“情况”。
- Machine Intelligence: 机器智能（Machine Intelligence）是指机器执行通常需要人类智能才能完成的任务的能力。本文将上下文工程的演变与机器智能的四个阶段联系起来：(i) 原始计算（Primitive Computation），机器只能处理结构化输入，理解能力非常有限；(ii) 智能体中心智能（Agent-Centric Intelligence），机器能够理解自然语言并推断部分意图，如基于大型语言模型（LLM）的智能体；(iii) 人类水平智能（Human-Level Intelligence），机器在推理和理解方面接近人类；(iv) 超人类智能（Superhuman Intelligence），机器的能力超越人类。
- Entropy Reduction: 熵减少（Entropy Reduction）是上下文工程的核心理念。人类在交流时，能够依靠听者的能力主动“填补空白”，即通过共享知识、情感线索和情境意识来推断缺失的上下文，这是一种信息熵降低的过程。而机器（至少目前）缺乏这种能力。因此，上下文工程的“努力”在于将高熵的原始上下文和意图转化为低熵的、机器易于理解的表示。
- Prompt Engineering: 提示工程（Prompt Engineering）是上下文工程在大型语言模型（LLM）时代的一项重要实践。它指设计、组织和管理输入给LLM的文本提示（prompt），以指导模型产生期望的输出。这种技术通过在提示中包含指令、示例或背景信息，来影响模型的行为和性能。它是Era 2.0时期处理高熵文本信息的一种重要手段，旨在最大化LLM在有限上下文窗口内的表现。
- Retrieval-Augmented Generation (RAG): 检索增强生成（Retrieval-Augmented Generation, RAG）是一种将外部知识检索与生成模型相结合的技术。在LLM的应用中，RAG通过在生成文本之前从一个大型知识库中检索相关信息，然后将这些检索到的信息整合到输入提示中，从而增强模型的知识能力和生成内容的准确性。这有助于模型在处理特定领域或需要更新知识的任务时，克服其内部知识的局限性。
- Intelligent Agents: 智能体（Intelligent Agents）是指能够感知其环境、根据自身状态做出决策，并采取行动以实现其目标的自主实体。在本文中，智能体是Era 2.0及以后上下文工程的重要载体。它们能够理解自然语言，处理一定的歧义，并与用户进行更自然的交互。智能体通过上下文管理和利用来执行复杂任务，并在多智能体系统中进行协作。
- Human-Computer Interaction (HCI): 人机交互（Human-Computer Interaction, HCI）是研究人与计算机之间交互的学科。本文追溯了上下文工程的历史演变，指出其根源可以追溯到早期的人机交互研究。在Era 1.0时期，HCI的研究重点在于如何设计更易用的界面和交互方式，以适应当时计算机能力的局限性。例如，从命令行界面（CLI）到图形用户界面（GUI）的转变，就是为了降低用户的认知负担。
- Human-Agent Interaction (HAI): 人机交互（Human-Agent Interaction, HAI）是人与智能体（agent）之间互动过程的研究。随着智能体技术的发展，特别是Era 2.0及以后，人机交互的概念扩展到人与更高级的AI智能体之间的互动。在这种互动中，上下文扮演着至关重要的角色，因为它帮助智能体理解用户的意图、偏好和所处情境，从而提供更个性化和有效的服务。
- Ubiquitous Computing: 普适计算（Ubiquitous Computing）是指将计算能力无缝地嵌入到日常环境中，使得计算机能够“消失”在背景中，用户无需主动与之交互即可获得服务。这个概念在20世纪90年代由Mark Weiser提出，并对Era 1.0时期的上下文工程产生了深远影响。普适计算的愿景促使研究者们探索如何让系统感知用户状态、环境和任务，并据此动态调整行为，即情境感知计算。
- Context-Aware Computing: 情境感知计算（Context-Aware Computing）是指系统能够获取和利用关于用户、环境或任务的上下文信息，并根据这些信息动态调整其行为。这是Era 1.0时期上下文工程的一个关键框架。例如，一个情境感知的系统可能会根据用户当前的位置（上下文）来调整其通知设置。早期的研究，如Dey的定义，为理解和处理上下文奠定了基础。
- Multimodal Context Processing: 多模态上下文处理（Multimodal Context Processing）是指系统能够整合和处理来自多种不同来源和类型的信息，例如文本、图像、音频、视频、传感器数据和环境状态。随着AI系统与现实世界的交互日益深入，理解和融合这些不同模态的信息成为关键挑战。Era 2.0的系统通过将不同模态的输入映射到共享向量空间、使用自注意力机制联合处理或利用跨注意力机制来解决这一问题。
- Self-baking: 自我烘焙（Self-baking）是上下文工程中的一个概念，特指智能体（agent）将原始上下文信息（如对话记录、工具输出、检索到的文档）消化并转化为更紧凑、结构化的表示，以形成持久化知识结构的过程。这模仿了人类认知过程，即将情景记忆（episodic memory）提炼为语义记忆（semantic memory），或将重复性动作抽象为习惯。自我烘焙的关键在于将记忆存储与学习区分开来，使智能体能够积累知识，而不仅仅是回忆。
- Layered Architecture of Memory: 分层记忆架构（Layered Architecture of Memory）是一种管理不同时间尺度信息的方法。类似于操作系统将数据分为不同的内存层级（如RAM和硬盘），AI系统也采用分层记忆来存储和组织上下文。通常包括短期记忆（Short-term Memory），用于存储具有高时间相关性的信息；以及长期记忆（Long-term Memory），用于存储经过处理和抽象的、具有高重要性的信息。这种架构有助于系统快速访问近期相关信息，同时将宝贵知识保存在更稳定、长期的存储中，优化了响应速度和存储效率。
- Context Isolation: 上下文隔离（Context Isolation）是一种通过功能性上下文隔离来管理上下文的策略，旨在克服上下文限制并降低上下文污染的风险。在多智能体系统中，每个子智能体可以拥有自己独立的上下文窗口、系统提示和工具权限。当一个任务匹配某个子智能体的专长时，主系统可以将其委托给该子单元，使其独立运行，而不影响主对话的上下文。这种隔离可以沿着功能维度（如分析、执行）或层级（如规划、实现）进行，确保每个单元只接收其职责所需的最小权限，从而提高系统的可靠性和可解释性。
- Context Usage: 上下文使用（Context Usage）是指智能体如何利用收集、存储和管理的上下文信息来执行任务和增强智能行为。这包括如何在系统内部或跨系统共享上下文、如何选择最相关的上下文以进行理解、如何主动推断用户的潜在需求，以及如何实现上下文的终身保存和更新。上下文的有效使用是实现智能交互和任务成功的关键环节。
- Context Selection: 上下文选择（Context Selection）是指在大量可用上下文中，为当前步骤选择最相关、最有用的信息子集的过程。即使有扩展的上下文窗口，LLM也受限于输入令牌的质量。不相关或嘈杂的上下文会干扰推理并增加成本。因此，上下文选择成为一种“注意力之前的注意力”，旨在决定哪些信息值得被关注。影响选择的因素包括语义相关性、逻辑依赖性、近期性、频率、信息重叠度以及用户偏好和反馈。
- Proactive User Need Inference: 主动用户需求推断（Proactive User Need Inference）是指AI代理不被动等待用户明确表达需求，而是能够通过分析交互历史、用户数据和其他线索，主动推断用户潜在的、未明确表达的意图、偏好和目标，并据此发起有益的交互。这类似于人类助手能够学会“用户偏好视觉摘要”或“晚上适合头脑风暴”。这要求系统能够挖掘、抽象和验证累积的交互上下文，从而提供更个性化的支持。
- Lifelong Context Preservation: 终身上下文保存（Lifelong Context Preservation）是指当上下文信息具有终身性质时，如何以一种连贯、自适应且对人机都可用、可更新的方式来保存和管理。随着交互的累积，上下文的规模和复杂性呈指数级增长，传统的存储和管理方法面临存储瓶颈、处理降级、系统不稳定和评估困难等挑战。实现终身上下文保存需要设计动态、语义健壮且时间感知的记忆系统，并可能需要构建一个能够语义存储、主动管理、修改和遗忘知识的“语义操作系统”。
- Brain-Computer Interfaces (BCI): 脑机接口（Brain-Computer Interfaces, BCI）提供了一种新的上下文工程途径，通过直接捕捉神经信号来实现更高级的上下文收集。与依赖语言输入等传统方法不同，BCI能够收集更丰富的上下文维度，如注意力水平、情绪状态或认知负荷，这些信息难以仅通过外部行为观察到。它还提供了一种更便捷的上下文收集方式，减少了显式用户操作的需求。
- Era 1.0: 第1.0时代（Era 1.0）是指从20世纪90年代到2020年左右的时期，对应于“原始计算”阶段。在此阶段，机器对上下文的解释能力非常有限，只能处理结构化输入和简单的环境线索。上下文工程的实践主要依赖于用户将复杂的人类意图转换为机器可读格式。技术背景包括普适计算、情境感知系统和早期的人机交互，核心实践是传感器融合和规则触发。
- Era 2.0: 第2.0时代（Era 2.0）是指从2020年至今的时期，对应于“智能体中心智能”阶段。以大型语言模型（LLM）的出现为标志，机器智能显著提升，能够理解自然语言并处理更模糊、不完整的信息。上下文工程的重点转向提示工程、检索增强生成（RAG）和内存代理等技术，提高了上下文的容忍度，使机器能够进行更积极的理解和协作。技术背景包括LLM、智能体和提示工程，核心实践是提示、RAG和记忆代理。

### 摘要

这篇论文深入探讨了“Context Engineering”（上下文工程）这一概念，并将其置于一个广阔的历史和理论框架中，而非仅仅局限于当前大型语言模型（LLM）时代的创新。论文强调，上下文工程的本质在于弥合人类（碳基智能）与机器（硅基智能）之间的认知鸿沟，通过有效管理上下文信息来增强机器对人类意图的理解和任务执行能力。

**核心思想与演进阶段：**
论文将上下文工程定义为一个系统性的过程，旨在设计和优化上下文的收集（collection）、存储（storage）、管理（management）和使用（usage），以提高机器的理解能力和任务表现。形式化定义为：
$$CE : (C, T) \to f_{context}$$
其中，$C$ 代表原始的上下文信息，如公式(2)所定义：$C = \bigcup_{e \in E_{rel}} Char(e)$，表示与用户和应用程序交互相关的实体 $E_{rel}$ 的所有特征信息 $Char(e)$ 的集合；$T$ 代表目标任务或应用领域；$f_{context}$ 是上下文处理函数，它通过一系列操作 $\phi_i$ 的组合 $F$ 来转换和优化上下文表示，即 $f_{context}(C) = F(\phi_1, \phi_2, \dots, \phi_n)(C)$。这些操作包括收集、存储、表示、处理多模态输入、整合历史上下文、选择相关元素、共享上下文以及动态调整。

论文提出，上下文工程的发展与机器智能的进步紧密相关，经历了四个演进阶段：
1.  **Context Engineering 1.0 (原始计算阶段, 1990s-2020):** 机器智能有限，主要处理结构化、低熵的输入。人类作为“意图翻译者”，需将复杂意图转换为机器可直接处理的格式。代表性技术包括普适计算（Ubiquitous Computing）、上下文感知系统（Context-Aware Systems）和人机交互（HCI）。核心实践是基于传感器的情境获取和规则触发响应，如Dey的Context Toolkit框架，通过Context Widgets、Interpreters、Aggregators、Services和Discoverers等抽象层实现模块化管理。
2.  **Context Engineering 2.0 (Agent-Centric Intelligence阶段, 2020至今):** LLM的兴起使机器能够理解自然语言并推断隐含意图。上下文不再限于显式信号，可包含模糊和不完整信息。核心特点是对原始上下文的容忍度提高，能处理自由文本、图像等自然人类表达形式。系统从被动感知转向主动理解和协作。
3.  **Context Engineering 3.0 (Human-Level Intelligence阶段, 未来):** 智能系统将达到人类水平的推理和理解能力，能够感知社交线索、情感状态等高熵信息，实现真正自然的人机协作。
4.  **Context Engineering 4.0 (Superhuman Intelligence阶段, 猜测):** 智能系统超越人类能力，能够主动构建上下文，揭示人类未明确表达的需求，甚至引导人类思维。

**核心方法论详解：**

1.  **上下文收集与存储 (Context Collection and Storage):**
    *   **时代1.0:** 主要在单一设备上进行，使用有限传感器（GPS、时钟、键盘/鼠标事件）或应用日志，存储在本地文件或简单数据库中，优先考虑独立可用性。
    *   **时代2.0:** 跨多终端分布式收集（智能手机、可穿戴设备、云服务），集成多模态信号。存储采用分层架构：短期频繁访问数据缓存于快速内存/边缘节点；中期保留数据存储于本地嵌入式数据库（如SQLite、LevelDB、RocksDB）或操作系统安全存储；长期持久化数据存储于云平台/远程服务器数据库，支持跨设备同步。对于Agent，任务状态和进度周期性存储于长期记忆，以实现中断恢复。例如，Claude Code通过维护结构化笔记实现轻量级持久记忆。
    *   **未来3.0:** AI系统将实现人类级别的上下文感知，收集触觉、嗅觉、味觉、情绪状态等信息，统一为动态的个人数字记忆，并具备类人“遗忘”和“回忆”能力。

2.  **上下文管理 (Context Management):**
    *   **文本上下文处理 (Textual Context Processing):**
        *   **带时间戳标记:** 简单且维护成本低，但缺乏语义结构，难以捕获长程依赖。
        *   **按功能和语义属性标记:** 通过“goal”、“decision”、“action”等标签组织上下文，支持多维度标记（如优先级、来源信息），提高检索效率。
        *   **用QA对压缩:** 将上下文重构为问答对，提高检索效率，但不适合需要全面理解上下文的任务。
        *   **用分层笔记压缩:** 信息组织成树状结构，明确分组关系，但难以表示因果、证据等逻辑关系，也无法捕获理解随时间演变的过程。
    *   **多模态上下文处理 (Multi-Modal Context Processing):**
        *   **映射到可比较的向量空间:** 将不同模态（文本、图像、视频）的输入通过各自的编码器处理后，映射到共享的嵌入空间，使语义相关内容在空间中接近。
        *   **结合不同模态进行自注意力 (Self-Attention):** 在共享嵌入空间中，模态特定Tokens由单一Transformer架构联合处理，实现细粒度的跨模态对齐和推理。
        *   **通过交叉注意力 (Cross-Attention) 使一种模态关注另一种:** 使用交叉注意力层，使一种模态（如文本）直接关注另一种模态（如图像）的特定部分，灵活检索跨模态相关信息。
    *   **上下文组织 (Context Organization):**
        *   **分层记忆架构 (Layered Architecture of Memory):** 效仿操作系统管理RAM，将记忆分为短期记忆（$M_s = f_{short}(c \in C : w_{temporal}(c) > \theta_s)$）和长期记忆（$M_l = f_{long}(c \in C : w_{importance}(c) > \theta_l \land w_{temporal}(c) \le \theta_s)$），通过记忆转移函数 $f_{transfer} : M_s \to M_l$ 实现频繁或重要信息的固化。
        *   **上下文隔离 (Context Isolation):** 引入子代理（Subagent），每个子代理有独立的上下文窗口、系统提示和工具权限，实现功能隔离，减少上下文污染，提高系统可靠性和可解释性。例如，LeadResearcher通过子代理并行处理任务，并总结中间结果。
        *   **轻量级引用 (Lightweight References):** 将大量信息外部存储，模型窗口中只暴露简洁引用，如HuggingFace的CodeAgent沙盒机制或基于Schema的状态对象。
    *   **上下文抽象 (Context Abstraction) / 自我烘焙 (Self-Baking):** 将原始上下文转化为更紧凑、结构化的表示，类似人类认知中情景记忆转化为语义记忆的过程。
        *   **分层记忆架构的应用:** 原始上下文存储在底层，通过逐级总结抽象为更高级别的表示。
        *   **添加自然语言摘要:** 存储原始上下文的同时，周期性生成摘要，提供压缩视图。可多级摘要或根据时效性/重要性删除。
        *   **使用固定Schema提取关键事实:** 提取关键信息至预定义格式（如实体图、事件记录、任务树），便于推理。CodeRabbit通过构建结构化案例文件实现。
        *   **将上下文逐步压缩成捕获含义的向量:** 将信息编码为致密的数值向量（embeddings），通过池化（pooling）或与现有长期状态融合，形成渐进抽象的语义记忆。

3.  **上下文使用 (Context Usage):**
    *   **系统内部上下文共享 (Intra-System Context Sharing):** 多Agent系统间信息传递机制。
        *   **将先前上下文嵌入提示:** 将前一个Agent的上下文（常经格式化）直接包含在下一个Agent的输入提示中。
        *   **Agent间交换结构化消息:** Agent通过预定义Schema的结构化消息进行通信。
        *   **使用共享内存进行间接通信:** Agent通过读写共享内存空间（如集中式外部存储、Blackboard、任务图Task Graph，或语义图Semantic Graph）进行间接协作。
    *   **跨系统上下文共享 (Cross-System Context Sharing):** 不同平台、模型或应用间共享上下文。
        *   **使用适配器转换上下文:** 每个系统保持自身格式，通过转换器翻译上下文。
        *   **跨系统使用共享表示:** 所有系统从一开始就约定使用相同的表示，如共享数据格式（JSON/API）、人类可读摘要，或语义向量（embeddings）。
    *   **上下文选择以进行理解 (Context Selection for Understanding):** 从可用上下文中选择最相关的子集。
        *   **考量因素:** 语义相关性（向量检索）、逻辑依赖（如MEM1的推理链跟踪）、新近度与频率（优先选择最新或常用信息）、重叠信息（过滤冗余）、用户偏好与反馈（通过交互学习用户习惯）。
        *   **过滤策略:** 分段（固定行、Token窗口或AST-based）、检索（语义检索、非语义检索、结构化检索）、重排（Reranking）。
    *   **主动用户需求推断 (Proactive User Need Inference):** 推断用户未明确表达的潜在需求、偏好和目标。
        *   **学习和适应用户偏好:** 分析对话历史和个人数据，构建用户画像。
        *   **从相关问题推断隐藏目标:** 分析查询序列，LLM可预测潜在需求。
        *   **基于用户困境主动提供帮助:** 检测用户受阻信号，主动提供工具或建议。
    *   **终身上下文保存与更新 (Lifelong Context Preservation and Update):**
        *   **挑战:** 存储瓶颈（资源限制下的有效保留与检索）、处理退化（注意力机制O($N^2$)复杂度、推理质量下降）、系统不稳定性（小错误扩散）、评估困难（现有基准不足以衡量长期记忆的正确性）。
        *   **未来方向：语义操作系统 (Semantic Operating System):** 目标是构建一个能随时间演进的语义操作系统，具备大规模、高效的语义存储、类人记忆管理（主动添加、修改、遗忘知识）、新型架构（超越Transformer的平面时间建模）、可解释性（追踪、纠正、解释推理步骤）。

**应用领域：**
论文列举了上下文工程在多个领域的应用：
*   **命令行界面 (CLI):** 如Google Gemini CLI，通过GEMINI.md文件组织项目背景、角色定义等上下文，并结合文件系统层级实现上下文继承和隔离。动态上下文（对话历史）可被AI生成摘要压缩。
*   **深度研究 (Deep Research):** 如Tongyi DeepResearch，通过周期性调用专门的摘要模型压缩累积历史，形成“上下文快照”，支撑长周期知识密集型查询。
*   **脑机接口 (Brain-Computer Interfaces, BCIs):** 作为一种新型上下文收集途径，BCIs能直接捕获神经信号，获取注意力、情绪状态、认知负荷等更丰富的内部上下文信息，减少对显式用户输入的依赖。

**挑战与未来方向：**
论文指出当前上下文工程面临的核心挑战：上下文收集仍有限且低效、大规模上下文的存储和管理复杂、模型对上下文的理解有限、长上下文处理性能瓶颈、选择相关有用上下文的准确性不足。未来，上下文工程将不仅是技术实践，更是对人类与机器之间“数字存在”和“社会关系”的重新定义。

## Abstract


*   **核心理念与背景**
    *   论文开篇引用马克思的观点，指出人类本质上是社会关系的总和，强调个体深受其交互环境（即上下文）的影响。
    *   随着计算机和人工智能的发展，这种“上下文”的概念不再局限于人际互动，而是扩展到了**人机交互**（Human-Machine Interaction）领域。
    *   由此引出一个核心问题：机器如何才能更好地理解人类的处境和意图？为了应对这一挑战，**上下文工程**应运而生。

*   **上下文工程的历史演变**
    *   论文指出，尽管上下文工程常被认为是智能体（Agent）时代的新兴概念，但实际上，相关实践可追溯到20多年前，即20世纪90年代早期。
    *   其演变经历了几个不同的历史阶段，每个阶段都与**机器智能**水平的提升紧密相关：
        *   **早期阶段**：围绕原始计算机构建的**人机交互**（Human-Computer Interaction, HCI）框架。
        *   **当前阶段**：由智能体驱动的**人机智能体交互**（Human-Agent Interaction, HAI）范式。
        *   **未来展望**：可能发展到机器具备人类水平甚至**超人类智能**的阶段。

*   **本文的贡献与目标**
    *   **定位和定义**：本文旨在对上下文工程进行全面的定位，并提供一个系统性的定义。
    *   **历史与概念梳理**：概述上下文工程的历史发展和概念图景。
    *   **实践设计考量**：探讨其实践中的关键设计考虑因素。
    *   **构建基础**：通过回答上述问题，为上下文工程奠定概念基础，并展望其未来前景。
    *   **推动发展**：本文是为推动AI系统中系统化上下文工程所迈出的重要一步，期望能引发更广泛的社区努力。




## 1 Introduction


### 背景与问题提出
近年来，**大语言模型（LLM）** 和**智能代理（intelligent agents）** 的快速发展引发了对“**上下文如何影响模型行为**”的广泛关注。研究表明，上下文窗口中的内容对模型性能有显著影响。同时，随着对**多步骤推理** 和**长时程任务** 的需求增长，一个核心问题浮现：**我们如何通过有效的上下文机制，使机器更好地理解和执行人类意图，尤其是在长期任务中？**

### 上下文工程的兴起
为应对这一挑战，**上下文工程（context engineering）** 成为研究热点。它指的是**设计、组织和管理上下文信息，以使机器行为更符合人类意图**。近年来，上下文工程在LLM和智能代理中得到了广泛应用，包括：
- **提示工程（prompt engineering）**
- **检索增强生成（RAG）**
- **工具调用（tool calling）**
- **长期记忆机制**

这些技术提升了机器处理高熵上下文的能力，并深刻影响了交互系统的设计。

### 对上下文工程的误解与历史回顾
尽管取得进展，**上下文工程常被误认为是新兴技术**，且“上下文”常被狭义地理解为对话历史、系统提示或代理环境输入。实际上，**上下文工程已有20多年的发展历史**，早期在**普适计算、上下文感知系统和人机交互** 领域已有大量研究，奠定了今天仍适用的基础原则。

### 核心观点：上下文工程是“熵减”过程
作者提出，**上下文工程本质上是一个“熵减”过程**。与人类能通过共享知识、情感线索等主动填补信息空白不同，当前机器缺乏这种能力，因此需要人类“预处理”上下文，将其压缩为机器可理解的形式。这一过程是上下文工程的核心“努力”所在。

图2展示了碳基（人类）与硅基（机器）认知能力的差距，说明了上下文工程的必要性。随着机器智能的快速迭代，上下文工程将越来越自然，人机交互成本也将降低。

### 上下文工程的演进阶段
每一次机器智能的飞跃都会引发**人机接口的根本性变革**，进而推动上下文工程的范式转变。图3展示了这一演化过程，作者据此提出上下文工程发展的四个阶段：
1. **1.0阶段**：原始计算，依赖结构化、低熵输入（如命令行）
2. **2.0阶段**：智能代理，能理解自然语言和处理模糊信息
3. **3.0阶段**：类人智能，实现细腻沟通与无缝协作
4. **4.0阶段**：超人智能，机器能主动构建上下文并揭示人类未明说的需求

每个阶段都代表了人机角色的转变和设计权衡的质变。

### 论文贡献
本文的主要贡献包括：
1. 将上下文工程置于更广阔的历史视角中，追溯其在现代智能代理出现前的发展。
2. 提出一个系统性的理论框架，从“熵减”角度揭示其本质，并提出四阶段演化模型。
3. 通过比较典型实践，提出通用设计考量，为未来智能系统开发提供指导。

### 后续章节安排
文章后续将：
- 给出上下文工程的定义并阐述理论框架；
- 回顾其历史演进，重点分析1.0和2.0阶段；
- 基于三个核心维度（上下文采集、管理与使用）探讨设计考量；
- 分析当前实践、识别挑战，并探索未来发展方向。


## 2 Theoretical Framework



本章旨在通过形式化定义，建立对“上下文”（context）的理论理解，并在此基础上提出“上下文工程”（Context Engineering）的概念，同时分析其在不同阶段的机器智能中的演变。

---

### 2.1 形式化定义（Formal Definition）

本节通过数学语言对“实体”、“交互”、“上下文”和“上下文工程”进行形式化定义，构建理论基础。

#### 定义1：实体与特征化（Entity and Characterization）

- **实体**（Entity）：包括用户、应用、对象、环境等。
- **特征化信息**（Characterization Information）：描述实体的各种信息。
- **特征化函数**（Char）：将实体映射到其特征信息集合的函数。

公式表示为：  
$$ \text{Char}:\mathcal{E} \rightarrow \mathcal{P}(\mathcal{F}) $$  
其中，$\mathcal{E}$ 是实体空间，$\mathcal{F}$ 是特征信息空间，$\mathcal{P}(\mathcal{F})$ 表示 $\mathcal{F}$ 的幂集。

**示例**：在 Gemini CLI 中，用户输入命令时，涉及的实体包括用户、应用、环境、工具、记忆模块和模型服务等，每个实体都有其对应的特征信息。

---

#### 定义2：交互（Interaction）

- **交互**：指用户与应用之间的任何可观测行为，包括显式行为（如点击、输入命令）和隐式行为（如注意力模式、环境变化）。

**示例**：在 Gemini CLI 中，用户输入命令是显式交互，终端状态、记忆模块使用情况等是隐式交互。

---

#### 定义3：上下文（Context）

- **上下文**：由与交互相关的所有实体的特征信息集合构成。

公式表示为：  
$$ C = \bigcup_{e \in \mathcal{E}_{\text{rel}}} \text{Char}(e) $$  
其中，$\mathcal{E}_{\text{rel}}$ 是与交互相关的实体集合。

**说明**：该定义扩展了 Dey（2001）的经典定义，强调上下文是对相关实体情境的全面描述。

---

#### 定义4：上下文工程（Context Engineering）

- **上下文工程**：系统性地设计和优化上下文的采集、存储、管理和使用，以提升机器的理解和任务表现。

公式表示为：  
$$ \text{CE}:(C, \mathcal{T}) \rightarrow f_{\text{context}}(C) $$  
其中，$C$ 是原始上下文信息，$\mathcal{T}$ 是目标任务，$f_{\text{context}}$ 是上下文处理函数。

- **上下文处理函数**：由多个上下文操作 $\phi_i$ 组成，通过组合函数 $\mathcal{F}$ 构建：

$$ f_{\text{context}}(C) = \mathcal{F}(\phi_1, \phi_2, \ldots, \phi_n)(C) $$

**操作示例**：
1. 上下文采集
2. 存储与管理
3. 多模态处理
4. 上下文复用（“自烘焙”）
5. 上下文选择与共享
6. 动态适应

---

#### 上下文工程的范围与意义

- **范围**：不局限于特定技术或时代，适用于从90年代图形界面到2025年智能代理的各类系统。
- **核心挑战**：始终是“如何让机器准确理解上下文与意图”。

**定义的重要性**：
1. 将当前的提示工程与人机交互设计历史连接起来；
2. 提供解释上下文设计为何在不同技术阶段有效的理论框架；
3. 为预测未来上下文工程的发展提供基础。

---

### 2.2 阶段划分（Stage Characterization）

本节将上下文工程的发展划分为四个阶段，对应机器智能的演进路径。

#### 阶段1.0：原始计算（Primitive Computation，1990s–2020）

- **特点**：机器只能处理结构化输入，理解能力有限。
- **交互方式**：依赖菜单、按钮等预定义格式。
- **上下文处理**：需人工将信息转换为机器可理解格式。

---

#### 阶段2.0：代理中心智能（Agent-Centric Intelligence，2020–现在）

- **转折点**：大语言模型（LLM）的出现（如 GPT-3）。
- **能力提升**：能理解自然语言，推理隐含意图。
- **上下文处理**：可处理模糊和不完整信息，支持上下文学习（in-context learning）。
- **代表研究**：Bommasani et al. (2021)

---

#### 阶段3.0：人类水平智能（Human-Level Intelligence，未来）

- **预期能力**：接近人类的理解与推理能力。
- **上下文处理**：能感知高熵信息（如情绪、社交线索），实现更自然的人机协作。
- **目标**：AI 成为人类的“知识伙伴”。

---

#### 阶段4.0：超人智能（Superhuman Intelligence，推测阶段）

- **能力特征**：超越人类理解能力，具备“上帝视角”。
- **上下文处理**：主动构建上下文，发现人类未察觉的需求。
- **人机关系转变**：从机器适应人类，变为人类从机器获取洞察。
- **示例**：AlphaGo 帮助人类棋手发现新策略（Silver et al., 2016）。

---

### 总结

本章通过形式化定义构建了上下文与上下文工程的理论基础，并将其置于机器智能发展的历史脉络中。从原始计算到超人智能，上下文工程始终是人机交互的核心，其技术手段不断演进，但核心目标始终未变：让机器更准确地理解人类意图，提升协作效率。


## 3 Historical Evolution

本节通过对比“上下文工程1.0”（1990s–2020）与“上下文工程2.0”（2020–现在）在多个维度上的差异，梳理上下文工程的发展脉络，帮助理解其演变逻辑。

| 维度 | 上下文工程1.0 | 上下文工程2.0 |
| --- | --- | --- |
| 时间段 | 1990s–2020 | 2020–现在 |
| 技术背景 | 普适计算、上下文感知系统、人机交互 | 大语言模型、智能体、提示工程 |
| 典型系统 | Context Toolkit、CooTown、ContextPhone | ChatGPT、LangChain、AutoGPT、Letta |
| 上下文模态 | 地点、身份、活动、时间、环境、设备状态 | token序列、检索文档、工具API、用户历史 |
| 核心机制 | 传感器融合、规则触发 | 提示、RAG、CoT、记忆代理 |
| 上下文容忍度 | 相对较低 | 相对较高 |
| 类人程度 | 相对较低 | 相对较高 |

**重点总结：**
- 1.0阶段依赖结构化输入和规则逻辑，系统被动响应；
- 2.0阶段引入大模型和智能体，系统具备主动理解和协作能力；
- 从“感知上下文”到“与上下文协作”，是系统智能化的重要跃迁。

---

### 3.1 超过20年前：1.0时代

**定义：**  
上下文工程1.0是指通过结构化方式，将人类意图转化为机器可理解的信息，实现人机有效沟通。

**时间范围：** 1990s–2020  
**核心特点：**  
- 人类是上下文的提供者，机器是接收者；
- 设计者充当“意图翻译者”，将复杂意图转化为机器可处理的结构化输入；
- 系统依赖预设规则和传感器输入，缺乏语义理解和推理能力。

#### 3.1.1 技术背景

- 从命令行界面（CLI）向图形界面（GUI）过渡；
- Mark Weiser提出“普适计算”（Ubiquitous Computing）概念（1991），强调计算无缝融入生活；
- Schilit和Theimer提出“上下文感知计算”（Context-Aware Computing）（1994），探索系统如何感知用户状态并动态调整行为；
- 技术限制：机器无法理解自然语言、推理或容错，需依赖人工设计的交互路径和反馈机制。

#### 3.1.2 理论基础

- Anind K. Dey在2001年提出经典定义：“上下文是任何可以用来描述实体状态的信息”；
- 强调上下文的多维性，涵盖人、地点、对象等；
- 理论全面且系统，与当前更聚焦于聊天历史等局部上下文形成对比；
- 当前应回归1.0理论，构建更全面的上下文系统。

#### 3.1.3 核心实践

- 从键盘鼠标转向传感器驱动的分布式上下文采集；
- Dey提出通用上下文系统框架；
- Context Toolkit是代表性实现，提供模块化架构：
  - **Context Widgets**：封装传感器；
  - **Interpreters**：解析原始数据；
  - **Aggregators**：整合多源上下文；
  - **Services**：提供应用接口；
  - **Discoverers**：动态注册上下文组件；
- 架构清晰，为后续发展奠定基础。

**总结：**  
上下文工程1.0奠定了响应式系统的基础，融合普适计算与人机交互理念，通过模块化设计实现上下文感知。尽管表达力和扩展性有限，但为2.0的发展提供了理论与架构基础。

---

### 3.2 20年后：2.0时代

**定义：**  
上下文工程2.0标志着从原始计算向智能代理的跃迁，系统具备更强的上下文理解与协作能力。

**核心变化：**
1. **上下文获取：** 传感器种类与能力大幅提升；
2. **上下文容忍度：** 从结构化输入转向自然表达（如文本、图像）；
3. **上下文理解与使用：** 从被动响应转向主动协作。

#### 上下文获取：先进传感器

- 表2列举了多种设备及其采集的上下文模态，如：
  - 智能手机：文本、图像、音频、位置；
  - 智能手表：心率、运动；
  - AR眼镜：视线、语音、场景；
  - 脑机接口：神经信号、情绪；
  - 家庭IoT：环境、声音、动作；
- 每个设备可采集多种模态信息，上下文来源更加丰富。

#### 原始上下文容忍度：从结构化输入到人类原生信号

- 1.0时代依赖预定义结构化信号（如GPS、时间）；
- 2.0时代可处理自然表达（如自由文本、图像、视频）；
- 基于大模型和多模态感知，系统能处理模糊、不完整、高熵数据；
- 不再依赖人工预处理，上下文可直接以原生形式输入；
- 向类人理解能力迈进。

#### 上下文理解与使用：从被动感知到主动协作

- 1.0系统基于规则触发（如“在办公室则静音”）；
- 2.0系统能理解用户行为意图，主动协作（如写作时建议下一段内容）；
- 系统不再是“感知上下文”，而是“与上下文协作”；
- 实现从“Context-Aware”到“Context-Cooperative”的转变。

**总结：**  
上下文工程2.0在获取、容忍、理解和使用上下文方面均有显著提升，系统具备更强的类人智能与协作能力，标志着上下文工程进入智能代理新阶段。

--- 

**总体总结：**
- 上下文工程从1.0到2.0经历了从结构化输入、规则响应到自然表达、主动协作的演变；
- 1.0奠定了理论与架构基础，2.0则借助大模型和智能体实现智能化跃迁；
- 未来应融合1.0的全面性与2.0的智能性，构建更强大、更自然的上下文系统。


## 4 Context Collection and Storage

### 设计考虑（Design Considerations）

本节探讨了如何优雅地收集和存储上下文，提出了多个关键技术方向与系统示例：

#### 上下文管理（Context Management）

- **时间戳标记上下文**：通过时间戳记录上下文的时间信息，便于后续检索与排序。  
  示例：MemOS、Manus。

- **按角色或功能打标签**：将上下文按其语义角色或功能分类，便于结构化管理。  
  示例：LLM4Tag。

- **问答对压缩**：将上下文压缩为问答对形式，便于高效存储与检索。  
  示例：Deep Cognition。

- **分层笔记压缩**：使用结构化笔记形式对上下文进行分层压缩。  
  示例：SII CLI。

#### 多模态上下文融合（Multi-modal Context Fusion）

- **编码到可比较向量空间**：将不同模态的信息统一编码到同一向量空间中，便于比较与融合。  
  示例：ChatGPT、Claude。

- **自注意力机制融合**：对各模态分别编码后，使用自注意力机制进行融合。  
  示例：ChatGPT、Claude。

- **跨模态注意力机制**：用一种模态去关注另一种模态，实现跨模态理解。  
  示例：Qwen2-VL。

#### 上下文组织与管理（Context Organization and Management）

- **分层记忆架构**：将上下文按使用频率和重要性分层存储。  
  示例：UI-TARS。

- **子代理机制**：通过功能隔离实现上下文隔离，提升系统模块化与安全性。  
  示例：Claude。

#### 上下文“自烘焙”（Context Self-baking）

- **原始上下文+自然语言摘要**：先存储原始信息，再生成摘要便于后续理解。  
  示例：Claude Code、Gemini CLI。

- **原始上下文+结构化事实提取**：从原始上下文中提取结构化信息。  
  示例：ChatSchema。

- **直接结构化存储**：直接以结构化格式存储信息，便于机器处理。  
  示例：HMT。

- **渐进式压缩为语义向量**：将上下文逐步压缩为语义向量，支持长期记忆。  
  示例：H-MEM。

#### 上下文使用（Context Usage）

- **如何选择合适的上下文？**  
  示例：Letta、MEM1。

- **多智能体间如何共享上下文？**  
  - 嵌入上下文到提示中：AutoGPT、ChatDev。  
  - 交换结构化消息：Letta、MemOS。  
  - 使用共享内存间接通信：Letta、A-MEM。

- **跨系统共享上下文？**  
  - 使用适配器转换上下文：Langroid。  
  - 使用统一表示：Sharedrop。

- **AI如何主动推断用户需求？**  
  示例：ChatGPT、Claude。

---

### 基本设计原则

- **最小充分性原则（Minimal Sufficiency Principle）**：只收集完成任务所需的最小信息量，强调“够用”而非“海量”。

- **语义连续性原则（Semantic Continuity Principle）**：上下文的核心是保持语义的连贯，而非仅仅是数据的延续。

---

### 4.1 典型策略（Era 1.0 和 Era 2.0）

#### Era 1.0（早期阶段）

- **上下文收集**：主要依赖单一设备（如桌面电脑、早期手机），传感器有限（GPS、键盘事件、应用日志等）。

- **存储方式**：本地文件系统或简单数据库，临时状态常驻内存，系统关闭后丢弃。跨设备同步受限于网络条件。

#### Era 2.0（技术进步阶段）

- **上下文收集**：多设备分布式收集（手机、可穿戴设备、家庭传感器、云服务、API），支持多模态信号融合。

- **存储架构**：采用分层架构，根据数据使用频率选择存储方式：
  - 短期数据：内存缓存或边缘节点。
  - 中期数据：本地嵌入式数据库（如 SQLite、LevelDB）或安全存储。
  - 长期数据：云平台或远程数据库。

- **代码代理的长期记忆机制**：
  - 通过结构化笔记（如 Claude Code）定期将上下文写入外部存储。
  - 支持任务中断后恢复，适用于长时间任务（如 Pokémon 游戏策略管理）。
  - 可嵌入模型参数中实现长期适应性。

---

### 4.2 人类级上下文生态系统（Era 3.0）

- **上下文感知能力**：AI具备类人感知能力，包括触觉、嗅觉、味觉、语音情感分析等，能理解复杂社交语境。

- **个人数字记忆（Personal Digital Memory）**：
  - 存储不仅是数据保存，更是动态认知基础设施。
  - 支持上下文的自动组织、提炼、遗忘与回忆。

- **数据流动与安全**：
  - 数据在本地与云端安全流动。
  - 用户对敏感信息拥有完全控制权。
  - 实现人机共生的自然交互体验。

---

### 总结

本章系统地梳理了上下文工程在不同发展阶段的技术演进路径，从早期的本地单设备收集与存储，到中期的分布式多模态融合与结构化管理，再到后期具备类人感知能力的智能上下文生态系统。设计上强调“最小充分性”与“语义连续性”原则，技术上涵盖从数据采集、压缩、融合、存储到共享与推理的完整流程，并通过多个实际系统案例展示了不同策略的应用与效果。


## 5 Context Management


### 5.1 文本上下文处理

本节探讨如何处理原始文本上下文以获得最佳效果，重点分析了几种常见的设计方法及其优缺点。

#### 时间戳标记上下文
- **优点**：简单易维护，适用于聊天机器人和用户行为监控。
- **缺点**：仅保留时间顺序，缺乏语义结构，难以捕捉长距离依赖关系，数据积累后会带来存储和推理的扩展性问题。

#### 按功能和语义属性标记上下文
- **方法**：为每条信息打上如“目标”、“决策”、“行动”等功能标签，支持多维度分类（如优先级、来源等）。
- **优点**：便于理解和检索。
- **缺点**：结构较僵化，可能限制灵活推理和创造性整合。

#### 用问答对压缩上下文
- **方法**：将上下文转化为问答对形式，提升检索效率。
- **适用场景**：搜索引擎、FAQ系统。
- **缺点**：破坏原始语义流程，不适合需要整体理解的任务（如总结、推理）。

#### 用分层笔记压缩上下文
- **方法**：将信息组织成树状结构，从宏观到微观逐步细化。
- **优点**：结构清晰。
- **缺点**：未体现逻辑关系（如因果、证据与结论），也无法反映理解随时间演化的动态过程。

---

### 5.2 多模态上下文处理

随着LLM系统的发展，上下文已扩展到文本、图像、音频、视频、代码、传感器数据等多种模态。如何整合这些异构信息是关键挑战。

#### 映射多模态输入到可比较向量空间
- **方法**：各模态先通过独立编码器处理，再通过投影层映射到共享嵌入空间。
- **目的**：使语义相关的内容在空间中靠近，无关内容远离。
- **应用**：多模态检索、跨模态匹配。

#### 使用统一Transformer进行自注意力处理
- **方法**：将不同模态的token在共享空间中联合处理。
- **优点**：实现细粒度跨模态对齐，如文本短语与图像区域的对应。
- **对比**：优于传统浅层拼接方式。

#### 跨注意力机制实现模态间关注
- **方法**：一个模态作为查询（如文本），另一个作为键/值（如图像），通过注意力机制提取相关信息。
- **优点**：灵活、精准地实现跨模态检索。
- **局限**：传统设计需预设模态交互方式，缺乏人类大脑的灵活整合能力。

---

### 5.3 上下文组织

#### 5.3.1 分层记忆架构

AI系统需在不同时间尺度上管理信息。类比操作系统内存管理，LLM的上下文窗口相当于“RAM”，而长期记忆则类似“硬盘”。

- **核心思想**：将信息按时间相关性和重要性分层存储，优化响应速度与存储效率。
- **典型应用**：LeadResearcher系统在处理超长上下文时，将研究计划存入持久记忆，防止关键信息丢失。

##### 短期记忆定义：
- 选择时间相关性高的上下文，公式为：
  $$
  M_s = f_{\text{short}}\left(c \in C : w_{\text{temporal}}(c) > \theta_s\right)
  $$

##### 长期记忆定义：
- 选择重要性高但时间相关性低的信息，公式为：
  $$
  M_l = f_{\text{long}}\left(c \in C : w_{\text{importance}}(c) > \theta_l \land w_{\text{temporal}}(c) \leq \theta_s\right)
  $$

##### 记忆转移机制：
- 将短期记忆中重要或频繁访问的信息转移到长期记忆中，公式为：
  $$
  f_{\text{transfer}}: M_s \rightarrow M_l
  $$

#### 5.3.2 上下文隔离

##### 子代理（Subagent）
- **原理**：每个子代理拥有独立上下文窗口、系统提示和工具权限，避免上下文污染。
- **优势**：提高系统可靠性与可解释性，支持并行处理与反馈循环。
- **应用**：Claude Code子代理系统、LeadResearcher任务分解。

##### 轻量引用
- **方法**：将大量信息存储在外部，仅在上下文中保留引用。
- **示例**：HuggingFace CodeAgent的沙箱机制、基于模式的状态对象。
- **优点**：减少token消耗，同时保留完整信息访问能力。

---

### 5.4 上下文抽象

原始上下文（如对话、工具输出、文档）积累过快，需通过抽象机制将其转化为结构化、紧凑的知识表示。这一过程称为“自烘焙”（self-baking），是系统从记忆存储走向学习的关键。

#### 使用分层记忆架构
- **方法**：底层存储原始上下文，高层逐步抽象为更简洁表示。
- **优点**：支持上下文扩展，保留原始细节的可追溯性。
- **与短期/长期记忆的关系**：原始信息在短期记忆层，抽象信息在长期记忆层。

#### 添加自然语言摘要
- **方法**：在保留原始上下文的同时，定期生成自然语言摘要。
- **优点**：简单灵活，便于快速理解。
- **缺点**：缺乏结构，不利于深入推理。

#### 使用固定模式提取关键事实
- **方法**：将信息结构化，如实体图、事件记录、任务树。
- **优点**：支持更有效的检索与推理。
- **挑战**：多层结构易不一致，抽取器设计复杂。

#### 逐步压缩上下文为语义向量
- **方法**：将信息编码为语义向量，定期融合与抽象。
- **优点**：紧凑、灵活，适用于语义搜索。
- **缺点**：不可读，难以编辑与调试。


## 6 Context Usage


### 6.1 系统内上下文共享

现代大语言模型（LLM）应用通常由多个代理（agent）组成，每个代理负责部分推理任务。多代理系统的一个关键挑战是：**如何在代理之间共享上下文以实现协同行为**？常见的上下文共享方式包括：

- **将上下文嵌入提示中**：通过在提示中直接包含前序上下文，实现信息传递。例如 AutoGPT、ChatDev 等系统。
- **结构化消息交换**：代理之间使用固定格式的消息进行通信，如 Letta、MemOS。
- **共享内存间接通信**：代理通过读写共享内存空间进行协作，如 MemGPT、A-MEM。  
  - **黑板结构**：将信息按主题或任务组织，代理仅关注相关部分。
  - **图结构记忆**：如 TME 和 G-Memory，通过节点和边表示推理步骤及其依赖关系，提升多步推理的可解释性。

### 6.2 跨系统上下文共享

跨系统上下文共享是指不同平台、模型或应用之间交换信息。由于系统间格式、结构和逻辑不同，共享上下文面临解释性挑战。常见方法包括：

- **使用适配器转换上下文**：为每个系统间连接构建转换器，如 Zarabzadeh 等（2024）。
- **统一表示方式**：所有系统使用相同表示形式，简化集成。
  - **共享数据格式（如 JSON 或 API）**：如 Anderson（2025）。
  - **自然语言摘要**：便于人类和模型理解，如 Dobre 等（2025）。
  - **语义向量表示**：灵活但需模型解释，如 Raj（2025）。

每种方法各有优劣，选择取决于系统目标和通信需求。

### 6.3 上下文选择与理解

LLM 的性能受限于输入上下文的质量，而非仅仅是长度。因此，**如何选择最相关的上下文子集**成为关键问题。影响上下文选择的因素包括：

- **语义相关性**：通过向量相似度检索相关内容，如 RAG 系统。
- **逻辑依赖**：当前任务依赖的前序信息，如 MEM1 的依赖图。
- **时间与频率**：近期或高频访问的信息优先保留。
- **信息重叠**：过滤重复或冗余信息，如 Yun 等（2025）。
- **用户偏好与反馈**：通过交互学习用户习惯，如 Jin 等（2024）。

常见过滤策略包括：
- **语义检索**：基于向量相似度。
- **非语义检索**：如 Grep。
- **结构化检索**：利用知识图谱。
- **重排序**：提升检索准确性，如 Windsurf。

### 6.4 主动用户需求推断

当前上下文使用多为被动响应，但用户往往难以明确表达需求。为此，系统应具备**主动推断用户潜在需求**的能力：

- **学习用户偏好**：通过对话历史、文档、反馈等构建用户画像，如 Pan 等（2025）。
- **从相关问题中推断隐藏目标**：如用户连续提问 Python 装饰器和性能优化，可能反映其提升代码效率的目标，如 Anthropic（2025a）。
- **基于用户困难主动提供帮助**：识别用户卡顿行为，主动提供工具支持，如 Chen 等（2025）。

### 6.5 终身上下文的保存与更新

随着上下文积累为“终身记忆”，如何**长期保存、更新并保持一致性**成为挑战：

- **挑战一：存储瓶颈**：如何在资源限制下高效存储、压缩、检索大规模上下文，如 Xing 等（2025）。
- **挑战二：处理退化**：注意力机制在长上下文中失效，推理质量下降，如 Thai 等（2023）。
- **挑战三：系统不稳定**：错误传播、一致性冲突，如 Meng 等（2025）。
- **挑战四：评估困难**：缺乏对长期记忆推理的可解释性和验证机制，如 Zheng 等（2025）。

**未来方向**：构建一个**语义操作系统**，具备人类般的记忆管理能力，支持动态添加、修改、遗忘知识，并具备可解释性与长期推理能力。

### 6.6 新兴工程实践

#### KV 缓存
KV 缓存通过存储注意力状态（键和值）避免重复计算，提升效率。关键实践包括：
- 保持前缀提示稳定。
- 强制追加和确定性更新。
- 手动插入缓存检查点。
- 预加载缓存（prefetch）提高命中率。

#### 工具设计
- **描述清晰**：避免模糊或重叠描述，提升可靠性。
- **规模控制**：工具集过大影响性能，建议稳定工具列表并限制选择空间。

#### 上下文内容管理
- **保留错误上下文**：帮助模型学习纠正行为。
- **结构化扰动**：通过微调动作和观察格式打破重复模式，提升鲁棒性。

#### 多代理系统
- **明确任务分解**：主代理需清晰定义子任务目标、输出和边界。
- **任务复杂度适配**：简单任务单代理，复杂任务多代理。
- **搜索策略**：从广度探索到深度分析，结合“扩展思考模式”提升准确率。

#### 实用技巧
- **维护目标清单（todo.md）**：在长任务中通过自然语言重述目标，保持模型注意力聚焦。


## 7 Applications


本章介绍了上下文工程在不同领域的实际应用，包括命令行工具（CLI）、深度研究（Deep Research）和脑机接口（Brain-Computer Interfaces, BCI）。

---

### 7.1 命令行工具（CLI）

**重点内容：**

Google 的 *Gemini CLI* 是一个典型的上下文工程应用，通过一个名为 *GEMINI.md* 的 Markdown 文件来组织项目上下文。该文件可存在于用户主目录、项目根目录或子目录中，支持上下文的继承与隔离。

- **上下文收集**：CLI 在启动时自动加载静态信息（如系统提示、项目环境、GEMINI.md 文件），并在交互过程中逐步积累动态对话历史。
- **上下文管理**：文件系统作为轻量级数据库，支持通过 AI 生成摘要压缩上下文。摘要格式标准化，保留关键信息（如目标、知识、文件状态、计划等），确保一致性。
- **协作机制**：社区建议引入人工优化摘要，以支持多人协作管理上下文。

**总结**：Gemini CLI 通过结构化文件与摘要机制，实现了项目导向的上下文工程，适用于开发场景中的持续交互。

---

### 7.2 深度研究（Deep Research）

**重点内容：**

Tongyi DeepResearch 是一个用于解决复杂、知识密集型问题的代理系统，其核心挑战是处理极长的交互历史。

- **工作流程**：包括四步：搜索、提取、生成子问题、整合证据。该过程循环进行，直到形成完整的证据链。
- **上下文压缩机制**：为突破上下文窗口限制，系统定期调用专门的摘要模型，将历史压缩为“推理状态”（reasoning state），保留关键证据并指出缺失信息和下一步方向。
- **上下文生命周期**：从信息收集、积累、压缩抽象，到基于摘要的推理与复用，构建了可扩展的长周期研究能力。

**总结**：通过系统化的上下文压缩与管理，Tongyi DeepResearch 实现了对复杂问题的长期推理与研究能力，突破了传统对话代理的限制。

---

### 7.3 脑机接口（Brain-Computer Interfaces）

**重点内容：**

脑机接口（BCI）为上下文工程提供了新的数据采集方式，通过直接读取神经信号，拓展了上下文的维度和采集效率。

- **优势**：
  - 可采集注意力、情绪、认知负荷等内部状态信息；
  - 减少显式输入需求，实现更自然的上下文获取。
- **挑战**：当前技术对脑信号的理解仍较粗略，存在噪声和不稳定问题。

**总结**：BCI 代表了上下文工程的一个前沿方向，即从外部环境扩展到用户内部认知状态的采集与建模。

---

**总体总结：**

第7章展示了上下文工程在不同应用场景中的实践与创新。从命令行工具的结构化上下文管理，到深度研究中的长周期推理机制，再到脑机接口带来的新型上下文采集方式，体现了上下文工程在提升AI代理能力方面的多样性和前瞻性。


## 8 Challenges and Future Directions



本节总结了当前**情境工程**（context engineering）领域所面临的主要挑战，并展望了未来可能的研究方向。以下是各小节的要点总结：

---

### 情境收集仍受限且效率低下

当前大多数智能系统仍依赖用户**显式输入**来获取情境信息，这种方式既繁琐又低效。此外，用户有时难以清晰表达自己的意图，导致关键情境信息缺失。未来的发展方向包括：

- **多模态、更自然的情境收集方式**，如脑机接口（BCI），可以更高效地捕捉用户状态和意图；
- 模型应具备更强的**用户意图推理能力**，以弥补情境缺失。

> 重点：需要从依赖用户输入转向更智能、自动化的信息获取方式。

---

### 大规模情境的存储与管理

随着交互的积累，情境数据的**规模和复杂度迅速增长**，如何高效地存储、组织、检索这些情境成为关键问题。若设计不当，大规模情境反而会成为负担，影响后续任务的执行效率。

> 重点：需要构建**可扩展性强、检索效率高**的情境管理系统。

---

### 模型对情境的理解能力有限

目前系统在情境理解方面远不如人类，尤其在处理**复杂逻辑**和**图像关系信息**时表现不佳。这导致大量可用情境未被充分利用。

未来应加强模型在以下方面的能力：

- 语义推理
- 逻辑解释
- 多模态对齐

> 重点：提升模型理解能力，减少对人工情境工程的依赖。

---

### 长文本情境处理的性能瓶颈

长文本处理仍是核心挑战。基于Transformer的模型因**复杂度呈二次增长**，在处理长上下文时效率低下。虽然一些新架构（如Mamba、LongMamba、LOCOST）提升了效率，但在长上下文理解上仍存在不足，尤其是在：

- 输入长度远超训练长度时；
- 逻辑或关系依赖跨越整个上下文时。

> 重点：需要开发**既能高效处理长上下文，又能准确理解其内容**的新架构。

---

### 相关情境的筛选问题

并非所有情境都对当前任务有用。尽管现有系统已采用相关性评估和过滤机制，但效果有限，常遗漏关键信息或保留冗余噪声。

未来研究方向包括：

- 开发**更精准、自适应的情境筛选策略**；
- 动态调整保留、丢弃或强调的内容，确保情境与任务目标高度对齐。

> 重点：情境筛选机制需更智能、动态，提升任务相关性。

---

### 数字存在（Digital Presence）

引用马克思关于“人的本质是社会关系的总和”的观点，指出在情境为中心的AI时代，个体越来越多地通过**数字情境**（如对话、决策、互动记录）被定义。

这些数字情境可以在个体离世后继续存在、演化，并通过AI系统与世界互动，形成一种**知识、记忆和身份的延续**。

> 重点：情境不仅是信息，更是人类存在的数字映射，具有长期价值和意义。

---

### 总结

本节系统梳理了情境工程在**收集、管理、理解、处理与筛选**等方面的挑战，并指出未来应从**技术架构、模型能力、系统设计**等多方面进行突破，最终实现更智能、自主、高效的情境驱动型AI系统。


## 9 Conclusion

本章节总结了全文关于**上下文工程**（context engineering）的探讨，指出它并非大语言模型（LLM）时代突然出现的概念，而是一个随着机器智能逐步发展而演化的长期学科。

文章回顾了上下文工程的历史发展阶段，并概述了其设计实践中的关键考虑因素。核心挑战在于：**在不同熵值（不确定性）水平下，如何有效连接人类意图与机器理解**。

作者提出，未来的发展趋势是：**人类将逐渐减少对上下文的显式管理**，转而由日益智能的机器承担更多解释、推理甚至构建上下文的责任。

展望未来，当机器理解能力接近甚至超越人类认知时，AI系统可能获得一种对人类意图的“上帝视角”。届时，人工智能不仅能理解我们，还能**帮助我们更清晰地认识自己、拓展自我认知的边界**。这是上下文工程发展可能带来的深远影响。

