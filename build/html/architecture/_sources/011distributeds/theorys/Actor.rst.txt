.. _Actor:

并发模型-Actor
##############


Actor模型，又叫参与者模型::

    其”一切皆参与者(actor)”的理念与面向对象编程的“一切皆是对象”类似
    但是面向对象编程中对象的交互通常是顺序执行的(占用的是调用方的时间片，是否并发由调用方决定)
    而Actor模型中actor的交互是并行执行的(不占用调用方的时间片，是否并发由自己决定)。

    在Actor模型中，actor执行体是第一类对象，每个actor都有自己的ID(类比人的身份证)，可以被传递。
    actor的交互通过发送消息来完成，每个actor都有一个通信信箱(mailbox)，用于保存已经收到但尚未被处理的消息。
    actorA要向actorB发消息，只需持有actorB ID，发送的消息将被立即Push到actorB的消息信箱尾部，然后返回。
    因此Actor的通信原语是异步的。

从actor自身来说，它的行为模式可简化为::

    发送消息给其它的actor
    接收并处理消息，更新自己的状态
    创建其它的actor
    
一个好的Actor模型实现的设计目标::

    调度器: 实现actor的公平调度
    容错性: 具备良好的容错性和完善错误处理机制
    扩展性: 屏蔽actor通信细节，统一本地actor和远程actor的通信方式，进而提供分布式支持
    热更新: (还没弄清楚热更新和Actor模型，函数式范式的关联性)

在Actor模型上，Erlang已经耕耘三十余载，以上提到的各个方面都有非常出色的表现，其OTP整合了在Actor模型上的最佳实践，是Actor模型的标杆。


CSP vs Actor
============

相同的宗旨::

    ”不要通过共享内存来通信，而应该通过通信来共享内存”

    两者都有独立的，并发执行的通信实体

不同::

    Actor第一类对象为执行实体(actor)，CSP第一类对象为通信介质(channel)
    Actor中实体和通信介质是紧耦合的，一个Actor持有一个Mailbox，
        而CSP中process和channel是解耦的，没有从属关系。
        从这一层来说，CSP更加灵活

    Actor模型中actor是主体，mailbox是匿名的，CSP模型中channel是主体，process是匿名的。
    从这一层来说，由于Actor不关心通信介质，底层通信对应用层是透明的。因此在分布式和容错方面更有优势

















