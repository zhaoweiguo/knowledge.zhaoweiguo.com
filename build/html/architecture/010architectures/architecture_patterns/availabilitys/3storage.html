

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>


<!-- start added 2025-04-14   增加对markdown中公式的支持 -->
<script>
window.MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
    },
    options: {
        ignoreHtmlClass: "tex2jax_ignore|mathjax_ignore",
        processHtmlClass: "tex2jax_process|mathjax_process|math|output_area"
    }
};
</script>
<script defer="defer" src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- end added 2025-04-14   增加对markdown中公式的支持 -->


  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>存储高可用架构 &mdash; 新溪-gordon V2025.07 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="计算高可用架构" href="4computing.html" />
    <link rel="prev" title="FMEA" href="2FMEA.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>
  <script src="../../../_static/js/jquery.min.js"></script>


<!-- 评论插件 gittalk start -->
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> -->
<!-- 评论插件 gittalk end -->


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> 新溪-gordon
          

          
          </a>

          
            
            
              <div class="version">
                V2025.07
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">关键知识</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../010architecture.html">010架构设计</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../normal.html">常用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../normals/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../normals/%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1.html">互联网业务</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../normals/tmp.html">临时</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../normals/other.html">其他架构设计</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/cqrs.html">CQRS </a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/crud.html">CRUD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/ddd.html">领域驱动设计</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/api.html">api设计</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/SSO.html">单点登录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/event_driver.html">事件驱动架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/network_agent.html">网络代理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/message_bus.html">消息总线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/mvc_mvp_mvvm.html">MVC MVP MVVM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../normals/others/other.html">其他</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../history.html">架构的历史</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../historys/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../historys/01origin_distributed_sys.html">原始分布式时代</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../historys/02monolithic_sys.html">单体系统时代</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../historys/03soa_sys.html">SOA架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../historys/04microService.html">微服务架构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../historys/04microServices/normal.html">常用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../historys/04microServices/9feature.html">微服务的九个核心的业务与技术特征</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../historys/04microServices/ServiceMesh.html">ServiceMesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../historys/04microServices/collect.html">微服务架构</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../historys/05cloudnative.html">云原生时代——后微服务时代</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../historys/05cloudnatives/collect1.html">云原生</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../historys/05cloudnatives/collect2.html">收集2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../historys/05cloudnatives/12Factor.html">云原生应用的12要素</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../historys/05cloudnatives/distribute_architecture.html">从分布式架构到云原生架构</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../historys/06serverless.html">无服务时代</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../historys/06serverless/collect1.html">Serverless</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../architecture_design.html">软件架构设计</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../architecture_designs/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../architecture_designs/history_design.html">架构设计的历史</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../architecture_designs/purpose.html">架构设计目的</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/1performance.html">复杂度来源-高性能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/2availability.html">复杂度来源-高可用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/3expandability.html">复杂度来源-可扩展性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/4lowcost.html">复杂度来源-低成本</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/5security.html">复杂度来源-安全</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/6scalability.html">复杂度来源-规模</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/purposes/7other.html">其他</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../architecture_designs/principle.html">架构设计原则</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../architecture_designs/process.html">架构设计流程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/process/1recognize.html">识别复杂度</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/process/2alternative.html">设计备选方案</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/process/3assess.html">评估&amp;选择备选方案</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../architecture_designs/process/4detailed.html">详细方案设计</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="../../architecture_pattern.html">架构模式</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../performance.html">高性能架构模式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../performances/normal.html">常用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/1read-write-seperate.html">读写分离</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/2split-db-table.html">分库分表</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/3NoSQL.html">高性能 NoSQL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/4cache.html">高性能缓存架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/5PPC-TPC.html">单服务器高性能模式: PPC&amp;TPC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/6Reactor-Proactor.html">单服务器高性能模式: Reactor&amp;Proactor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../performances/7slb.html">高性能负载均衡: 分类&amp;架构&amp;算法</a></li>
</ul>
</li>
<li class="toctree-l3 current"><a class="reference internal" href="../availability.html">高可用架构模式</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="normal.html">常用</a></li>
<li class="toctree-l4"><a class="reference internal" href="1CAP.html">CAP理论</a></li>
<li class="toctree-l4"><a class="reference internal" href="2FMEA.html">FMEA</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">存储高可用架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="4computing.html">计算高可用架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="5different-live.html">异地多活</a></li>
<li class="toctree-l4"><a class="reference internal" href="6api-failure.html">接口级故障&amp;应对</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../expandability.html">可扩展架构模式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../expandabilitys/normal.html">常用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../expandabilitys/1basic-ideas-and-pattern.html">可扩展架构的基本思想和模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../expandabilitys/2hierarchical.html">传统可扩展架构-分层架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../expandabilitys/3soa.html">传统可扩展架构-SOA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../expandabilitys/4microservice.html">微服务架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../expandabilitys/5microkernel.html">微内核架构</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../communication_pattern.html">通信模式communication patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../communication_patterns/normal.html">通用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../communication_patterns/SAP.html">SAP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../communication_patterns/theory.html">理论</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../evolution.html">架构演进/重构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../evolutions/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../evolutions/be-microservice.html">对现有系统做微服务化改造</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../evolutions/evolution-graph.html">演进架构图</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../graph.html">架构图</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../graphs/normal.html">常用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../graphs/normals/normal.html">常用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../graphs/normals/color.html">颜色</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../graphs/normals/other.html">其他</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../graphs/business.html">业务架构图</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../graphs/c4-model.html">软件架构——C4模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../graphs/%E6%9E%B6%E6%9E%84%E5%9B%BE%E6%8A%80%E5%B7%A7.html">架构图技巧</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../EA.html">EA企业级架构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../EAs/TOGAF.html">TOGAF</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../EAs/Zachman.html">Zachman扎克曼框架</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../011distributed.html">011分布式系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../011distributeds/normal.html">常用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/normals/normal.html">分布式系统</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/normals/concept.html">并发</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/normals/tmp.html">临时</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../011distributeds/theory.html">并发相关理论</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/CAP.html">并发相关-CAP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/PACELC.html">PACELC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/FLP.html">并发相关-FLP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/DLS.html">DLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/CSP.html">并发模型-CSP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/CAS.html">CAS 机制</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/Actor.html">并发模型-Actor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/Gossip.html">Gossip协议</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/BASE.html">BASE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/ACID.html">ACID原则</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/UUID.html">UUID</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/theorys/consistent_hash.html">一致性hash</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../011distributeds/transaction.html">事务</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/transactions/normal.html">通用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/transactions/local.html">本地事务</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/transactions/global.html">全局事务(Global Transactions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/transactions/share.html">共享事务(Share Transactions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/transactions/distribute.html">分布式事务</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../011distributeds/transactions/distributes/reliable_event_queue.html">可靠事件队列</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../011distributeds/transactions/distributes/SAGA.html">SAGA 事务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../011distributeds/transactions/distributes/TCC.html">TCC 事务</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../011distributeds/consensus.html">分布式共识</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/consensus/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/consensus/Paxos.html">Paxos算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/consensus/zab.html">zab协议</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../011distributeds/consensus/Raft.html">The Raft Consensus Algorithm </a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../012SoftEngineering.html">012软件工程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../012SoftEngineerings/normal.html">常用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/normals/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/normals/methodology.html">编程方法论</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/normals/code-quality.html">代码质量</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/normals/complexity.html">复杂度</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../012SoftEngineerings/Programming-Spec.html">编程规范</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../012SoftEngineerings/Refactor.html">重构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/normal.html">通用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/5W2H.html">5W2H 分析法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-unit.html">重构手段-单元测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-unit.html#id3">定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-unit.html#id4">作用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-unit.html#id5">如何编写单元测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-unit.html#id6">为何难落地执行</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-unit.html#anti-patterns">影响可测试性的 Anti-Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/approach-decoupling.html">重构手段-解耦</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../012SoftEngineerings/Refactors/code-standard.html">改善代码质量的编程规范</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../012SoftEngineerings/document.html">设计文档</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../021microservice.html">021微服务架构</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../021microservices/normal.html">常用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../021microservices/discovery.html">服务注册&amp;发现</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../021microservices/api_gateway.html">API网关</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../021microservices/contract.html">对比</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../021microservices/tmp.html">临时</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../022middle-platform.html">022中台</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../031dataanalysis.html">031数据分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../031dataanalysis/normal.html">常用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../031dataanalysis/data.html">数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../031dataanalysis/tmp.html">临时</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../041governance.html">041服务治理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../041governances/normal.html">常用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../041governances/normals/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../041governances/normals/technical-debt.html">技术债</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../041governances/normals/anti-fragile.html">反脆弱</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../041governances/normals/code-review.html">Code Review</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../041governances/service_protection.html">服务保护</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../051compiler.html">051编译原理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/normal.html">常用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/tool.html">工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html">汇编语言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90.html">词法分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.html">词法分析, 语法分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90.html">语义分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/LLVM.html">LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/IR.html">编译期后端技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../051compilers/other.html">其他</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../052composition-principle.html">052 计算机组成原理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../052composition-principles/CPU%20%E5%8E%82%E5%95%86.html">CPU 厂商</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../052composition-principles/CPU%20Arch.html">CPU 架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../052composition-principles/Arm.html">Arm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../052composition-principles/X86.html">X86</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../052composition-principles/API.html">API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../053os.html">053操作系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../053os/normal.html">常用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../053os/signal.html">signal信号</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../053os/other.html">其他</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../054algorithm.html">054算法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/normal.html">常用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/algorithm.html">经典算法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/algorithms/normal.html">常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/algorithms/nlp.html">NLP相关算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/algorithms/encrypt.html">加密相关算法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/tree.html">树结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/b-tree.html">b-树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/b%2Btree.html">b+树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/lsm_tree.html">LSM树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/balanced_binary_tree.html">平衡二叉树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/red_black_tree.html">红黑树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/trie-tree.html">Trie 树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../054algorithms/trees/merkle-tree.html">Merkle 树</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/example.html">实例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/website.html">网站</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/iq.html">智力题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/graph_theory.html">图论</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../054algorithms/other.html">其他算法</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">新溪-gordon</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../010architecture.html">010架构设计</a> &raquo;</li>
        
          <li><a href="../../architecture_pattern.html">架构模式</a> &raquo;</li>
        
          <li><a href="../availability.html">高可用架构模式</a> &raquo;</li>
        
      <li>存储高可用架构</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/010architectures/architecture_patterns/availabilitys/3storage.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            <nav id="local-table-of-contents" role="navigation" aria-labelledby="local-table-of-contents-title">
              <h4 id="local-table-of-contents-title">On This Page</h4>
              <ul>
<li><a class="reference internal" href="#">存储高可用架构</a><ul>
<li><a class="reference internal" href="#id3">双机高可用架构</a><ul>
<li><a class="reference internal" href="#id4">主备复制</a></li>
<li><a class="reference internal" href="#id5">主从复制</a></li>
<li><a class="reference internal" href="#id6">双机切换</a><ul>
<li><a class="reference internal" href="#id7">设计关键</a></li>
<li><a class="reference internal" href="#id8">常见架构</a></li>
<li><a class="reference internal" href="#id9">互连式架构</a></li>
<li><a class="reference internal" href="#id10">中介式架构</a></li>
<li><a class="reference internal" href="#id11">模拟式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">主主复制</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">数据集群</a><ul>
<li><a class="reference internal" href="#id14">1. 数据集中集群</a></li>
<li><a class="reference internal" href="#id15">2. 数据分散集群</a></li>
<li><a class="reference internal" href="#id17">两种集群对比</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">数据分区</a><ul>
<li><a class="reference internal" href="#id19">集中式</a></li>
<li><a class="reference internal" href="#id20">互备式</a></li>
<li><a class="reference internal" href="#id21">独立式</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </nav>
  <table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference external" href="/index.html">主页</a></p></td>
<td><p><a class="reference internal" href="../../../genindex.html"><span class="std std-ref">索引</span></a></p></td>
<td><p><a class="reference internal" href="../../../py-modindex.html"><span class="std std-ref">模块索引</span></a></p></td>
<td><p><a class="reference internal" href="../../../search.html"><span class="std std-ref">搜索页面</span></a></p></td>
</tr>
</tbody>
</table>
<section id="id2">
<h1>存储高可用架构<a class="headerlink" href="#id2" title="此标题的永久链接">¶</a></h1>
<p>一个高可用存储方案设计角度:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数据如何复制？
各个节点的职责是什么？
如何应对复制延迟？
如何应对复制中断？
</pre></div>
</div>
<p>常见的高可用存储架构有:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">主备</span>
<span class="mf">2.</span> <span class="n">主从</span>
<span class="mf">3.</span> <span class="n">主主</span>
<span class="mf">4.</span> <span class="n">集群</span>
<span class="mf">5.</span> <span class="n">分区</span>
</pre></div>
</div>
<section id="id3">
<h2>双机高可用架构<a class="headerlink" href="#id3" title="此标题的永久链接">¶</a></h2>
<p>常见的双机高可用架构:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">主备</span>
<span class="mf">2.</span> <span class="n">主从</span>
<span class="mf">3.</span> <span class="n">主备</span><span class="o">/</span><span class="n">主从切换</span>
<span class="mf">4.</span> <span class="n">主主</span>
</pre></div>
</div>
<section id="id4">
<h3>主备复制<a class="headerlink" href="#id4" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>主备复制是最常见也是最简单的一种存储高可用方案，主备架构中的 “备机” 主要还是起到一个备份作用，并不承担实际的业务读写操作，如果要把备机改为主机，需要人工操作。几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。</p>
</div>
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage1.webp" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage1.webp" />
<p>优点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>主要是就是『简单』
对于客户端来说，不需要感知备机的存在
    即使灾难恢复后，原来的备机被人工修改为主机后，
    对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。
对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。
</pre></div>
</div>
<p>缺点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。
故障后需要人工干预，无法自动恢复。
    人工处理的效率是很低的，故障时间会很长
    人工在执行恢复操作的过程易出错，因为这类操作不常见，实际操作可能遇到各种意想不到的问题。
</pre></div>
</div>
</section>
<section id="id5">
<h3>主从复制<a class="headerlink" href="#id5" title="此标题的永久链接">¶</a></h3>
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage2.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage2.png" />
<p>与主备复制相比，优点有:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>主从复制在主机故障时，读操作相关的业务可以继续运行
主从复制架构的从机提供读操作，发挥了硬件的性能
</pre></div>
</div>
<p>缺点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高
主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题
故障时需要人工干预
</pre></div>
</div>
</section>
<section id="id6">
<h3>双机切换<a class="headerlink" href="#id6" title="此标题的永久链接">¶</a></h3>
<p>主备复制和主从复制方案存在两个共性的问题:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>主机故障后，无法进行写操作。
如果主机无法恢复，需要人工指定新的主机角色。
</pre></div>
</div>
<section id="id7">
<h4>设计关键<a class="headerlink" href="#id7" title="此标题的永久链接">¶</a></h4>
<ol class="arabic">
<li><p>主备间状态判断:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>a. 主要包括两方面：状态传递的渠道，以及状态检测的内容。
b. 状态传递的渠道：是相互间互相连接，还是第三方仲裁？
c. 状态检测的内容：例如机器是否掉电、进程是否存在、响应是否缓慢等。
</pre></div>
</div>
</li>
<li><p>切换决策:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>主要包括几方面：切换时机、切换策略、自动程度。
a. 切换时机
    什么情况下备机应该升级为主机？
    是机器掉电后备机才升级，还是主机上的进程不存在就升级，
    还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。
b. 切换策略
    原来的主机故障恢复后
    要再次切换，确保原来的主机继续做主机，
    还是原来的主机故障恢复后自动成为新的备机？
c. 自动程度
    切换是完全自动的，还是半自动的？
    例如，系统判断当前需要切换，但需要人工做最终的确认操作（例如，单击一下 “切换” 按钮）。
</pre></div>
</div>
</li>
<li><p>数据冲突解决:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。
以上设计点并没有放之四海而皆准的答案，不同的业务要求不一样，
  所以切换方案比复制方案不只是多了一个切换功能那么简单，而是复杂度上升了一个量级。
形象点来说，如果复制方案的代码是 1000 行，那么切换方案的代码可能就是 10000 行，
  多出来的那 9000 行就是用于实现上面我所讲的 3 个设计点的。
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id8">
<h4>常见架构<a class="headerlink" href="#id8" title="此标题的永久链接">¶</a></h4>
<p>根据状态传递渠道的不同，常见的主备切换架构有三种形式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>互连式、中介式和模拟式。
</pre></div>
</div>
</section>
<section id="id9">
<h4>互连式架构<a class="headerlink" href="#id9" title="此标题的永久链接">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>故名思议，互连式就是指主备机直接建立状态传递的渠道。</p>
</div>
<figure class="align-default" id="id23">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage3.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage3.png" />
<figcaption>
<p><span class="caption-text">架构图请注意与主备复制架构对比</span><a class="headerlink" href="#id23" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>“状态传递” 的通道，这个通道就是用来传递状态信息的。这个通道的具体实现可以有很多方式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>可以是网络连接（例如，各开一个端口），也可以是非网络连接（用串口线连接）。
可以是主机发送状态给备机，也可以是备机到主机来获取状态信息。
可以和数据复制通道共用，也可以独立一条通道。
状态传递通道可以是一条，也可以是多条，还可以是不同类型的通道混合（例如，网络 + 串口）。
</pre></div>
</div>
<p>客户端这里也会有一些相应的改变，常见的方式有:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。
    例如虚拟 IP，主机需要绑定这个虚拟的 IP。
2. 客户端同时记录主备机的地址，哪个能访问就访问哪个；
    备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是 “备机不对外提供服务”。
</pre></div>
</div>
<p>主要的缺点在于:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 如果状态传递的通道本身有故障
    那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。
2. 虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已
    不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，
    因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。
</pre></div>
</div>
</section>
<section id="id10">
<h4>中介式架构<a class="headerlink" href="#id10" title="此标题的永久链接">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息，其架构图如下：</p>
</div>
<figure class="align-default" id="id24">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage4.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage4.png" />
<figcaption>
<p><span class="caption-text">主机和备机不再通过互联通道传递状态信息，而是都将状态上报给中介这一角色</span><a class="headerlink" href="#id24" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>优点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">中介式架构在状态传递和决策上更加简单明了</span>
<span class="mf">1.</span> <span class="n">连接管理更简单</span>
<span class="mf">2.</span> <span class="n">状态决策更简单</span>
</pre></div>
</div>
<p>缺点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>关键代价就在于如何实现中介本身的高可用。
如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了

这就陷入了一个递归的陷阱
</pre></div>
</div>
<figure class="align-default" id="id25">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage5-mongo.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage5-mongo.png" />
<figcaption>
<p><span class="caption-text">MongoDB 的 Replica Set 采取的就是这种方式</span><a class="headerlink" href="#id25" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>开源方案已经有比较成熟的中介式解决方案，例如 ZooKeeper 和 Keepalived。</p>
</div>
</section>
<section id="id11">
<h4>模拟式<a class="headerlink" href="#id11" title="此标题的永久链接">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。</p>
</div>
<figure class="align-default" id="id26">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage6.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage6.png" />
<figcaption>
<p><span class="caption-text">互连式切换架构: 主备机之间只有数据复制通道，而没有状态传递通道，备机通过模拟的读写操作来探测主机的状态，然后根据读写操作的响应情况来进行状态决策。</span><a class="headerlink" href="#id26" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>与互连式切换相比，优点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现更加简单，因为省去了状态传递通道的建立和管理工作。
</pre></div>
</div>
<p>缺点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>因为模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等）
没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I/O 负载、吞吐量、响应时间等）
基于有限的状态来做状态决策，可能出现偏差
</pre></div>
</div>
</section>
</section>
<section id="id12">
<h3>主主复制<a class="headerlink" href="#id12" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作</p>
</div>
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage7-master-master.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage7-master-master.png" />
<p>相比主备切换架构，主主复制架构具有如下特点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>两台都是主机，不存在切换的概念。
客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。
</pre></div>
</div>
<p>其独特的复杂性，具体表现在:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等</p>
</div>
</section>
</section>
<section id="id13">
<h2>数据集群<a class="headerlink" href="#id13" title="此标题的永久链接">¶</a></h2>
<p>根据集群中机器承担的不同角色来划分，集群可以分为两类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">数据集中集群</span>
<span class="n">数据分散集群</span>
</pre></div>
</div>
<section id="id14">
<h3>1. 数据集中集群<a class="headerlink" href="#id14" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>数据集中集群与主备、主从这类架构相似，我们也可以称数据集中集群为 1 主多备或者 1 主多从。虽然架构上是类似的，但由于集群里面的服务器数量更多，导致复杂度整体更高一些</p>
</div>
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage8.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage8.png" />
<p>复杂度整体更高一些，具体体现在:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 主机如何将数据复制给备机
    主备和主从架构中，只有一条复制通道，而数据集中集群架构中，存在多条复制通道。
    多条复制通道:
      首先: 会增大主机复制的压力，某些场景下需考虑如何降低主机复制压力，或者降低主机复制给正常读写带来的压力
      其次: 多条复制通道可能导致多个备机之间数据不一致，某些场景下需对备机之间的数据一致性进行检查和修正
2. 备机如何检测主机状态
    主备和主从架构中，只有一台备机需要进行主机状态判断。
    在数据集中集群架构中，多台备机都需要对主机状态进行判断，
    而不同的备机判断的结果可能是不同的，如何处理不同备机对主机状态的不同判断，是一个复杂的问题。
3. 主机故障后，如何决定新的主机
    主从架构中，如果主机故障，将备机升级为主机即可；
    而在数据集中集群架构中，有多台备机都可以升级为主机，但实际上只能允许一台备机升级为主机，
    那么究竟选择哪一台备机作为新的主机，备机之间如何协调，这也是一个复杂的问题。

    目前开源的数据集中集群以 ZooKeeper 为典型，
    ZooKeeper 通过 ZAB 算法来解决上述提到的几个问题，但 ZAB 算法的复杂度是很高的。
</pre></div>
</div>
</section>
<section id="id15">
<h3>2. 数据分散集群<a class="headerlink" href="#id15" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>数据分散集群指多个服务器组成一个集群，每台服务器都会负责存储一部分数据；同时，为了提升硬件利用率，每台服务器又会备份一部分数据。</p>
</div>
<p>数据分散集群的复杂点在于如何将数据分配到不同的服务器上，算法需要考虑这些设计点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 均衡性
算法需要保证服务器上的数据分区基本是均衡的，不能存在某台服务器上的分区数量是另外一台服务器的几倍的情况
2. 容错性
当出现部分服务器故障时，算法需要将原来分配给故障服务器的数据分区分配给其他服务器
3. 可伸缩性
当集群容量不够，扩充新的服务器后，算法能够自动将部分数据分区迁移到新服务器，并保证扩容后所有服务器的均衡性
</pre></div>
</div>
<figure class="align-default" id="id27">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage9-hadoop.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage9-hadoop.png" />
<figcaption>
<p><span class="caption-text">Hadoop 的实现就是独立的服务器负责数据分区的分配，这台服务器叫作 Namenode。</span><a class="headerlink" href="#id27" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>下面是 Hadoop 官方的解释，能够说明集中式数据分区管理的基本方式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. HDFS 采用 master/slave 架构。
    一个 HDFS 集群由一个 Namenode 和一定数目的 Datanodes 组成。
2. Namenode 是一个中心服务器，负责管理文件系统的名字空间（namespace），以及客户端对文件的访问。
3. Datanode 在集群中一般是一个节点一个，负责管理它所在节点上的存储。
    HDFS 暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。
    从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组 Datanode 上。
4. Namenode 执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。
    它也负责确定数据块到具体 Datanode 节点的映射。
    Datanode 负责处理文件系统客户端的读写请求。
    在 Namenode 的统一调度下进行数据块的创建、删除和复制操作。
</pre></div>
</div>
<figure class="align-default" id="id28">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage9-es.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage9-es.png" />
<figcaption>
<p><span class="caption-text">与 Hadoop 不同的是，Elasticsearch 集群通过选举一台服务器来做数据分区的分配，叫作 master node</span><a class="headerlink" href="#id28" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>其中 master 节点的职责 <a class="reference external" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html">如下</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">master</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">lightweight</span> <span class="n">cluster</span><span class="o">-</span><span class="n">wide</span> <span class="n">actions</span>
  <span class="n">such</span> <span class="k">as</span> <span class="n">creating</span> <span class="ow">or</span> <span class="n">deleting</span> <span class="n">an</span> <span class="n">index</span><span class="p">,</span> <span class="n">tracking</span> <span class="n">which</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">cluster</span><span class="p">,</span>
  <span class="ow">and</span> <span class="n">deciding</span> <span class="n">which</span> <span class="n">shards</span> <span class="n">to</span> <span class="n">allocate</span> <span class="n">to</span> <span class="n">which</span> <span class="n">nodes</span><span class="o">.</span>
<span class="n">It</span> <span class="ow">is</span> <span class="n">important</span> <span class="k">for</span> <span class="n">cluster</span> <span class="n">health</span> <span class="n">to</span> <span class="n">have</span> <span class="n">a</span> <span class="n">stable</span> <span class="n">master</span> <span class="n">node</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="id17">
<h3>两种集群对比<a class="headerlink" href="#id17" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>数据分散集群和数据集中集群的不同点在于，数据分散集群中的每台服务器都可以处理读写请求，因此不存在数据集中集群中负责写的主机那样的角色。但在数据分散集群中，必须有一个角色来负责执行数据分配算法，这个角色可以是独立的一台服务器，也可以是集群自己选举出的一台服务器。如果是集群服务器选举出来一台机器承担数据分区分配的职责，则这台服务器一般也会叫作主机，但我们需要知道这里的 “主机” 和数据集中集群中的 “主机”，其职责是有差异的。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>数据集中集群架构中，客户端只能将数据写到主机；数据分散集群架构中，客户端可以向任意服务器中读写数据。正是因为这个关键的差异，决定了两种集群的应用场景不同。一般来说，数据集中集群适合数据量不大，集群机器数量不多的场景。例如，ZooKeeper 集群，一般推荐 5 台机器左右，数据量是单台服务器就能够支撑；而数据分散集群，由于其良好的可伸缩性，适合业务数据量巨大、集群机器数量庞大的业务场景。例如，Hadoop 集群、HBase 集群，大规模的集群可以达到上百台甚至上千台服务器。</p>
</div>
</section>
</section>
<section id="id18">
<h2>数据分区<a class="headerlink" href="#id18" title="此标题的永久链接">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>前面我们讨论的存储高可用架构都是基于硬件故障的场景去考虑和设计的，主要考虑当部分硬件可能损坏的情况下系统应该如何处理，但如出现一个城市甚至一个地区的所有基础设施瘫痪的情况。基于硬件故障而设计的高可用架构不再适用，我们需要基于地理级别的故障来设计高可用架构，这就是数据分区架构产生的背景。</p>
</div>
<p>设计一个良好的数据分区架构，需要从多方面去考虑:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 数据量
    数据量的大小直接决定了分区的规则复杂度。

    例如，使用 MySQL 来存储数据，假设一台 MySQL 存储能力是 500GB，那么
      2TB 的数据就至少需要 4 台 MySQL 服务器；
      而如果数据是 200TB，并不是增加到 800 台的 MySQL 服务器那么简单。
    管理 800 台服务器，复杂度会发生本质的变化，具体表现为:
      a. 800 台服务器里面可能每周都有一两台服务器故障，
          从 800 台里面定位出 2 台服务器故障，很多情况下并不是一件容易的事情，运维复杂度高。
      b. 增加新的服务器，分区相关的配置甚至规则需要修改
          而每次修改理论上都有可能影响已有的 800 台服务器的运行。
      c. 如此大量的数据，如果在地理位置上全部集中于某个城市，风险很大
          遇到了水灾、大停电这种灾难性的故障时，数据可能全部丢失，因此分区规则需要考虑地理容灾
    因此，数据量越大，分区规则会越复杂，考虑的情况也越多。

2. 分区规则
    地理位置有近有远，因此可以得到不同的分区规则，包括洲际分区、国家分区、城市分区。

    具体采取哪种或者哪几种规则，需要综合考虑业务范围、成本等因素:
    a. 洲际分区:
        由于跨洲通讯的网络延迟已经大到不适合提供在线服务了，因此洲际间的数据中心可以不互通或者仅仅作为备份；
    b. 国家分区:
        不同国家有不同语言、法律、业务等，国家间的分区一般也仅作为备份；
    c. 城市分区:
        网络延迟较低，业务相似，分区同时对外提供服务，可以满足业务异地多活之类的需求。

3. 复制规则
    数据分区指将数据分散在多个地区，在灾难下，虽然部分数据受影响，但整体并没有全部被影响，本身就相当于一个高可用方案了
    但仅仅做到这点还不够，因为每个分区本身的数据量虽然只是整体数据的一部分，但还是很大，
        这部分数据如果损坏或者丢失，损失同样难以接受。
    因此即使是分区架构，同样需要考虑复制方案。
</pre></div>
</div>
<p>常见的分区复制规则有三种:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">集中式</span>
<span class="mf">2.</span> <span class="n">互备式</span>
<span class="mf">3.</span> <span class="n">独立式</span>
</pre></div>
</div>
<section id="id19">
<h3>集中式<a class="headerlink" href="#id19" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>集中式备份指存在一个总的备份中心，所有的分区都将数据备份到备份中心</p>
</div>
<figure class="align-default">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage10-1.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage10-1.png" />
</figure>
<p>集中式备份架构的优缺点是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 设计简单
    各分区之间并无直接联系，可以做到互不影响。
2. 扩展容易
    如果要增加第四个分区（例如，武汉分区），只需要将武汉分区的数据复制到西安备份中心即可，其他分区不受影响。
3. 成本较高
    需要建设一个独立的备份中心。
</pre></div>
</div>
</section>
<section id="id20">
<h3>互备式<a class="headerlink" href="#id20" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>互备式备份指每个分区备份另外一个分区的数据</p>
</div>
<figure class="align-default">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage10-2.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage10-2.png" />
</figure>
<p>互备式备份架构的优缺点是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1.  设计比较复杂
    各个分区除了要承担业务数据存储，还需要承担备份功能，相互之间互相关联和影响。
2.  扩展麻烦
    如果增加一个武汉分区，则需要修改广州分区的复制指向武汉分区，然后将武汉分区的复制指向北京分区。
    而原有北京分区已经备份了的广州分区的数据怎么处理也是个难题:
        不管是做数据迁移，还是广州分区历史数据保留在北京分区，新数据备份到武汉分区，无论哪种方式都很麻烦
3. 成本低，直接利用已有的设备。
</pre></div>
</div>
</section>
<section id="id21">
<h3>独立式<a class="headerlink" href="#id21" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>独立式备份指每个分区自己有独立的备份中心</p>
</div>
<figure class="align-default">
<img alt="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage10-3.png" src="https://img.zhaoweiguo.com/knowledge/images/architectures/availabilitys/storage10-3.png" />
</figure>
<p>独立式备份架构的优缺点是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 设计简单，各分区互不影响。
2. 扩展容易，新增加的分区只需要搭建自己的备份中心即可。
3. 成本高，每个分区需要独立的备份中心，备份中心的场地成本是主要成本，因此独立式比集中式成本要高很多
</pre></div>
</div>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference external" href="/index.html">主页</a></p></td>
<td><p><a class="reference internal" href="../../../genindex.html"><span class="std std-ref">索引</span></a></p></td>
<td><p><a class="reference internal" href="../../../py-modindex.html"><span class="std std-ref">模块索引</span></a></p></td>
<td><p><a class="reference internal" href="../../../search.html"><span class="std std-ref">搜索页面</span></a></p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="4computing.html" class="btn btn-neutral float-right" title="计算高可用架构" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="2FMEA.html" class="btn btn-neutral" title="FMEA" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>
  
  <div id="gitalk-container"></div>
  <div role="contentinfo">
    <p>
        &copy; Copyright 2010-2025, 新溪-gordon.

    </p>
  </div>
  <div>备案号 <a href="http://www.beian.miit.gov.cn">京ICP备16018553号</a></div><div>Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a></div>. 


</footer>

<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?042289284b8eb33866001347a3e0b129";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>     
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'V2025.07',
            LANGUAGE:'zh-CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/sphinx_highlight.js"></script>
      <script type="text/javascript" src="../../../_static/clipboard.min.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });


      // var gitalk = new Gitalk({
      //         clientID: '565177626b5d46427009',
      //         clientSecret: 'b2a36e67e1d2a73e43667f46d571c2624f8e1026',
      //         repo: 'knowledge',
      //         owner: 'zhaoweiguo',
      //         admin: ['zhaoweiguo'],
      //         id: location.pathname,      // Ensure uniqueness and length less than 50
      //         distractionFreeMode: false  // Facebook-like distraction free mode
      //       })
      // gitalk.render('gitalk-container')

  </script>


<script type="text/javascript" src="../../../_static/js/table-of-contents-sidebar.js"></script>
<!-- <script type="text/javascript" src="https://table-of-contents-sidebar.github.io/table-of-contents-sidebar-lib/table-of-contents-sidebar.js"></script> -->
<script type="text/javascript">
    window.onload = function(e){
        TableOfContents.init({
            basePath: "https://table-of-contents-sidebar.github.io/table-of-contents-sidebar-lib/",
            querySelector: "body" // or other css querySelector
        });
    }
</script> 

</body>
</html>