实时计算
--------------

Esper
''''''''
Esper就是CEP的一个java的开源实现。
Esper官方网址：http://www.espertech.com/
CEP（Complex Event Processing, 复杂事件处理）
事件（Event）一般情况下指的是一个系统中正在发生的事，事件可能发生在系统的各个层面上，它可以是某个动作，例如客户下单，发送消息，提交报告等，也可以是某种状态的改变，例如温度的变化，超时等等。通过对这些事件进行分析，可以提取出其中有效的信息。 根据维基百科的定义，事件处理（Event processing）指的是跟踪系统中发生的事件，分析事件中的信息并从中得到某种结论。而复杂事件处理，则是结合多个事件源中的事件，从中推断出更加复杂的情况下的事件。

Esper主要包括了三个部分：Input adapter，Esper engine，Output adapter
2.1 Input adapter & Output adapter
输入适配器和输出适配器的主要目的是接收来自不同事件源的事件，并向不同的目的地输出事件。 目前，Esper提供的适配器包括File Input and Output adpter, Spring JMS Input and Output Adapter, AMQP Input and Output Adapter, Kafka Adapter等等。这些适配器提供了一系列接口，可以让用户从不同的数据源读取数据，并将数据发送给不同的目的数据源，用户可以不用自己单独编写客户端代码来连接这些数据源，感觉相当于对这些数据源提供了一层封装。

2.2 Esper engine
Esper引擎是处理事件的核心，它允许用户定义需要接收的事件以及对这些事件的处理方式。

2.2.1 Esper支持的事件表现形式
Esper支持多种事件表现形式， 这些事件表现形式的共同之处在于，它们都提供了事件类型的元数据，也就是说能够表示事件的一系列属性，例如，一个Java对象可以通过其成员变量来表示其事件属性，一个Map对象能够通过键值对来表示属性。由此可见，本质上事件是一系列属性值的集合，对事件的操作即对事件中的部分或全部属性的操作。

2.2.2 Esper事件处理模型
Esper的事件处理模型主要包括两个部分：Statement和Listener。 
（1）Statement 利用Esper的事件处理语言EPL声明对事件进行的操作，Esper中提供了多种类型的事件操作，包括过滤、加窗、事件聚合等等。EPL是一种类似于SQL的语言，从这一点上来看，Esper恰好与数据库相反，数据库是保存数据，并在数据上运行查询语句，而Esper是保存查询语句，在这些查询上运行数据，只要事件与查询条件匹配，Esper就会实时进行处理，而不是只有在查询提交的时候才处理。
（2）Listener Listener用于监听事件的处理情况，接收事件处理的结果，通过UpdateListener接口来实现，它相当于一个回调函数，当事件处理完成之后，可以通过该回调函数向结果发送到目的地。



Drools（JBoss Rules ）
''''''''''''''''''''''''''
具有一个易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，速度快、效率高。业务分析师或审核人员可以利用它轻松查看业务规则，从而检验是否已编码的规则执行了所需的业务规则。
JBoss Rules 的前身是Codehaus的一个开源项目叫Drools。最近被纳入JBoss门下，更名为JBoss Rules，成为了JBoss应用服务器的规则引擎。
Drools是为Java量身定制的基于Charles Forgy的RETE算法的规则引擎的实现。具有了OO接口的RETE,使得商业规则有了更自然的表达。




Storm/JStorm
'''''''''''''''''
Storm是一个免费并开源的分布式实时计算系统。利用Storm可以很容易做到可靠地处理无限的数据流，像Hadoop批量处理大数据一样，Storm可以实时处理数据。Storm简单，可以使用任何编程语言。

Storm的特点之一是可靠的消息处理机制，这个机制中最重要的一环是设计一个算法来跟踪Storm中处理的数据，确保Storm知道消息是否被完整的处理。他创造出的这个算法，极大的简化了系统的设计。

在Storm之前，进行实时处理是非常痛苦的事情: 需要维护一堆消息队列和消费者，他们构成了非常复杂的图结构。消费者进程从队列里取消息，处理完成后，去更新数据库，或者给其他队列发新消息。

Storm有如下特点::

    编程简单：开发人员只需要关注应用逻辑，而且跟Hadoop类似，Storm提供的编程原语也很简单
    高性能，低延迟：可以应用于广告搜索引擎这种要求对广告主的操作进行实时响应的场景。
    分布式：可以轻松应对数据量大，单机搞不定的场景
    可扩展： 随着业务发展，数据量和计算量越来越大，系统可水平扩展
    容错：单个节点挂了不影响应用
    消息不丢失：保证消息处理

不过Storm不是一个完整的解决方案。使用Storm时你需要关注以下几点::

    如果使用的是自己的消息队列，需要加入消息队列做数据的来源和产出的代码
    需要考虑如何做故障处理：如何记录消息队列处理的进度，应对Storm重启，挂掉的场景
    需要考虑如何做消息的回退：如果某些消息处理一直失败怎么办？

Storm的应用跟Hadoop不一样，Storm是没有包括任何存储概念的计算系统。这就让Storm可以用在多种不同的场景下：非传统场景下数据动态到达或者数据存储在数据库这样的存储系统里（或数据是被实时操控其他设备的控制器(如交易系统)所消费）

Storm有很多应用：实时分析，在线机器学习(online machine learning)，连续计算(continuous computation)，分布式远程过程调用(RPC)、ETL等。Storm处理速度很快：每个节点每秒钟可以处理超过百万的数据组。它是可扩展(scalable)，容错(fault-tolerant)，保证你的数据会被处理，并且很容易搭建和操作。

Storm模型

Storm实现了一个数据流(data flow)的模型，在这个模型中数据持续不断地流经一个由很多转换实体构成的网络。一个数据流的抽象叫做流(stream)，流是无限的元组(Tuple)序列。元组就像一个可以表示标准数据类型（例如int，float和byte数组）和用户自定义类型（需要额外序列化代码的）的数据结构。每个流由一个唯一的ID来标示的，这个ID可以用来构建拓扑中各个组件的数据源。
Storm对数据输入的来源和输出数据的去向没有做任何限制。典型场景下，输入/输出数据来是基于类似Kafka或者ActiveMQ这样的消息队列，但是数据库，文件系统或者web服务也都是可以的。

Storm中涉及的主要概念有::

    拓扑(Topologies)
    元组(Tuple)
    流(Streams)
    Spouts(喷嘴)
    Bolts
    任务(Tasks)
    组件(Component)
    流分组(Stream groupings)
    可靠性(Reliability)
    Workers(工作进程)




