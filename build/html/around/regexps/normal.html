

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>


<!-- start added 2025-04-14   增加对markdown中公式的支持 -->
<script>
window.MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
    },
    options: {
        ignoreHtmlClass: "tex2jax_ignore|mathjax_ignore",
        processHtmlClass: "tex2jax_process|mathjax_process|math|output_area"
    }
};
</script>
<script defer="defer" src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- end added 2025-04-14   增加对markdown中公式的支持 -->


  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.1. 正则基本功能 &mdash; 新溪-gordon V2025.07 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="4.2. 语言" href="lang.html" />
    <link rel="prev" title="4. 正则表达式" href="../regexp.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>
  <script src="../_static/js/jquery.min.js"></script>


<!-- 评论插件 gittalk start -->
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> -->
<!-- 评论插件 gittalk end -->


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> 新溪-gordon
          

          
          </a>

          
            
            
              <div class="version">
                V2025.07
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../encoding.html">1. 编码</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../encodings/coding.html">1.1. 各种字符编码</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/ascii.html">1.1.1. ASCII 码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/ascii.html#id2">ASCII码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/ascii.html#id3">非ASCII编码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/Unicode.html">1.1.2. Unicode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/Unicode.html#id2">实例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/Unicode.html#id3">Unicode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/Unicode.html#panel">平面Panel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/Unicode.html#id7">历史</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/utf8.html">1.1.3. UTF-8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/utf8.html#id2">几种编码格式的比较</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/utf8.html#id3">UTF-8</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/utf8.html#little-endianbig-endian">Little endian和Big endian</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/utf8.html#utf-16">UTF-16</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/gb.html">1.1.4. 国标GB</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/gb.html#id2">GB码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/gb.html#gb2312">GB2312</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/gb.html#gbk">GBK</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/gb.html#id3">其他 GB 码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/base.html">1.1.5. base编码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base100">Base100</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base91">Base91</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base85">base85</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base64">base64</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#urlbase64-url-base64">URL安全的Base64编码(URL Base64)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base62">Base62</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base58">base58</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base45">Base45</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base38">base38</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base32">base32</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/base.html#base16">base16</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/URLEncode.html">1.1.6. URLEncode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/URLEncode.html#id2">原理</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/codings/other.html">1.1.7. 其他</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/other.html#big5">BIG5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/codings/other.html#iso-8859">ISO-8859</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/normalization.html">1.2. Uncode标准化</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/normalizations/normal.html">1.2.1. 通用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/normalizations/NFC.html">1.2.2. NFC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFC.html#id2">特点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFC.html#id3">适用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFC.html#id4">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/normalizations/NFKC.html">1.2.3. NFKC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFKC.html#id2">NFKC 的特点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFKC.html#id3">NFKC 的作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFKC.html#id4">示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFKC.html#id5">NFKC 的应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFKC.html#nfkc-nfd">NFKC 与 NFD 的区别</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/normalizations/NFD.html">1.2.4. NFD</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFD.html#unicode">Unicode 标准化背景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFD.html#id2">NFD 的作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFD.html#id3">适用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFD.html#id4">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/normalizations/NFKD.html">1.2.5. NFKD</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/normalizations/NFKD.html#id2">示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/DataSerialization.html">1.3. Data Serialization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/DataSerializations/normal.html">1.3.1. 常用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/DataSerializations/json.html">1.3.2. JSON</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/escape.html">1.4. 转义</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/escape.html#escape">1.4.1. 各种 Escape</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/escape.html#ascii-escape">AscII Escape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/escape.html#string-escape">string-escape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/escape.html#unicode-escape">unicode-escape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/escape.html#url-encode-decode">URL Encode/Decode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/escape.html#id3">其他</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/escape.html#id4">1.4.2. 控制字符</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/escape.html#id5">1.4.3. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/locale.html">1.5. locale相关</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/locale.html#id3">1.5.1. locale 命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/locale.html#id4">1.5.2. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/question.html">1.6. 编码相关问题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/question.html#encode-decode">1.6.1. 什么情况用encode，什么情况又是decode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/question.html#id3">1.6.2. 可能的解决方法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/resource.html">1.7. 资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/resources/http_Content-Type.html">1.7.1. Http Content-type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/resources/html_transfer-character.html">1.7.2. Html转意字符</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/resources/Ascii.html">1.7.3. Ascii对照表</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/resources/Ascii.html#id1">Ascii特殊字符解释</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/resources/http_status-code.html">1.7.4. Http状态码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../encodings/resources/linux_port.html">1.7.5. Linux系统端口</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../encodings/resources/linux_port.html#unix">Unix特有的端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/resources/linux_port.html#iana">IANA注册的端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/resources/linux_port.html#id1">数据报传递协议端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/resources/linux_port.html#kerberos">Kerberos端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="../encodings/resources/linux_port.html#id2">未注册的端口</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/BOM.html">1.8. BOM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../encodings/BOM.html#id2">1.8.1. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../encodings/other.html">1.9. 其他</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../time-zone.html">2. 时区</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../time-zones/normal.html">2.1. 常用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../time-zones/utc_cst.html">2.2. 存储用UTC时间</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../time-zones/utc_cst.html#id2">2.2.1. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../time-zones/time.html">2.3. 时间格式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../time-zones/china.html">2.4. 中国相关</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../resource.html">3. 资源库</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../resources/ip.html">3.1. ip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resources/CDN.html">3.2. CDN</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../resources/CDN.html#id2">3.2.1. 中国CDN加速</a></li>
<li class="toctree-l3"><a class="reference internal" href="../resources/CDN.html#id3">3.2.2. 图床工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../resources/CDN.html#upic-macos">uPic(只支持 macos)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../resources/%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1.html">3.3. 托管服务</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../resources/%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1.html#netlify">3.3.1. netlify</a></li>
<li class="toctree-l3"><a class="reference internal" href="../resources/%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1.html#jsdelivr">3.3.2. jsdelivr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../resources/%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1.html#itclan">3.3.3. itclan</a></li>
<li class="toctree-l3"><a class="reference internal" href="../resources/%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1.html#pythonanywhere">3.3.4. PythonAnywhere</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../resources/%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1.html#fastapi-asgi">fastapi(ASGI)如何使用</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../resources/mirror.html">3.4. 镜像服务</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../regexp.html">4. 正则表达式</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.1. 正则基本功能</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#metacharacter">4.1.1. 元字符(Metacharacter)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">1. 特殊字符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">2. 空白符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">3. 量词</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">4. 范围</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">4.1.2. 量词的贪婪, 非贪婪与独占模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">4.1.3. 分组&amp;引用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">分组与编号</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">命名分组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">分组引用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">不保存子组</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#match-mode">4.1.4. 匹配模式(Match Mode)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#case-insensitive">1. 不区分大小写模式(Case-Insensitive)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dot-all">2. 点号通配模式(Dot All)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiline">3. 多行匹配模式(Multiline)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comment">4. 注释模式(Comment)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#x">5. x 模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">6. 其他</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertion">4.1.5. 断言(Assertion)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#word-boundary">1. 单词边界(Word Boundary)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">2. 行的开始或结束</a></li>
<li class="toctree-l4"><a class="reference internal" href="#look-around">3. 环视(Look Around)/零宽断言</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">零宽断言</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#escape">4.1.6. 转义Escape</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">字符串转义和正则转义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">元字符的转义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">括号的转义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">转义函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">字符组中的转义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id21">4.1.7. 常见的流派及其特性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#posix">1. POSIX 流派</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pcre">2. PCRE 流派</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">区别</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unicode">4.1.8. Unicode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id24">Unicode 属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">表情符号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id26">4.1.9. 匹配原理以及优化原则</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nfa">4.1.10. NFA 工作机制</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id27">示例演示1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">示例演示2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dfa">4.1.11. DFA 工作机制</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id30">示例演示</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#posix-nfa">4.1.12. POSIX NFA工作机制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id32">4.1.13. 回溯</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id33">示例1-简单回溯</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">示例2-.* 导致大量回溯</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">示例3-店名匹配</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">示例3-店名匹配(优化版)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id37">示例3-店名匹配(独占模式优化版)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id38">示例3-店名匹配(其他优化版)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id39">4.1.14. 正则调试</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#regex101-comregex-debugger">regex101.com的Regex Debugger</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id40">4.1.15. 正则优化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id41">1. 测试性能的方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id42">2. 提前编译好正则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id43">3. 尽量准确表示匹配范围</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id44">4. 提取出公共部分</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id45">5. 出现可能性大的放左边</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id46">6. 只在必要时才使用子组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id47">7. 警惕嵌套的子组重复</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id48">8. 避免不同分支重复匹配</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id49">4.1.16. 语系对正则表达式的影响</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id50">4.1.17. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lang.html">4.2. 语言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lang.html#id3">4.2.1. 1. 校验文本内容</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lang.html#python">Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#golang">Golang</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#javascript">JavaScript</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lang.html#id4">4.2.2. 2. 提取文本内容</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id5">Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id6">Golang</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id7">JavaScript</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lang.html#id8">4.2.3. 3. 替换文本内容</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id9">Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id10">Golang</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id11">JavaScript</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lang.html#id12">4.2.4. 4. 切割文本内容</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id13">Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id14">Golang</a></li>
<li class="toctree-l4"><a class="reference internal" href="lang.html#id15">JavaScript</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="example.html">4.3. 实例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="example.html#id3">4.3.1. 1. 数字</a><ul>
<li class="toctree-l4"><a class="reference internal" href="example.html#id4">基本</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id5">浮点数</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id6">十六进制数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="example.html#id7">4.3.2. 常见码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="example.html#id8">手机号码</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id9">身份证号码</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id10">邮政编码</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#qq">腾讯 QQ 号码</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id11">日期和时间</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id12">邮箱</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="example.html#ip">4.3.3. IP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="example.html#ipv4">IPv4 地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#ipv6">IPv6</a></li>
<li class="toctree-l4"><a class="reference internal" href="example.html#id13">中文字符</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tmp.html">4.4. 临时</a></li>
<li class="toctree-l2"><a class="reference internal" href="other_wildcard.html">4.5. 通配符</a></li>
<li class="toctree-l2"><a class="reference internal" href="other_glob_pattern.html">4.6. glob 模式</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chart.html">5. 图表</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../charts/common.html">5.1. 图表</a></li>
<li class="toctree-l2"><a class="reference internal" href="../charts/sankey_diagram.html">5.2. 桑基图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../charts/bubble_chart.html">5.3. 气泡图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../charts/rose_illustration.html">5.4. 南丁格尔玫瑰图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../charts/flame_graph.html">5.5. 火焰图</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../charts/flame_graph.html#id3">5.5.1. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../charts/other.html">5.6. 其他</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../charts/other.html#id4">5.6.1. 力导向图 </a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../special-subject.html">6. 专题专问</a></li>
<li class="toctree-l1"><a class="reference internal" href="../font.html">7. 字体</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../fonts/law.html">7.1. 法律</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fonts/law.html#id3">7.1.1. 免费字体</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fonts/law.html#id4">7.1.2. 字体识别平台</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fonts/law.html#id5">7.1.3. 案例讲解</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fonts/law.html#id6">7.1.4. 侵权案例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unit.html">8. 计量单位</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">新溪-gordon</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../regexp.html"><span class="section-number">4. </span>正则表达式</a> &raquo;</li>
        
      <li><span class="section-number">4.1. </span>正则基本功能</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/regexps/normal.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            <nav id="local-table-of-contents" role="navigation" aria-labelledby="local-table-of-contents-title">
              <h4 id="local-table-of-contents-title">On This Page</h4>
              <ul>
<li><a class="reference internal" href="#">4.1. 正则基本功能</a><ul>
<li><a class="reference internal" href="#metacharacter">4.1.1. 元字符(Metacharacter)</a><ul>
<li><a class="reference internal" href="#id3">1. 特殊字符</a></li>
<li><a class="reference internal" href="#id4">2. 空白符</a></li>
<li><a class="reference internal" href="#id5">3. 量词</a></li>
<li><a class="reference internal" href="#id6">4. 范围</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">4.1.2. 量词的贪婪, 非贪婪与独占模式</a></li>
<li><a class="reference internal" href="#id8">4.1.3. 分组&amp;引用</a><ul>
<li><a class="reference internal" href="#id9">分组与编号</a></li>
<li><a class="reference internal" href="#id10">命名分组</a></li>
<li><a class="reference internal" href="#id11">分组引用</a></li>
<li><a class="reference internal" href="#id12">不保存子组</a></li>
</ul>
</li>
<li><a class="reference internal" href="#match-mode">4.1.4. 匹配模式(Match Mode)</a><ul>
<li><a class="reference internal" href="#case-insensitive">1. 不区分大小写模式(Case-Insensitive)</a></li>
<li><a class="reference internal" href="#dot-all">2. 点号通配模式(Dot All)</a></li>
<li><a class="reference internal" href="#multiline">3. 多行匹配模式(Multiline)</a></li>
<li><a class="reference internal" href="#comment">4. 注释模式(Comment)</a></li>
<li><a class="reference internal" href="#x">5. x 模式</a></li>
<li><a class="reference internal" href="#id13">6. 其他</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assertion">4.1.5. 断言(Assertion)</a><ul>
<li><a class="reference internal" href="#word-boundary">1. 单词边界(Word Boundary)</a></li>
<li><a class="reference internal" href="#id14">2. 行的开始或结束</a></li>
<li><a class="reference internal" href="#look-around">3. 环视(Look Around)/零宽断言</a></li>
<li><a class="reference internal" href="#id15">零宽断言</a></li>
</ul>
</li>
<li><a class="reference internal" href="#escape">4.1.6. 转义Escape</a><ul>
<li><a class="reference internal" href="#id16">字符串转义和正则转义</a></li>
<li><a class="reference internal" href="#id17">元字符的转义</a></li>
<li><a class="reference internal" href="#id18">括号的转义</a></li>
<li><a class="reference internal" href="#id19">转义函数</a></li>
<li><a class="reference internal" href="#id20">字符组中的转义</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21">4.1.7. 常见的流派及其特性</a><ul>
<li><a class="reference internal" href="#posix">1. POSIX 流派</a></li>
<li><a class="reference internal" href="#pcre">2. PCRE 流派</a></li>
<li><a class="reference internal" href="#id22">区别</a></li>
<li><a class="reference internal" href="#id23">参考</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unicode">4.1.8. Unicode</a><ul>
<li><a class="reference internal" href="#id24">Unicode 属性</a></li>
<li><a class="reference internal" href="#id25">表情符号</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id26">4.1.9. 匹配原理以及优化原则</a></li>
<li><a class="reference internal" href="#nfa">4.1.10. NFA 工作机制</a><ul>
<li><a class="reference internal" href="#id27">示例演示1</a></li>
<li><a class="reference internal" href="#id28">示例演示2</a></li>
<li><a class="reference internal" href="#id29">总结</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dfa">4.1.11. DFA 工作机制</a><ul>
<li><a class="reference internal" href="#id30">示例演示</a></li>
<li><a class="reference internal" href="#id31">总结</a></li>
</ul>
</li>
<li><a class="reference internal" href="#posix-nfa">4.1.12. POSIX NFA工作机制</a></li>
<li><a class="reference internal" href="#id32">4.1.13. 回溯</a><ul>
<li><a class="reference internal" href="#id33">示例1-简单回溯</a></li>
<li><a class="reference internal" href="#id34">示例2-.* 导致大量回溯</a></li>
<li><a class="reference internal" href="#id35">示例3-店名匹配</a></li>
<li><a class="reference internal" href="#id36">示例3-店名匹配(优化版)</a></li>
<li><a class="reference internal" href="#id37">示例3-店名匹配(独占模式优化版)</a></li>
<li><a class="reference internal" href="#id38">示例3-店名匹配(其他优化版)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id39">4.1.14. 正则调试</a><ul>
<li><a class="reference internal" href="#regex101-comregex-debugger">regex101.com的Regex Debugger</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id40">4.1.15. 正则优化</a><ul>
<li><a class="reference internal" href="#id41">1. 测试性能的方法</a></li>
<li><a class="reference internal" href="#id42">2. 提前编译好正则</a></li>
<li><a class="reference internal" href="#id43">3. 尽量准确表示匹配范围</a></li>
<li><a class="reference internal" href="#id44">4. 提取出公共部分</a></li>
<li><a class="reference internal" href="#id45">5. 出现可能性大的放左边</a></li>
<li><a class="reference internal" href="#id46">6. 只在必要时才使用子组</a></li>
<li><a class="reference internal" href="#id47">7. 警惕嵌套的子组重复</a></li>
<li><a class="reference internal" href="#id48">8. 避免不同分支重复匹配</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id49">4.1.16. 语系对正则表达式的影响</a></li>
<li><a class="reference internal" href="#id50">4.1.17. 参考</a></li>
</ul>
</li>
</ul>

            </nav>
  <table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference external" href="/index.html">主页</a></p></td>
<td><p><a class="reference internal" href="../genindex.html"><span class="std std-ref">索引</span></a></p></td>
<td><p><a class="reference internal" href="../py-modindex.html"><span class="std std-ref">模块索引</span></a></p></td>
<td><p><a class="reference internal" href="../search.html"><span class="std std-ref">搜索页面</span></a></p></td>
</tr>
</tbody>
</table>
<section id="regexp-normal">
<span id="id2"></span><h1><span class="section-number">4.1. </span>正则基本功能<a class="headerlink" href="#regexp-normal" title="此标题的永久链接">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>插入符号 ^ 和美元符号 $ 在正则表达式中具有特殊的意义，它们被称为 “锚点”。【另外】^，中文尚无通用名称，可以是插入符号、插入符、脱字符号、脱字符等；英文称为 Caret (英语发音：/ˈkærət/)，是个倒 V 形的字素</p>
</div>
<section id="metacharacter">
<h2><span class="section-number">4.1.1. </span>元字符(Metacharacter)<a class="headerlink" href="#metacharacter" title="此标题的永久链接">¶</a></h2>
<p>定义:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，元字符是构成正则表达式的基本元件。
正则就是由一系列的元字符组成的
如:
    \d 和 {11}
</pre></div>
</div>
<section id="id3">
<h3>1. 特殊字符<a class="headerlink" href="#id3" title="此标题的永久链接">¶</a></h3>
<p>常用特殊字符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.              除换行外的任意字符(在英文环境下)

\d             数字 [0-9]
\D             非数字 [^0-9]

\s             空白字符[ \t\r\n\f]
\S             非空白字符[^ \t\r\n\f]

\w             单词字符[A-Za-z0-9_]
\W             非单词字符[^A-Za-z0-9_]
    https://stackoverflow.com/a/11874614/2714931
    \W would match any non-word character
        and so its easy to try to use it to match word boundaries.
    The problem is that it will not match the start or end of a line.

\d 对于Unicode（str类型）模式：匹配任何一个数字，包括[0-9]和其他数字字符
    如果开启了re.ASCII,只匹配 [0-9]
\D与\d相反，如果开启了re.ASCII,只匹配 [^0-9]
\s 对于Unicode(str类型)模式:匹配Unicode中的空白字符(包括[\t\n\v\f\r]以及其他空白字符)
    如果开启了re.ASCII标志，就只匹配[\t\n\f\v\r]
\S与\s相反,如果开启了re.ASCII标志,就只匹配[^\t\n\f\v\r]
\w于Unicode（str类型）模式：匹配任何Unicode的单词字符，基本上所以语言的字符都可以匹配，包括数字和下划线
    如果开启了re.ASCII，只匹配[0-9a-zA-Z_]
\W与\w相反，如果开启了re.ASCII，只匹配[^0-9a-zA-Z_]
</pre></div>
</div>
<p>其他特殊字符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">A匹配输入字符串的开始位置</span>
\<span class="n">Z匹配输入字符串的结束位置</span>

\<span class="n">u</span><span class="p">,</span>\<span class="n">U只有在Unicode模式下才被识别</span>
</pre></div>
</div>
<p>解释:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">d</span> <span class="n">是</span> <span class="n">digit</span> <span class="n">数字</span>
<span class="mf">2.</span> <span class="n">w</span> <span class="n">是</span> <span class="n">word</span> <span class="n">单词</span>
<span class="mf">3.</span> <span class="n">s</span> <span class="n">是</span> <span class="n">space</span> <span class="n">空白</span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>2. 空白符<a class="headerlink" href="#id4" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">r</span> <span class="n">回车符</span>
\<span class="n">n</span> <span class="n">换行符</span>
\<span class="n">f</span> <span class="n">换页符</span>
\<span class="n">t</span> <span class="n">制表符</span>
\<span class="n">v</span> <span class="n">垂直制表符</span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>3. 量词<a class="headerlink" href="#id5" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 星号（*）代表出现 0 到多次
2. 加号（+）代表 1 到多次
3. 问号（?）代表 0 到 1 次
4. {m,n} 代表 m 到 n 次
5. {m} 代表 m 次
6. {m, } 代表最小 m 次
</pre></div>
</div>
</section>
<section id="id6">
<h3>4. 范围<a class="headerlink" href="#id6" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="o">|</span><span class="p">:</span> <span class="n">或</span>
    <span class="n">如</span><span class="p">:</span>
        <span class="n">ab</span><span class="o">|</span><span class="n">bc</span> <span class="n">代表</span> <span class="n">ab</span> <span class="n">或</span> <span class="n">bc</span>
<span class="mf">2.</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="n">多选一</span>
    <span class="n">代表中括号内的任一元素</span>
<span class="mf">3.</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">z</span><span class="p">]</span><span class="n">代表a</span><span class="o">-</span><span class="n">z之间任一元素</span>
<span class="mf">4.</span> <span class="p">[</span><span class="o">^...</span><span class="p">]</span> <span class="n">取反</span>
</pre></div>
</div>
</section>
</section>
<section id="id7">
<h2><span class="section-number">4.1.2. </span>量词的贪婪, 非贪婪与独占模式<a class="headerlink" href="#id7" title="此标题的永久链接">¶</a></h2>
<ol class="arabic">
<li><p>贪婪匹配（Greedy）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在正则中，表示次数的量词默认是贪婪的
贪婪模式的特点就是尽可能进行最大长度匹配。
如:
    a*
    a+
</pre></div>
</div>
</li>
<li><p>非贪婪匹配（Lazy）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如何将贪婪模式变成非贪婪模式:
    可以在量词后面加上英文的问号 (?)，正则就变成了 a*?

非贪婪模式会尽可能短地去匹配
</pre></div>
</div>
</li>
</ol>
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_greedy_lazy1.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_greedy_lazy1.png" />
<ol class="arabic" start="3">
<li><p>独占模式（Possessive）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好

如:
    regex = &quot;xy{1,3}+yz&quot;
    text = &quot;xyyz&quot;
    使用「独占模式」就会匹配失败
</pre></div>
</div>
</li>
</ol>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Python 和 Go 的标准库目前都不支持独占模式，会报错</p>
</div>
<p>示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a*&#39;</span><span class="p">,</span> <span class="s1">&#39;aaabb&#39;</span><span class="p">)</span>  <span class="c1"># 贪婪模式</span>
<span class="go">[&#39;aaa&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a*?&#39;</span><span class="p">,</span> <span class="s1">&#39;aaabb&#39;</span><span class="p">)</span> <span class="c1"># 非贪婪模式</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>示例2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">regex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;xy{1,3}z&#39;</span><span class="p">,</span> <span class="s1">&#39;xyyz&#39;</span><span class="p">)</span>  <span class="c1"># 贪婪模式</span>
<span class="go">[&#39;xyyz&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;xy{1,3}+z&#39;</span><span class="p">,</span> <span class="s1">&#39;xyyz&#39;</span><span class="p">)</span> <span class="c1"># 独占模式</span>
<span class="go">[&#39;xyyz&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;xy{1,2}+yz&#39;</span><span class="p">,</span> <span class="s1">&#39;xyyz&#39;</span><span class="p">)</span> <span class="c1"># 独占模式</span>
<span class="go">[]</span>
</pre></div>
</div>
</section>
<section id="id8">
<h2><span class="section-number">4.1.3. </span>分组&amp;引用<a class="headerlink" href="#id8" title="此标题的永久链接">¶</a></h2>
<section id="id9">
<h3>分组与编号<a class="headerlink" href="#id9" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>第几个括号就是第几个分组。只需要数左括号（开括号）是第几个，就可以确定是第几个子组</p>
</div>
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping3.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping3.png" />
</section>
<section id="id10">
<h3>命名分组<a class="headerlink" href="#id10" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为 (?P &lt; 分组名&gt; 正则)。</p>
</div>
<p>示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>^profile/(?P&lt;username&gt;\w+)/$
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>命名分组并不是所有语言都支持的，在使用时，你需要查阅所用语言正则说明文档</p>
</div>
</section>
<section id="id11">
<h3>分组引用<a class="headerlink" href="#id11" title="此标题的永久链接">¶</a></h3>
<figure class="align-default" id="id52">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping4.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping4.png" />
<figcaption>
<p><span class="caption-text">分组引用在查找中使用</span><a class="headerlink" href="#id52" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id53">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping5.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping5.png" />
<figcaption>
<p><span class="caption-text">分组引用在替换中使用</span><a class="headerlink" href="#id53" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_str</span> <span class="o">=</span> <span class="s2">&quot;2020-05-10 20:23:05&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;((\d</span><span class="si">{4}</span><span class="s2">)-(\d</span><span class="si">{2}</span><span class="s2">)-(\d</span><span class="si">{2}</span><span class="s2">)) ((\d</span><span class="si">{2}</span><span class="s2">):(\d</span><span class="si">{2}</span><span class="s2">):(\d</span><span class="si">{2}</span><span class="s2">))&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subst</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;日期 \1 时间 \5   \2 年 \3 月 \4 日 \6 时 \7 分 \8 秒&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">test_str</span><span class="p">)</span>
<span class="go">&#39; 日期 2020-05-10 时间 20:23:05   2020 年 05 月 10 日 20 时 23 分 05 秒&#39;</span>
</pre></div>
</div>
<p>实例说明:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一篇英文文章，里面有一些单词连续出现了多次，我们认为连续出现多次的单词应该是一次
比如：
the little cat cat is in the hat hat hat, we like it.
其中 cat 和 hat 连接出现多次，要求处理后结果是
the little cat is in the hat, we like it.
</pre></div>
</div>
<figure class="align-default" id="id54">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping6.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping6.png" />
<figcaption>
<p><span class="caption-text">上面实例使用正则 <code class="docutils literal notranslate"><span class="pre">(\w+)(\s\1)+</span></code></span><a class="headerlink" href="#id54" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="id12">
<h3>不保存子组<a class="headerlink" href="#id12" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果正则中出现了括号，那么我们就认为，这个子表达式在后续可能会再次被引用，所以不保存子组可以提高正则的性能。</p>
</div>
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping1.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping1.png" />
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_grouping2.png" />
</section>
</section>
<section id="match-mode">
<h2><span class="section-number">4.1.4. </span>匹配模式(Match Mode)<a class="headerlink" href="#match-mode" title="此标题的永久链接">¶</a></h2>
<section id="case-insensitive">
<h3>1. 不区分大小写模式(Case-Insensitive)<a class="headerlink" href="#case-insensitive" title="此标题的永久链接">¶</a></h3>
<p>模式修饰符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格式: (?模式标识)
如:
    (?i)cat    # 不区分大小写的 cat
</pre></div>
</div>
<p>要点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 不区分大小写模式的指定方式，使用模式修饰符 (?i)
2. 修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则
3. 使用编程语言时可以使用预定义好的常量来指定匹配模式
</pre></div>
</div>
<figure class="align-default" id="id55">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode1.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode1.png" />
<figcaption>
<p><span class="caption-text">尝试匹配两个连续出现的 cat，即便是第一个 cat 和第二个 cat 大小写不一致，也可以匹配上。</span><a class="headerlink" href="#id55" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id56">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode2.png" />
<figcaption>
<p><span class="caption-text">想要前面匹配上的结果，和第二次重复时的大小写一致，只需要用括号把修饰符和正则 cat 部分括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容。</span><a class="headerlink" href="#id56" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="dot-all">
<h3>2. 点号通配模式(Dot All)<a class="headerlink" href="#dot-all" title="此标题的永久链接">¶</a></h3>
<p>模式修饰符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格式: (?s)
如:
    (?s).+
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有很多地方把它称作 <strong>单行匹配模式</strong> ，但这么说容易造成误解，毕竟它与多行匹配模式没有联系。在单行匹配模式下，.可以匹配换行。</p>
</div>
<figure class="align-default" id="id57">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode3.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode3.png" />
<figcaption>
<p><span class="caption-text">一个点号通配模式的例子</span><a class="headerlink" href="#id57" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>JavaScript 不支持此模式，那么我们就可以使用前面说的 [sS] 等方式替代。在 Ruby 中则是用 Multiline，来表示点号通配模式（单行匹配模式）</p>
</div>
</section>
<section id="multiline">
<h3>3. 多行匹配模式(Multiline)<a class="headerlink" href="#multiline" title="此标题的永久链接">¶</a></h3>
<p>模式修饰符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格式: (?m)
如:
    (?m)^the|cat$

^ 匹配整个字符串的开头
$ 匹配整个字符串的结尾
</pre></div>
</div>
<figure class="align-default" id="id58">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode4.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode4.png" />
<figcaption>
<p><span class="caption-text">非多行模式</span><a class="headerlink" href="#id58" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id59">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode5.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_match_mode5.png" />
<figcaption>
<p><span class="caption-text">多行模式</span><a class="headerlink" href="#id59" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="comment">
<h3>4. 注释模式(Comment)<a class="headerlink" href="#comment" title="此标题的永久链接">¶</a></h3>
<p>模式修饰符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格式: (?#comment)
如:
    (\w+)(?#word) \1(?#word repeat again)
</pre></div>
</div>
</section>
<section id="x">
<h3>5. x 模式<a class="headerlink" href="#x" title="此标题的永久链接">¶</a></h3>
<p>x 模式也可以起到注释的作用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="n">regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;(?mx)  # 使用多行模式和 x 模式</span>
<span class="s1">^          # 开头</span>
<span class="s1">(\d </span><span class="si">{4}</span><span class="s1">)    # 年</span>
<span class="s1">(\d </span><span class="si">{2}</span><span class="s1">)    # 月</span>
<span class="s1">$          # 结尾</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="s1">&#39;202006</span><span class="se">\n</span><span class="s1">202007&#39;</span><span class="p">)</span>
<span class="c1"># 输出结果 [(&#39;2020&#39;, &#39;06&#39;), (&#39;2020&#39;, &#39;07&#39;)]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 x 模式下，所有的换行和空格都会被忽略。为了换行和空格的正确使用，我们可以通过把空格放入字符组中，或将空格转义来解决换行和空格的忽略问题。</p>
</div>
</section>
<section id="id13">
<h3>6. 其他<a class="headerlink" href="#id13" title="此标题的永久链接">¶</a></h3>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> 匹配模式 <a class="reference external" href="https://docs.python.org/3.8/library/re.html#module-re">Python3专用</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格式: (?a)
说明:
    指的是 ASCII 模式，可以让 \w 等只匹配 ASCII
例:
    &gt;&gt;&gt; re.findall(r&#39;(?a)^.$&#39;, &#39;学&#39;)
    [&#39;学&#39;]
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">:</span></code> 匹配模式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格式: (?:&lt;xxxxx&gt;)
说明:
    不创建后向引用的group
    即: 不保存子组
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="assertion">
<h2><span class="section-number">4.1.5. </span>断言(Assertion)<a class="headerlink" href="#assertion" title="此标题的永久链接">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>【定义】在有些情况下，我们对要匹配的文本的位置也有一定的要求。为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言。</p>
</div>
<p>断言有三种:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">单词边界</span>
<span class="mf">2.</span> <span class="n">行的开始或结束</span>
<span class="mf">3.</span> <span class="n">环视</span>
</pre></div>
</div>
<section id="word-boundary">
<h3>1. 单词边界(Word Boundary)<a class="headerlink" href="#word-boundary" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\b匹配一个单词边界，单词定义为Unidcode的字母数字或下划线字符
\B匹配非单词边界，跟\b相反
</pre></div>
</div>
<p>准确匹配单词:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">使用</span> \<span class="n">b</span>\<span class="n">w</span><span class="o">+</span>\<span class="n">b</span>
</pre></div>
</div>
<p>准确匹配单词tom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">使用</span> \<span class="n">btom</span>\<span class="n">b</span>
</pre></div>
</div>
</section>
<section id="id14">
<h3>2. 行的开始或结束<a class="headerlink" href="#id14" title="此标题的永久链接">¶</a></h3>
<p>日志起始行判断:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">判断条件</span><span class="p">:</span> <span class="n">以时间开头</span>
<span class="n">那些不是以时间开头的可能就是打印的堆栈信息</span>
</pre></div>
</div>
<p>输入数据校验:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^\d</span><span class="si">{6}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="s2">&quot;123456&quot;</span><span class="p">)</span>  <span class="c1"># 用户录入的 6 位数字必须是行的开头或结尾</span>
</pre></div>
</div>
</section>
<section id="look-around">
<h3>3. 环视(Look Around)/零宽断言<a class="headerlink" href="#look-around" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，有些地方也称环视为零宽断言。</p>
</div>
<p>环视的4种结构:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(?&lt;=Y): 肯定逆序(postive-lookbehind)
(?&lt;!Y): 否定逆序(negative-lookbehind)
(?=Y):  肯定顺序(postive-lookahead)
(?!Y):  否定顺序(negative-lookahead)
</pre></div>
</div>
<figure class="align-default" id="id60">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_assertion1.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_assertion1.png" />
<figcaption>
<p><span class="caption-text">左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思。</span><a class="headerlink" href="#id60" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>环视中虽然也有括号，但不会保存成子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容。</p>
</div>
<figure class="align-default" id="id61">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_assertion2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_assertion2.png" />
<figcaption>
<p><span class="caption-text">验证是否有且只有 6 位数字。</span><a class="headerlink" href="#id61" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id62">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_assertion3.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_assertion3.png" />
<figcaption>
<p><span class="caption-text">左边不是数字，右边也不是数字的 6 位数的正则。即 <code class="docutils literal notranslate"><span class="pre">(?&lt;!\d)\d{6}(?!\d)</span></code></span><a class="headerlink" href="#id62" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="id15">
<h3>零宽断言<a class="headerlink" href="#id15" title="此标题的永久链接">¶</a></h3>
<p>元字符 “^” 和 “$” 匹配的只是位置，顺序环视 “(?=[a-z])” 只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>A,Z,b,^,$都是零宽断言</p>
</div>
</section>
</section>
<section id="escape">
<h2><span class="section-number">4.1.6. </span>转义Escape<a class="headerlink" href="#escape" title="此标题的永久链接">¶</a></h2>
<ul class="simple">
<li><p>转义字符: Escape Character</p></li>
</ul>
<p>转义序列通常有两种功能:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 编码无法用字母表直接表示的特殊数据
2. 用于表示无法直接键盘录入的字符（如回车符）
</pre></div>
</div>
<section id="id16">
<h3>字符串转义和正则转义<a class="headerlink" href="#id16" title="此标题的永久链接">¶</a></h3>
<figure class="align-default" id="id63">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_escape2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_escape2.png" />
<figcaption>
<p><span class="caption-text">我们输入的字符串，四个反斜杠 <code class="docutils literal notranslate"><span class="pre">\\\\</span></code> ，经过第一步字符串转义，它代表的含义是两个反斜杠 <code class="docutils literal notranslate"><span class="pre">\\</span></code> ；这两个反斜杠再经过第二步正则转义，它就可以代表单个反斜杠 <code class="docutils literal notranslate"><span class="pre">\</span></code> 了。</span><a class="headerlink" href="#id63" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;a*b+c?</span><span class="se">\\</span><span class="s1">d123d</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;\\&#39;, &#39;\\&#39;]</span>
<span class="go">=&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;a*b+c?</span><span class="se">\\</span><span class="s1">d123d</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;\\&#39;, &#39;\\&#39;]</span>
</pre></div>
</div>
</section>
<section id="id17">
<h3>元字符的转义<a class="headerlink" href="#id17" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;\+&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="go">[&#39;+&#39;]</span>
</pre></div>
</div>
</section>
<section id="id18">
<h3>括号的转义<a class="headerlink" href="#id18" title="此标题的永久链接">¶</a></h3>
<p>方括号 [] 和 花括号 {} 只需转义开括号，但圆括号 () 两个都要转义:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;\(\)$$</span>
</pre></div>
</div>
<dl class="simple">
<dt>]{}’, ‘()[]{}’)</dt><dd><p>[‘()[]{}’]</p>
</dd>
</dl>
<p>方括号和花括号都转义也可以:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;\(\)\[</span>
</pre></div>
</div>
<dl class="simple">
<dt>$${}’, ‘()[]{}’)</dt><dd><p>[‘()[]{}’]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在正则中，圆括号通常用于分组，或者将某个部分看成一个整体，如果只转义开括号或闭括号，正则会认为少了另外一半，所以会报错。</p>
</div>
</section>
<section id="id19">
<h3>转义函数<a class="headerlink" href="#id19" title="此标题的永久链接">¶</a></h3>
<figure class="align-default" id="id64">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_escape1_lang.jpeg" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_escape1_lang.jpeg" />
<figcaption>
<p><span class="caption-text">编程语言对应的转义函数</span><a class="headerlink" href="#id64" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>Python 实例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;\d&#39;</span><span class="p">)</span>  <span class="c1"># 反斜杠和字母d转义</span>
<span class="go">&#39;\\\\d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;\d&#39;</span><span class="p">),</span> <span class="s1">&#39;\d&#39;</span><span class="p">)</span>
<span class="go">[&#39;\\d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;[+]&#39;</span><span class="p">)</span>  <span class="c1"># 中括号和加号</span>
<span class="go">&#39;\$$</span>
</pre></div>
</div>
<p>\+$$’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;[+]&#39;</span><span class="p">),</span> <span class="s1">&#39;[+]&#39;</span><span class="p">)</span>
<span class="go">[&#39;[+]&#39;]</span>
</pre></div>
</div>
</section>
<section id="id20">
<h3>字符组中的转义<a class="headerlink" href="#id20" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>书写正则的时候，在字符组中，如果有过多的转义会导致代码可读性差。在字符组里只有三种情况需要转义</p>
</div>
<ol class="arabic">
<li><p>脱字符在中括号中，且在第一个位置需要转义:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^ab]&#39;</span><span class="p">,</span> <span class="s1">&#39;^ab&#39;</span><span class="p">)</span>  <span class="c1"># 转义前代表&quot;非&quot;</span>
<span class="go">[&#39;^&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\^ab]&#39;</span><span class="p">,</span> <span class="s1">&#39;^ab&#39;</span><span class="p">)</span>  <span class="c1"># 转义后代表普通字符</span>
<span class="go">[&#39;^&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
</li>
<li><p>中划线在中括号中，且不在首尾位置:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-c]&#39;</span><span class="p">,</span> <span class="s1">&#39;abc-&#39;</span><span class="p">)</span>  <span class="c1"># 中划线在中间，代表&quot;范围&quot;</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a\-c]&#39;</span><span class="p">,</span> <span class="s1">&#39;abc-&#39;</span><span class="p">)</span>  <span class="c1"># 中划线在中间，转义后的</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;-&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[-ac]&#39;</span><span class="p">,</span> <span class="s1">&#39;abc-&#39;</span><span class="p">)</span>  <span class="c1"># 在开头，不需要转义</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;-&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[ac-]&#39;</span><span class="p">,</span> <span class="s1">&#39;abc-&#39;</span><span class="p">)</span>  <span class="c1"># 在结尾，不需要转义</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;-&#39;]</span>
</pre></div>
</div>
</li>
<li><p>右括号在中括号中，且不在首位:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[]ab]&#39;</span><span class="p">,</span> <span class="s1">&#39;]ab&#39;</span><span class="p">)</span>  <span class="c1"># 右括号不转义，在首位</span>
<span class="go">[&#39;]&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a]b]&#39;</span><span class="p">,</span> <span class="s1">&#39;]ab&#39;</span><span class="p">)</span>  <span class="c1"># 右括号不转义，不在首位</span>
<span class="go">[]  # 匹配不上，因为含义是 a后面跟上b]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a\]b]&#39;</span><span class="p">,</span> <span class="s1">&#39;]ab&#39;</span><span class="p">)</span>  <span class="c1"># 转义后代表普通字符</span>
<span class="go">[&#39;]&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
</li>
</ol>
<p>除上面三种必须转义的情况，其它情况不转义也能正常工作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[.*+?()]&#39;</span><span class="p">,</span> <span class="s1">&#39;[.*+?()]&#39;</span><span class="p">)</span>  <span class="c1"># 单个长度的元字符</span>
<span class="go">[&#39;.&#39;, &#39;*&#39;, &#39;+&#39;, &#39;?&#39;, &#39;(&#39;, &#39;)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\d]&#39;</span><span class="p">,</span> <span class="s1">&#39;d12</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># \w，\d等在中括号中还是元字符的功能</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]  # 匹配上了数字，而不是反斜杠\和字母d</span>
</pre></div>
</div>
<p>实例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n</span><span class="se">\n\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;\n&#39;]  # 找到了换行符</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n</span><span class="se">\n\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;\n&#39;]  # 找到了换行符</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n</span><span class="se">\n\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;\n&#39;]  # 找到了换行符</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">n&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n</span><span class="se">\n\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;\\n&#39;] # 找到了反斜杠和字母n</span>

<span class="go">``&#39;\\n\n\\&#39;`` 共包含四个字符:</span>
<span class="go">    第一个字符是 \，第二个是字母n，第三个是换行符，第四个是 \</span>

<span class="go">说明:</span>
<span class="go">Actually regex string specified by string literal is processed by two compilers:</span>
<span class="go">1. programming language compiler</span>
<span class="go">2. regexp compiler</span>

<span class="go">Original        Compiled        Regex compiled</span>
<span class="go">&quot;\n&quot;            NL              NL</span>
<span class="go">&quot;\\n&quot;           &#39;\&#39;+&#39;n&#39;         NL</span>
<span class="go">&quot;\\\n&quot;          &#39;\&#39;+NL          NL</span>
<span class="go">&quot;\\\\n&quot;         &#39;\&#39;+&#39;\&#39;+&#39;n&#39;     &#39;\&#39;+&#39;n&#39;</span>

<span class="go">from: https://stackoverflow.com/questions/6967204/how-is-n-and-n-interpreted-by-the-expanded-regular-expression/59192811#59192811</span>

<span class="go">关键: 包含“字符串转义”和“正则转义”两个步骤</span>
</pre></div>
</div>
</section>
</section>
<section id="id21">
<h2><span class="section-number">4.1.7. </span>常见的流派及其特性<a class="headerlink" href="#id21" title="此标题的永久链接">¶</a></h2>
<p>正则表达式主要有两大流派(Flavor):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">POSIX</span> <span class="n">流派</span>
<span class="mf">2.</span> <span class="n">PCRE</span> <span class="n">流派</span>
</pre></div>
</div>
<section id="posix">
<h3>1. POSIX 流派<a class="headerlink" href="#posix" title="此标题的永久链接">¶</a></h3>
<p>POSIX 规范定义了正则表达式的两种标准:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. BRE 标准（Basic Regular Expression 基本正则表达式）
    如:
        vi/vim
        grep、sed使用 -B 选项(默认选项)
2. ERE 标准（Extended Regular Expression 扩展正则表达式）
    如:
        egrep、awk
        grep、sed使用 -E 选项
</pre></div>
</div>
<p>实例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>使用 POSIX ERE 标准
$ grep -E &#39;[[:digit:]]+&#39; access.log
使用 PCRE 标准
$ grep -P &#39;\d+&#39; access.log
</pre></div>
</div>
<p>POSIX 字符组:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[:alnum:] 0-9 A-Z a-z 同w
[:alpha:] A-Z a-z
[:blank:] 空格和tab
[:cntrl:] 代表控制按键，入CR LF tab del等
[:digit:] 0-9
[:graph:] 空格和tab之外
[:lower:] a-z
[:upper:] A-Z
[:space:] 任何会产生空白的字符 空格 tab CR
重要的记住[:alnum:] [:alpha:] [:upper:] [:lower:] [:digit:]即可
</pre></div>
</div>
<figure class="align-default" id="id65">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor4.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor4.png" />
<figcaption>
<p><span class="caption-text">POSIX 字符组: 与 PCRE 流派使用的区别</span><a class="headerlink" href="#id65" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="pcre">
<h3>2. PCRE 流派<a class="headerlink" href="#pcre" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>目前大部分常用编程语言都是源于 PCRE 标准，这个流派显著特征是有 <code class="docutils literal notranslate"><span class="pre">\d、\w、\s</span></code> 这类字符组简记方式。</p>
</div>
<p>虽然 PCRE 流派是与 Perl 正则表达式相兼容的流派，但这种兼容在各种语言和工具中还存在程度上的差别，这包括了直接兼容与间接兼容两种情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 直接兼容
    PCRE 流派中与 Perl 正则表达式直接兼容的语言或工具。
    比如 Perl、PHP  preg、PCRE 库等，一般称之为 Perl 系。
2. 间接兼容
    比如:
        Java 系（包括 Java、Groovy、Scala 等）
        Python 系（包括 Python2 和 Python3）
        JavaScript 系（包括原生 JavaScript 和扩展库 XRegExp）
        .Net 系（包括 C#、VB.Net 等）
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>【兼容问题】即便是直接兼容，也并非完全兼容，还是存在部分不兼容的情况，原因也很简单，Perl 语言中的正则表达式在不断改进和升级之中，其他语言和工具不可能完全做到实时跟进与更新。</p>
</div>
</section>
<section id="id22">
<h3>区别<a class="headerlink" href="#id22" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>【区别1】 <strong>早期</strong> BRE 与 ERE 标准的区别主要在于，BRE 标准不支持量词问号和加号，也不支持多选分支结构管道符。BRE 标准在使用花括号，圆括号时要转义才能表示特殊含义。</p>
</div>
<p>现在 GNU 在实现 POSIX 标准时，做了一定的扩展，主要有以下三点扩展:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. GNU BRE 支持了 +、?，但转义了才表示特殊含义，即需要用 \+、\? 表示
2. GNU BRE 支持管道符多选分支结构，同样需要转义，即用 \| 表示
3. GNU ERE 也支持使用反引用，和 BRE 一样，使用 \1、\2…\9 表示
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>【区别2】 <strong>现在</strong> GNU BRE 和 GNU ERE 它们的功能特性并没有太大区别，区别是在于部分语法层面上，主要是一些字符要不要转义。</p>
</div>
<figure class="align-default" id="id66">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor3.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor3.png" />
<figcaption>
<p><span class="caption-text">BRE 标准和 ERE 标准的详细区别: 浅黄色背景是 BRE 和 ERE 不同的地方，三处天蓝色字体是 GNU 扩展。</span><a class="headerlink" href="#id66" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>【区别3】ERE 和 PCRE 主要区别在于字符组，PCRE 功能更丰富些，比如支持了 环视。</p>
</div>
<figure class="align-default" id="id67">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor1.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor1.png" />
<figcaption>
<p><span class="caption-text">UNIX/LINUX 系统里 PCRE 流派与 POSIX 流派的对比</span><a class="headerlink" href="#id67" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id68">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor2_option.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_Flavor2_option.png" />
<figcaption>
<p><span class="caption-text">-G 是指定使用 BRE 标准（默认），-E 是 ERE 标准，-P 是 PCRE 标准</span><a class="headerlink" href="#id68" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>[实例]使用不同的标准（即 BRE、ERE、PCRE ），来查找含有 ftp、http 或 https 的行:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>内容:
https://time.geekbang.org
ftp://ftp.ncbi.nlm.nih.gov
www.baidu.com
www.ncbi.nlm.nih.gov

命令:
## BRE
$ grep &#39;$f\|ht$tps\?.*&#39; a.txt

## ERE
$ grep -E &#39;(f|ht)tps?.*&#39; a.txt

## PCRE
$ grep -P &#39;(f|ht)tps?.*&#39; a.txt
</pre></div>
</div>
</section>
<section id="id23">
<h3>参考<a class="headerlink" href="#id23" title="此标题的永久链接">¶</a></h3>
<ul class="simple">
<li><p>详细的 Regex cheatsheet: <a class="reference external" href="https://remram44.github.io/regex-cheatsheet/regex.html">https://remram44.github.io/regex-cheatsheet/regex.html</a></p></li>
<li><p>GNU sed 不支持 PCRE，没有 - P 选项,可以考虑使用 perl 命令代替: <a class="reference external" href="https://askubuntu.com/questions/1050693/sed-with-pcre-like-grep-p">https://askubuntu.com/questions/1050693/sed-with-pcre-like-grep-p</a></p></li>
</ul>
</section>
</section>
<section id="unicode">
<h2><span class="section-number">4.1.8. </span>Unicode<a class="headerlink" href="#unicode" title="此标题的永久链接">¶</a></h2>
<ul class="simple">
<li><p>参见 <cite>Unicode 编码</cite></p></li>
</ul>
<section id="id24">
<h3>Unicode 属性<a class="headerlink" href="#id24" title="此标题的永久链接">¶</a></h3>
<p>正则中常用的三种 Unicode 字符集:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 按功能划分的 Unicode Categories（有的也叫 Unicode Property），比如标点符号，数字符号
2. 按连续区间划分的 Unicode Blocks，比如只是中日韩字符
3. 按书写系统划分的 Unicode Scripts，比如汉语中文字符
</pre></div>
</div>
<figure class="align-default" id="id69">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_unicode1.jpeg" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_unicode1.jpeg" />
<figcaption>
<p><span class="caption-text">正则中常用的三种 Unicode 字符集</span><a class="headerlink" href="#id69" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id70">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_unicode2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_unicode2.png" />
<figcaption>
<p><span class="caption-text">在正则中，这三种属性在正则中的表示方式都是 p {属性}。比如，我们可以使用 Unicode Script 来实现查找连续出现的中文。其中，Unicode  Blocks 在不同的语言中记法有差异，比如 Java 需要加上 In 前缀，类似于 p {InBopomofo} 表示注音字符。</span><a class="headerlink" href="#id70" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>参考:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="n">Unicode</span> <span class="n">Property</span>
<span class="o">*</span> <span class="n">Unicode</span> <span class="n">Block</span>
<span class="o">*</span> <span class="n">Unicode</span> <span class="n">Script</span>
</pre></div>
</div>
</section>
<section id="id25">
<h3>表情符号<a class="headerlink" href="#id25" title="此标题的永久链接">¶</a></h3>
<p>表情符号有如下特点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 许多表情不在 BMP 内，码值超过了 FFFF
    使用 UTF-8 编码时:
        普通的 ASCII 是 1 个字节
        中文是 3 个字节
        有一些表情需要 4 个字节来编码
2. 这些表情分散在 BMP 和各个补充平面中
    要想用一个正则来表示所有的表情符号非常麻烦，即便使用编程语言处理也同样很麻烦
3. 一些表情现在支持使用颜色修饰（Fitzpatrick modifiers），可以在 5 种色调之间进行选择
    这样一个表情其实就是 8 个字节了
</pre></div>
</div>
<figure class="align-default" id="id71">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_unicode3_emoji.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_unicode3_emoji.png" />
<figcaption>
<p><span class="caption-text">关于表情颜色修饰的 5 种色调</span><a class="headerlink" href="#id71" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<p>在 <code class="docutils literal notranslate"><span class="pre">ipython3</span></code> 上测试表情颜色修饰的 <code class="docutils literal notranslate"><span class="pre">emoji</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>➜ ipython3
In [1]: &#39;✅&#39;.encode(&#39;utf8&#39;)
Out[1]: b&#39;\xe2\x9c\x85&#39;
In [2]: &#39;☑️&#39;.encode(&#39;utf8&#39;)
Out[2]: b&#39;\xe2\x98\x91\xef\xb8\x8f&#39;
In [4]: &#39;👍︎️&#39;.encode(&#39;utf8&#39;)
Out[4]: b&#39;\xf0\x9f\x91\x8d\xef\xb8\x8e\xef\xb8\x8f&#39;
In [13]: &#39;👍🏻︎️&#39;.encode(&#39;utf8&#39;)    # 注: 这儿不支持这个颜色的修饰
Out[13]: b&#39;\xf0\x9f\x91\x8d\xf0\x9f\x8f\xbb\xef\xb8\x8e\xef\xb8\x8f&#39;
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>而在处理表情时，由于表情比较复杂，我不建议使用正则来处理，更建议使用专用的表情库来处理。</p>
</div>
</section>
</section>
<section id="id26">
<h2><span class="section-number">4.1.9. </span>匹配原理以及优化原则<a class="headerlink" href="#id26" title="此标题的永久链接">¶</a></h2>
<p>有穷自动机的具体实现称为正则引擎，包括:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">DFA</span>
<span class="mf">2.</span> <span class="n">传统的</span> <span class="n">NFA</span>
<span class="mf">3.</span> <span class="n">POSIX</span> <span class="n">NFA</span>
</pre></div>
</div>
</section>
<section id="nfa">
<h2><span class="section-number">4.1.10. </span>NFA 工作机制<a class="headerlink" href="#nfa" title="此标题的永久链接">¶</a></h2>
<p>NFA 引擎的工作方式是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>先看正则，再看文本，而且以正则为主导
</pre></div>
</div>
<section id="id27">
<h3>示例演示1<a class="headerlink" href="#id27" title="此标题的永久链接">¶</a></h3>
<p>示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>字符串：we study on jikeshijian app
正则：jike (zhushou|shijian|shixi)
</pre></div>
</div>
<ol class="arabic">
<li><p>正则中的第一个字符是 j，NFA 引擎在字符串中查找 j，接着匹配其后是否为 i ，如果是 i 则继续，这样一直找到 jike:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
          <span class="o">^</span>
<span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshijian</span> <span class="n">app</span>
                     <span class="o">^</span>
</pre></div>
</div>
</li>
<li><p>再根据正则看文本后面是不是 z，发现不是，此时 zhushou 分支淘汰:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
            <span class="o">^</span>
         <span class="n">淘汰此分支</span> <span class="p">(</span><span class="n">zhushou</span><span class="p">)</span>
<span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshijian</span> <span class="n">app</span>
                      <span class="o">^</span>
</pre></div>
</div>
</li>
<li><p>看其它的分支，看文本部分是不是 s，直到 shijian 整个匹配上:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>说明:
    shijian 在匹配过程中如果不失败，就不会看后面的 shixi 分支。
    当匹配上了 shijian 后，整个文本匹配完毕，也不会再看 shixi 分支
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id28">
<h3>示例演示2<a class="headerlink" href="#id28" title="此标题的永久链接">¶</a></h3>
<p>示例-文本改一下，把 jikeshijian 变成 jikeshixi:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>字符串：we study on jikeshixi app
正则：jike (zhushou|shijian|shixi)
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p>正则 shijian 的 j 匹配不上时 shixi 的 x，会接着使用正则 shixi 来进行匹配，重新从 s 开始（NFA 引擎会记住这里）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">第二个分支匹配失败</span>
<span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
                       <span class="o">^</span>
                  <span class="n">淘汰此分支</span> <span class="p">(</span><span class="n">正则</span> <span class="n">j</span> <span class="n">匹配不上文本</span> <span class="n">x</span><span class="p">)</span>
<span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshixi</span> <span class="n">app</span>
                         <span class="o">^</span>
<span class="n">再次尝试第三个分支</span>
<span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
                            <span class="o">^</span>
<span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshixi</span> <span class="n">app</span>
                      <span class="o">^</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id29">
<h3>总结<a class="headerlink" href="#id29" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>NFA 是以正则为主导，反复测试字符串，这样字符串中同一部分，有可能被反复测试很多次。</p>
</div>
</section>
</section>
<section id="dfa">
<h2><span class="section-number">4.1.11. </span>DFA 工作机制<a class="headerlink" href="#dfa" title="此标题的永久链接">¶</a></h2>
<p>NFA 引擎的工作方式是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>先看文本，再看正则表达式，是以文本为主导的
</pre></div>
</div>
<section id="id30">
<h3>示例演示<a class="headerlink" href="#id30" title="此标题的永久链接">¶</a></h3>
<ol class="arabic">
<li><p>从 we 中的 w 开始依次查找 j，定位到 j ，这个字符后面是 i。所以我们接着看正则部分是否有 i ，如果正则后面是个 i ，那就以同样的方式，匹配到后面的 ke:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshijian</span> <span class="n">app</span>
                     <span class="o">^</span>
<span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
          <span class="o">^</span>
</pre></div>
</div>
</li>
<li><p>文本 e 后面是字符 s ，DFA 接着看正则表达式部分，此时 zhushou 分支被淘汰，开头是 s 的分支 shijian 和 shixi 符合要求:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshijian</span> <span class="n">app</span>
                      <span class="o">^</span>
<span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
            <span class="o">^</span>       <span class="o">^</span>       <span class="o">^</span>
           <span class="n">淘汰</span>     <span class="n">符合</span>    <span class="n">符合</span>
</pre></div>
</div>
</li>
<li><p>依次检查字符串，检测到 shijian 中的 j 时，只有 shijian 分支符合，淘汰 shixi，接着看分别文本后面的 ian，和正则比较，匹配成功:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text</span><span class="p">:</span> <span class="n">we</span> <span class="n">study</span> <span class="n">on</span> <span class="n">jikeshijian</span> <span class="n">app</span>
                         <span class="o">^</span>
<span class="n">regex</span><span class="p">:</span> <span class="n">jike</span><span class="p">(</span><span class="n">zhushou</span><span class="o">|</span><span class="n">shijian</span><span class="o">|</span><span class="n">shixi</span><span class="p">)</span>
                       <span class="o">^</span>       <span class="o">^</span>
                      <span class="n">符合</span>     <span class="n">淘汰</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id31">
<h3>总结<a class="headerlink" href="#id31" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>DFA 和 NFA 两种引擎的工作方式完全不同。NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导，先看文本，再看正则表达式。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>一般来说，DFA 引擎会更快一些，因为整个匹配过程中，字符串只看一遍，不会发生回溯，相同的字符不会被测试两次。也就是说 DFA 引擎执行的时间一般是线性的。DFA 引擎可以确保匹配到可能的最长字符串。但由于 DFA 引擎只包含有限的状态，所以它没有反向引用功能；并且因为它不构造显示扩展，它也不支持捕获子组。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>NFA  以表达式为主导，它的引擎是使用贪心匹配回溯算法实现。NFA  通过构造特定扩展，支持子组和反向引用。但由于 NFA 引擎会发生回溯，即它会对字符串中的同一部分，进行很多次对比。因此，在最坏情况下，它的执行速度可能非常慢。</p>
</div>
</section>
</section>
<section id="posix-nfa">
<h2><span class="section-number">4.1.12. </span>POSIX NFA工作机制<a class="headerlink" href="#posix-nfa" title="此标题的永久链接">¶</a></h2>
<p>POSIX NFA 与 传统 NFA 区别:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>传统的 NFA 引擎 “急于” 报告匹配结果，找到第一个匹配上的就返回了，
所以可能会导致还有更长的匹配未被发现
</pre></div>
</div>
<figure class="align-default" id="id72">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa2.png" />
<figcaption>
<p><span class="caption-text">使用正则 pos|posix 在文本 posix 中进行匹配，传统的 NFA 从文本中找到的是 pos，而不是 posix，而 POSIX NFA 找到的是 posix。</span><a class="headerlink" href="#id72" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>POSIX NFA 的应用很少，主要是 Unix/Linux 中的某些工具。POSIX NFA 引擎与传统的 NFA 引擎类似，但不同之处在于，POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准（“The Longest-Leftmost”）。因此，POSIX NFA 引擎的速度要慢于传统的 NFA 引擎。</p>
</div>
<figure class="align-default" id="id73">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa1.jpeg" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa1.jpeg" />
<figcaption>
<p><span class="caption-text">DFA、传统 NFA 以及 POSIX NFA 引擎的特点总结</span><a class="headerlink" href="#id73" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="id32">
<h2><span class="section-number">4.1.13. </span>回溯<a class="headerlink" href="#id32" title="此标题的永久链接">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>回溯是 NFA 引擎才有的，并且只有在正则中出现量词或多选分支结构时，才可能会发生回溯。</p>
</div>
<section id="id33">
<h3>示例1-简单回溯<a class="headerlink" href="#id33" title="此标题的永久链接">¶</a></h3>
<p>用正则 a+ab 来匹配 文本 aab:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. a+ 是贪婪匹配，会占用掉文本中的两个 a
2. 但正则接着又是 a，文本部分只剩下 b，只能通过回溯，让 a+ 吐出一个 a，再次尝试
</pre></div>
</div>
</section>
<section id="id34">
<h3>示例2-.* 导致大量回溯<a class="headerlink" href="#id34" title="此标题的永久链接">¶</a></h3>
<p>使用 .*ab 去匹配一个比较长的字符串:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.* 会吃掉整个字符串（不考虑换行，假设文本中没有换行）
然后，你会发现正则中还有 ab 没匹配到内容，只能将 .* 匹配上的字符串吐出一个字符，再尝试
还不行，再吐出一个，不断尝试
</pre></div>
</div>
<figure class="align-default" id="id74">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa3.jpeg" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa3.jpeg" />
<figcaption>
<p><span class="caption-text">示例2演示</span><a class="headerlink" href="#id74" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>要尽量不用 .*  ，除非真的有必要，因为点能匹配的范围太广了，我们要尽可能精确。常见的解决方式有两种，比如要提取引号中的内容时，使用 “[^”]+”，或者使用非贪婪的方式 “.+?”，来减少 “匹配上的内容不断吐出，再次尝试” 的过程。</p>
</div>
</section>
<section id="id35">
<h3>示例3-店名匹配<a class="headerlink" href="#id35" title="此标题的永久链接">¶</a></h3>
<p>店名可以出现下面这些组合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 英文字母大小写
2. 数字
3. 越南文
4. 一些特殊字符，如 “&amp;”，“-”，“_” 等
</pre></div>
</div>
<p>正则表达:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">^</span><span class="p">([</span><span class="n">A</span><span class="o">-</span><span class="n">Za</span><span class="o">-</span><span class="n">z0</span><span class="o">-</span><span class="mf">9.</span><span class="n">_</span><span class="p">()</span><span class="o">&amp;</span><span class="s1">&#39;\- ]|[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$</span>
</pre></div>
</div>
<p>测试字符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">cat</span><span class="p">,</span> <span class="n">cat</span>
</pre></div>
</div>
<figure class="align-default" id="id75">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa4.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa4.png" />
<figcaption>
<p><span class="caption-text">一个很短的字符串，NFA 引擎尝试步骤达到了 9021 次，由于是贪婪匹配，第一个分支能匹配上 this is a cat 部分，接着后面的逗号匹配失败，使用第二个分支匹配，再次失败，此时贪婪匹配部分结束。NFA 引擎接着用正则后面的 $ 来进行匹配，但此处不是文本结尾，匹配不上，发生回溯，吐出第一个分支匹配上的 t，使用第二个分支匹配 t 再试，还是匹配不上。继续回溯，第二个分支匹配上的 t 吐出，第一个分支匹配上的 a 也吐出，再用第二个分支匹配 a 再试，如此发生了大量的回溯。</span><a class="headerlink" href="#id75" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
<section id="id36">
<h3>示例3-店名匹配(优化版)<a class="headerlink" href="#id36" title="此标题的永久链接">¶</a></h3>
<p>第一个分支中的 A-Za-z 去掉，因为后面多选分支结构中重复了:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">^</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mf">9.</span><span class="n">_</span><span class="p">()</span><span class="o">&amp;</span><span class="s1">&#39;\- ]|[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$</span>
</pre></div>
</div>
<figure class="align-default" id="id76">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa5.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa5.png" />
<figcaption>
<p><span class="caption-text">这样优化后只尝试匹配了 57 次就结束了</span><a class="headerlink" href="#id76" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>【结论】一定要记住，不要在多选择分支中，出现重复的元素。即：“回溯不可怕，我们要尽量减少回溯后的判断”</p>
</div>
</section>
<section id="id37">
<h3>示例3-店名匹配(独占模式优化版)<a class="headerlink" href="#id37" title="此标题的永久链接">¶</a></h3>
<p>说明:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>独占模式可以理解为贪婪模式的一种优化，
它也会发生广义的回溯，但它不会吐出已经匹配上的字符。
</pre></div>
</div>
<figure class="align-default" id="id77">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa5.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa5.png" />
<figcaption>
<p><span class="caption-text">独占模式匹配到英文逗号那儿，不会吐出已经匹配上的字符，匹配就失败了，所以采用独占模式也能解决性能问题</span><a class="headerlink" href="#id77" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>独占模式 “不吐出已匹配字符” 的特性，会使得一些场景不能使用它。另外，只有少数编程语言支持独占模式。</p>
</div>
</section>
<section id="id38">
<h3>示例3-店名匹配(其他优化版)<a class="headerlink" href="#id38" title="此标题的永久链接">¶</a></h3>
<figure class="align-default" id="id78">
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa6.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_dfa_nfa6.png" />
<figcaption>
<p><span class="caption-text">移除多选分支选择结构，直接用中括号表示多选一</span><a class="headerlink" href="#id78" title="此图像的永久链接">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="id39">
<h2><span class="section-number">4.1.14. </span>正则调试<a class="headerlink" href="#id39" title="此标题的永久链接">¶</a></h2>
<section id="regex101-comregex-debugger">
<h3>regex101.com的Regex Debugger<a class="headerlink" href="#regex101-comregex-debugger" title="此标题的永久链接">¶</a></h3>
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_debug1.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_debug1.png" />
<img alt="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_debug2.png" src="https://img.zhaoweiguo.com/knowledge/images/regexps/regexp_debug2.png" />
</section>
</section>
<section id="id40">
<h2><span class="section-number">4.1.15. </span>正则优化<a class="headerlink" href="#id40" title="此标题的永久链接">¶</a></h2>
<section id="id41">
<h3>1. 测试性能的方法<a class="headerlink" href="#id41" title="此标题的永久链接">¶</a></h3>
<ol class="arabic">
<li><p>用 ipython 来测试正则的性能:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>In [1]: import re
In [2]: x = &#39;-&#39; * 1000000 + &#39;abc&#39;
In [3]: timeit re.search(&#39;abc&#39;, x)
480 µs ± 8.06 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
</li>
<li><p>regex101.com 查看正则和文本匹配的次数</p></li>
</ol>
</section>
<section id="id42">
<h3>2. 提前编译好正则<a class="headerlink" href="#id42" title="此标题的永久链接">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。</p>
</div>
</section>
<section id="id43">
<h3>3. 尽量准确表示匹配范围<a class="headerlink" href="#id43" title="此标题的永久链接">¶</a></h3>
<p>要匹配引号里面的内容，除了写成 “.+?” 之外，我们可以写成 “[^”]+”。使用 [^”] 要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题。</p>
</section>
<section id="id44">
<h3>4. 提取出公共部分<a class="headerlink" href="#id44" title="此标题的永久链接">¶</a></h3>
<p>因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(abcd|abxy) 这样的表达式，可以优化成 ab(cd|xy)

th(?:is|at) 要比 this|that 要快
^th(is|at) is 要比 (^this|^that) is 好
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>但从可读性上看，后者要好一些，这个就需要用的时候去权衡，也可以添加代码注释让代码更容易理解。</p>
</div>
</section>
<section id="id45">
<h3>5. 出现可能性大的放左边<a class="headerlink" href="#id45" title="此标题的永久链接">¶</a></h3>
<p>正则是从左到右看的，把出现概率大的放左边:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\.(?:com|net)\b 要比 \.(?:net|com)\b 好
</pre></div>
</div>
</section>
<section id="id46">
<h3>6. 只在必要时才使用子组<a class="headerlink" href="#id46" title="此标题的永久链接">¶</a></h3>
<p>在正则中，括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能。</p>
</section>
<section id="id47">
<h3>7. 警惕嵌套的子组重复<a class="headerlink" href="#id47" title="此标题的永久链接">¶</a></h3>
<p>如果一个组里面包含重复，接着这个组整体也可以重复，比如 (.*)* 这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则。</p>
</section>
<section id="id48">
<h3>8. 避免不同分支重复匹配<a class="headerlink" href="#id48" title="此标题的永久链接">¶</a></h3>
<p>在多选分支选择中，要避免不同分支出现相同范围的情况</p>
</section>
</section>
<section id="id49">
<h2><span class="section-number">4.1.16. </span>语系对正则表达式的影响<a class="headerlink" href="#id49" title="此标题的永久链接">¶</a></h2>
<p>在linux下执行正则表达式，要考虑语系环境所带来的影响，LANG=C和LANG=zh_CN.gb2312时，[a-z]所选取的范围是不同的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>LANG=C，使用ascii编码，a-z表示的就是a-z，字母排列方式是A,B,C,D……Z 然后a,b,c,d……z
LANG=zh_CN.gb2312，使用的是gb2312语系，排列方式为： a,A,b,B,c,C……z,Z
</pre></div>
</div>
</section>
<section id="id50">
<h2><span class="section-number">4.1.17. </span>参考<a class="headerlink" href="#id50" title="此标题的永久链接">¶</a></h2>
<ul class="simple">
<li><p>[工具]正则测试: <a class="reference external" href="https://regex101.com/r/PnzZ4k/1">https://regex101.com/r/PnzZ4k/1</a></p></li>
<li><p>[工具]Regexper: <a class="reference external" href="https://regexper.com/">https://regexper.com/</a></p></li>
</ul>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://regex101.com/">https://regex101.com/</a> （老师用的）</p></li>
<li><p><a class="reference external" href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></p></li>
<li><p><a class="reference external" href="http://tool.chinaz.com/regex/">http://tool.chinaz.com/regex/</a></p></li>
<li><p><a class="reference external" href="https://www.w3cschool.cn/tools/index?name=re">https://www.w3cschool.cn/tools/index?name=re</a></p></li>
<li><p><a class="reference external" href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></p></li>
<li><p><a class="reference external" href="http://tools.haokh.net/Regex">http://tools.haokh.net/Regex</a></p></li>
<li><p>Windows 上推荐：RegexBuddy</p></li>
<li><p>Mac 上推荐：Expressions</p></li>
</ol>
<ul class="simple">
<li><p>Python - Regular Expressions: <a class="reference external" href="http://www.tutorialspoint.com/python/python_reg_expressions.htm">http://www.tutorialspoint.com/python/python_reg_expressions.htm</a></p></li>
<li><p>正则基础之 ——NFA 引擎匹配原理: <a class="reference external" href="https://blog.csdn.net/lxcnn/article/details/4304651">https://blog.csdn.net/lxcnn/article/details/4304651</a></p></li>
</ul>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference external" href="/index.html">主页</a></p></td>
<td><p><a class="reference internal" href="../genindex.html"><span class="std std-ref">索引</span></a></p></td>
<td><p><a class="reference internal" href="../py-modindex.html"><span class="std std-ref">模块索引</span></a></p></td>
<td><p><a class="reference internal" href="../search.html"><span class="std std-ref">搜索页面</span></a></p></td>
</tr>
</tbody>
</table>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lang.html" class="btn btn-neutral float-right" title="4.2. 语言" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../regexp.html" class="btn btn-neutral" title="4. 正则表达式" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>
  
  <div id="gitalk-container"></div>
  <div role="contentinfo">
    <p>
        &copy; Copyright 2010-2025, 新溪-gordon.

    </p>
  </div>
  <div>备案号 <a href="http://www.beian.miit.gov.cn">京ICP备16018553号</a></div><div>Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a></div>. 


</footer>

<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?042289284b8eb33866001347a3e0b129";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>     
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'V2025.07',
            LANGUAGE:'zh-CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
      <script type="text/javascript" src="../_static/clipboard.min.js"></script>
      <script type="text/javascript" src="../_static/copybutton.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });


      // var gitalk = new Gitalk({
      //         clientID: '565177626b5d46427009',
      //         clientSecret: 'b2a36e67e1d2a73e43667f46d571c2624f8e1026',
      //         repo: 'knowledge',
      //         owner: 'zhaoweiguo',
      //         admin: ['zhaoweiguo'],
      //         id: location.pathname,      // Ensure uniqueness and length less than 50
      //         distractionFreeMode: false  // Facebook-like distraction free mode
      //       })
      // gitalk.render('gitalk-container')

  </script>


<script type="text/javascript" src="../_static/js/table-of-contents-sidebar.js"></script>
<!-- <script type="text/javascript" src="https://table-of-contents-sidebar.github.io/table-of-contents-sidebar-lib/table-of-contents-sidebar.js"></script> -->
<script type="text/javascript">
    window.onload = function(e){
        TableOfContents.init({
            basePath: "https://table-of-contents-sidebar.github.io/table-of-contents-sidebar-lib/",
            querySelector: "body" // or other css querySelector
        });
    }
</script> 

</body>
</html>