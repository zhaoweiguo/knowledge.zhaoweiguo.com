.. _vmstat:

vmstat命令使用
====================

使用实例及解析::

    procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
     0  0 1290784 126076 109276 880080    1    1    10    41   13   16  5 12 82  2
     0  0 1290784 121092 109284 885548    0    0     0    28 9530 3442  3 24 72  2
     0  0 1290784 120368 109284 885932    0    0     0     0 9201 3640  6 18 77  0
     1  0 1290784 116276 109284 890076    0    0     0    20 9181 5791 10 24 67  0


命令内容介绍

* Procs::

   r
   运行的和等待(CPU时间片)运行的进程数，这个值也可以判断是否需要增加CPU(长期大于1)
   b
   处于不可中断状态的进程数，常见的情况是由IO引起的

* Memory::

   swpd
   切换到交换内存上的内存(默认以KB为单位).如果 swpd 的值不为0，或者还比较大，比如超过100M了，但是 si, so 的值长期为 0，这种情况我们可以不用担心，不会影响系统性能

   free
   空闲的物理内存

   buff
   作为buffer cache的内存，对块设备的读写进行缓冲

   cache
   作为page cache的内存, 文件系统的cache作为page cache的内存, 文件系统的cache. 如果 cache 的值大的时候，说明cache住的文件数多，如果频繁访问到的文件都能被cache住，那么磁盘的读IO bi 会非常小

* Swap::

    si
    交换内存使用，由磁盘调入内存 

    so
    交换内存使用,由内存调入磁盘. 内存够用的时候,这2个值都是0,如果这2个值长期大于0时,系统性能会受到影响。磁盘IO和CPU资源都会被消耗。我发现有些朋友看到空闲内存(free)很少或接近于0时,就认为内存不够用了,实际上不能光看这一点的,还要结合si,so, **如果free很少，但是si,so也很少(大多时候是0)，那么不用担心** ，系统性能这时不会受到影响的

* Io::

    bi
    从块设备读入的数据总量(读磁盘) (KB/s)

    bo
    写入到块设备的数据总理(写磁盘) (KB/s). 随机磁盘读写的时候，这2个值越大(如超出1M)，能看到CPU在IO等待的值也会越大

* System::

    in
    每秒产生的中断次数

    cs
    每秒产生的上下文切换次数. 上面这2个值越大，会看到由内核消耗的CPU时间会越多

* Cpu::

    us
    用户进程消耗的CPU时间百分比. us 的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超过50% 的使用，那么我们就该考虑优化程序算法或者进行加速了(比如 PHP/Perl)

    sy
    内核进程消耗的CPU时间百分比. sy 的值高时，说明系统内核消耗的CPU资源多，这并不是良性的表现，我们应该检查原因

    wa
    IO等待消耗的CPU时间百分比. wa 的值高时，说明IO等待比较严重，这可能是由于磁盘大量作随机访问造成，也有可能是磁盘的带宽出现瓶颈(块操作)。

    id
    CPU处在空闲状态时间百分比


实例分析

* 实例::

    vmstat 1 20 #取前20条数据


vmstat的输出值得关注的信息::

    Procs r: 运行的进程比较多，系统很繁忙
    Io bo: 磁盘写的数据量稍大，如果是大文件的写，10M以内基本不用担心，如果是小文件写2M以内基本正常
    Cpu us: 持续大于50，服务高峰期可以接受
    Cpu wa: 稍微有些高
    Cpu id:持续小于50，服务高峰期可以接受



