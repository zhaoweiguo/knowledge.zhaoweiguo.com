里式替换原则-LSP
################

* Liskov Substitution Principle

.. note:: If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program——1986 年由 Barbara Liskov 提出。Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it——1996 年，Robert Martin 在他的 SOLID 原则中，重新描述了这个原则



子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。


几个违反里式替换原则的例子::

    1. 子类违背父类声明要实现的功能
        如父类排序函数是按字母从小到大，则子类就也必须是从小到大
    2. 子类违背父类对输入、输出、异常的约定
        父类某个函数约定：运行出错的时候返回 null，则子类返回异常就不符合里式替换原则
        父类抛出 A 异常，则子类也要抛出 A 异常
    3. 子类违背父类注释中所罗列的任何特殊说明
        父类注释写「用户提现金额不能超过余额」，子类重写时针对 vip 用户透支提现就不符合里式替换

    小窍门:
      用父类的单元测试去验证子类的代码。
      如果某些单元测试运行失败，就有可能说明子类违背里式替换原则

.. note:: 理解里式替换原则，最核心的就是理解 “design by contract，按照协议来设计”

LSP 的意义::

    1. 改进已有实现
        例如程序最开始实现时采用了低效的排序算法，改进时使用 LSP 实现更高效的排序算法
    2. 指导程序开发
        告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合 contract
    3. 改进抽象设计
        如果一个子类中的实现违反了 LSP，那么是不是考虑抽象或者设计出了问题



与多态的区别
============

.. note:: 虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。







参考
====

* Liskov 是美国历史上第一个女计算机博士，曾获得过图灵奖: https://en.wikipedia.org/wiki/Barbara_Liskov







