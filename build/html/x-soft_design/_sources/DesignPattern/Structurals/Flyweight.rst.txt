Flyweight-享元模式
##################


.. note:: reduces the cost of creating and manipulating a large number of similar objects.“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。


.. note:: 当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。


.. note:: 它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。




享元模式 vs 单例/缓存/对象池
============================

享元模式 vs 单例::

    1. 代码实现
      在单例模式中，一个类只能创建一个对象
      在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享
    2. 设计意图
      尽管从代码实现上来看，享元模式和多例有很多相似之处，
      但从设计意图上来看，它们是完全不同的。
      应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。

享元模式 vs 对象池::

    对象池: 为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间
    池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）
    享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。





