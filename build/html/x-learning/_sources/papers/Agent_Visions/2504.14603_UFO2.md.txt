# 2504.14603_UFO2: The Desktop AgentOS

* [https://arxiv.org/abs/2504.14603](https://arxiv.org/abs/2504.14603)
* 官网: [https://microsoft.github.io/UFO/](https://microsoft.github.io/UFO/)
* GitHub: [https://github.com/microsoft/UFO](https://github.com/microsoft/UFO)
* 组织: Microsoft
* 引用: 9(2025-06-27)
* Keywords: Computer Using Agent, Desktop Automation, Windows System

## Abstract

* 目前的“计算机操作智能体（CUAs）”可以用自然语言自动执行电脑上的复杂操作，但大多仍停留在概念阶段，存在与操作系统整合不深、交互方式脆弱（比如靠截图）、操作容易中断等问题。
* 本文提出了 **UFO2**，一个在 Windows 上运行的多智能体系统（AgentOS），让这些智能体真正实用起来。
* 它包括：
    * 一个负责任务分解与协调的 **HostAgent**；
    * 多个针对不同应用的软件智能体 **AppAgents**，它们使用原生 API 和图形界面操作；
    * 结合视觉识别与 Windows UI 自动化，能识别多种界面风格；
    * 通过“多步预测”减少大模型的响应时间；
    * 使用“画中画”界面，允许用户和智能体同时操作，不互相干扰。
* 在超过 20 个真实 Windows 应用中测试显示，UFO2 在稳定性和执行准确性上远超以往方法，说明深度整合操作系统是实现可靠桌面自动化的关键路径。


![](https://img.zhaoweiguo.com/uPic/2025/06/ZgYKDx.png)

Figure 1.A comparison of (a) existing CUAs and (b) desktop AgentOS UFO2.


## 1.Introduction

### **传统RPA的局限：**

* 以前的桌面自动化（比如 UiPath、Power Automate）主要依赖固定脚本模拟鼠标键盘操作。
* 这种方式很脆弱，一旦界面变动就容易出错，维护成本高、扩展性差。


### **CUA的兴起与问题：**
* 新一代“计算机代理”（CUAs）借助大模型理解指令和界面，可以更灵活地执行操作。
* 但它们目前主要还是实验性质，缺乏对操作系统底层和应用程序内部的深度整合，执行效率和稳定性有限。


### **UFO2 的创新：**
* UFO2 是一种“AgentOS”，也就是深度嵌入Windows系统的自动化操作系统，具有以下特点：
    1. **多代理架构**：由一个主代理（HostAgent）协调多个针对不同应用的子代理（AppAgents）。
    2. **混合控制方式**：结合图像识别+Windows原生API，提高识别准确率和操作稳定性。
    3. **统一执行接口**：同时支持模拟GUI操作和直接调用API，灵活高效。
    4. **持续学习机制**：集成历史执行记录和文档作为知识库，不需要频繁训练也能变聪明。
    5. **提前预测动作序列**：减少大模型的推理开销。
    6. **不干扰用户的PiP界面**：在独立的虚拟桌面中执行任务，不影响用户正常使用电脑。
    7. **实测效果显著**：在20多个真实应用中表现优于现有方案10%以上。

### **总结：**
* UFO2 通过系统级深度集成和架构设计，把桌面自动化从“脚本堆砌”升级为“操作系统级智能控制”。


## 2.Background

### 传统桌面自动化的问题

* 过去几十年，桌面自动化依赖“录屏+回放”的方式，比如录鼠标、键盘操作，或者使用固定规则脚本。
* 这些方式很脆弱：只要界面按钮改一下位置或名字，自动化就会失效，还需要人工频繁维护。
* 这类方法不懂应用的实际逻辑，只能执行简单重复的任务，无法适应变化。

### 新趋势：用大模型驱动的“电脑代理人（CUA）”

* 近年来，大语言模型（LLMs）和多模态技术的发展让自动化进入了新阶段。
* 新的“电脑代理人（CUA）”可以看懂图形界面，理解自然语言指令，然后自主点击、输入操作，而不需要手工写脚本。
* 比如 Claude-3.5 和 OpenAI Operator 就可以跨多个应用自动完成复杂任务。
* 不过，这些新系统目前还多是研究原型，离真正实用还有距离。


### 当前 CUA 的三大问题

1. **没深度接入操作系统**：
    * 它们大多通过截图、模拟鼠标键盘控制界面，而不是用操作系统提供的正式接口（比如 accessibility API 或 shell 命令），所以效率低，稳定性差。
2. **不了解具体应用的内部逻辑**：
    * CUA 把每个应用都当黑盒，不会利用应用自己的 API 或文档，这让它们难以执行更复杂或抽象的任务。
3. **执行方式打扰用户且不安全**：
    * CUA 是直接操作真实桌面，期间用户无法操作电脑，也容易出现干扰甚至风险。

### 根本问题：操作系统缺乏“自动化”这个基础能力

* 现在的操作系统没有为自动化任务提供“系统级支持”。
* 不像文件、进程、网络有标准接口，GUI 界面完全是黑盒。
* 所以不论是旧的 RPA 还是新的 CUA 都只能“贴着表面做事”。


### 解决方案：UFO2 / AgentOS

* 这篇论文提出一个新的操作系统框架 **UFO2**，也叫 **AgentOS**，把自动化能力变成操作系统的“内建功能”。
* 它让代理人可以用标准方式读取界面结构、调用应用 API、协调任务，实现安全、高效、通用的自动化。


## 3.System Design of UFO2

![](https://img.zhaoweiguo.com/uPic/2025/06/n5y1rn.png)

Figure 2.An overview of the architecture of UFO2.



### 3.1. UFO2 as a System Substrate for Automation

* **UFO2 是一个运行在 Windows 桌面的自动化系统平台**，它可以让用户用自然语言发出请求，系统再自动操作多个图形界面应用程序完成任务。
* 它的核心结构分为两个部分：
    1. **HostAgent（主控代理）**：像“大脑”，负责理解用户意图，把请求拆分成子任务，并分发给对应的应用处理模块。
    2. **AppAgents（应用代理）**：每个代理对应一个应用（如 Excel、Outlook），负责操作和观察该应用，使用视觉识别和 API 控制应用执行子任务。
* 这些模块之间通过一种“黑板”机制共享信息，比如中间结果和执行状态。这种架构让多个应用之间协同工作变得容易，比如从 Excel 中提取数据并填入网页表单。
* 所有操作都在一个虚拟桌面中进行，保证各应用间隔离、运行安全。
* 最后，UFO2 的模块化设计也方便开发者增加新应用的支持，使系统易扩展、可维护。


### 3.2. HostAgent: System-Level Orchestration and Execution Control

![](https://img.zhaoweiguo.com/uPic/2025/06/PJ5YRb.png)

Figure 3.High-level architecture of HostAgent as a control-plane orchestrator.

#### 它主要做什么？

1. **理解任务并拆解**：把用户输入的自然语言任务转化为有依赖关系的子任务图。
2. **管理应用程序生命周期**：判断相关程序是否运行，如果没有则自动打开。
3. **启动子代理 AppAgent**：为每个应用程序生成对应的执行代理，赋予它任务上下文和工具。
4. **调度与控制**：用一个状态机管理整个任务执行过程，控制执行顺序、出错恢复等。
5. **共享信息**：通过一个“黑板”机制让多个 AppAgent 共享状态、互相通信。
6. **系统感知能力**：通过屏幕截图（视觉层）+ 系统 API（语义层）理解当前桌面环境。
7. **输出结构化信息**：包括子任务计划、命令行调用、分配的应用、代理指令、用户提示等。


#### 怎么控制执行流程？

* 它用一个\*\*有限状态机（FSM）\*\*来控制任务状态，包括：
    * **CONTINUE**：检查要执行的任务
    * **ASSIGN**：选择程序并生成代理
    * **PENDING**：等待用户进一步输入
    * **FINISH**：任务完成，清理状态
    * **FAIL**：出错处理或终止任务

![](https://img.zhaoweiguo.com/uPic/2025/06/FQyw5a.png)

Figure 4.Control-state transitions managed by HostAgent.


#### 怎么管理记忆？

* 分为两种：
    * **私有状态**：记录当前用户任务、执行进度等（给自己用）
    * **共享黑板**：记录所有代理都能看到的状态信息（大家共享）

#### 它的作用总结：

* HostAgent 统一管理和协调多个桌面应用程序间的协同工作，使复杂任务自动化变得可行、可靠、可扩展。



### 3.3. AppAgent: Application-Specialized Execution Runtime

![](https://img.zhaoweiguo.com/uPic/2025/06/Byhsiw.png)

Figure 5.Architecture of an AppAgent, the per-application execution runtime in UFO2.

#### 什么是 AppAgent？

AppAgent 是 UFO2 中专门为某一个 Windows 应用设计的“智能执行单元”，负责执行这个应用内的具体子任务。


#### AppAgent 的核心特点：

1. **每个 AppAgent 只负责一个特定应用**，不像通用 GUI 代理那样“一把梭”，而是“专精专用”。
2. 由一个上层调度器 HostAgent 启动和管理。
3. 使用 ReAct（感知-推理-执行）循环来完成任务。


#### 它是怎么工作的？

##### 感知层：

* AppAgent 获取应用的多种信息来理解当前状态，包括：
    * **截图**：获取应用界面布局。
    * **UI 元数据**：通过系统 API 拿到控件类型、状态等信息。
    * **符号注释**：在截图上标注控件，方便识别。
* 这些信息融合成一个结构化的“观察对象”。

#### 输出层：

* 基于感知结果，AppAgent 生成：
    * 要操作的控件
    * 操作类型（比如点击、输入、调用 API）
    * 操作参数
    * 推理过程的记录（思维链 CoT）
    * 当前状态（用于状态机）

#### 执行控制（状态机）：

* AppAgent 有一个本地状态机控制流程，包含几种状态：
    * **CONTINUE**：正常执行
    * **PENDING**：危险操作前需要用户确认
    * **FINISH**：任务完成
    * **FAIL**：出错（比如程序崩溃）
* 这个设计让任务失败不会影响整个系统。

![](https://img.zhaoweiguo.com/uPic/2025/06/xTyG1N.png)

Figure 6.Control-state transitions for an AppAgent runtime.


#### 记忆与共享状态：

* 每个 AppAgent 维护：
    * **私有记忆**：记录自己做了什么
    * **共享记忆**：向整个系统汇报信息，比如错误、输出等
* 这样既能独立运行，又能和系统配合。

#### 可扩展性：

* UFO2 提供 SDK，方便为新应用快速开发 AppAgent。开发者可以：
    * 注册 API
    * 定义参数和提示词
    * 加入帮助文档供查询
* 不需要重新训练模型，只更新插件即可。


### 总结：

* AppAgent 是 UFO2 的“分布式大脑”，每个专门控制一个应用，拥有强大的感知、推理、执行和记忆能力。
* 它比传统 GUI 代理更专业、更安全、更容易扩展。





### 3.4. Hybrid Control Detection

* 这段内容讲的是 **UFO2 系统中如何检测图形界面（GUI）中的控件**，以便智能体（AppAgent）能可靠地操作应用程序界面。

![](https://img.zhaoweiguo.com/uPic/2025/06/zmoJve.png)

Figure 7.The hybrid control detection approach employed in UFO2.


1. **背景问题**：
    * 有些应用的界面控件可以通过标准的 Windows 接口（UIA）获取信息，但很多旧应用或自定义界面不支持这种方式，只能靠“看图”识别控件。

2. **解决方案：混合检测机制**
    * UFO2 同时使用两种方法检测控件：
        * **UIA 检测层**：用标准 API 获取界面控件的信息（比如类型、标签、位置），构建控件图。
        * **视觉检测层**：对于无法通过 UIA 获取的控件，用图像识别模型（OmniParser-v2）来识别截图中的按钮等控件，补充信息。

3. **融合去重**：
      * 如果视觉检测到的控件和 UIA 检测的控件有 10% 以上重叠（IoU > 10%），就认为是重复，丢弃视觉结果。
      * 剩下的视觉控件被包装成“伪UIA控件”，和 UIA 的结果整合在一起。

4. **最终目的**：
    * 构建一个完整的控件图，不管控件是通过 API 还是视觉识别得到的，AppAgent 都能用统一方式访问和操作。

### 3.5. Unified GUI–API Action Orchestrator

![](https://img.zhaoweiguo.com/uPic/2025/06/0YSU5A.png)

Figure 8.Puppeteer serves as a unified execution engine that harmonizes GUI actions and native API calls.


* **核心思想：**
    * 让智能代理 AppAgent 执行任务时能在两种方式中选择——
        * GUI 操作（比如模拟点击按钮）
        * 原生 API 调用（比如直接调用 Excel 内部接口）

* **关键点：**
    * GUI 通用但脆弱；API 稳定但需要手动对接。
    * **Puppeteer** 作为统一调度器，根据实际情况决定用哪种方式执行操作。
    * 比如，在 Excel 中选择一段表格，如果用 GUI 要点很多次；但用 API 一步搞定，更快也更稳定。
    * 如果 API 出错，就自动回退用 GUI。
    * 开发者可以用 Python 装饰器暴露 API 给 Puppeteer 使用。



### 3.6. Continuous Knowledge Integration Substrate

![](https://img.zhaoweiguo.com/uPic/2025/06/2E2olv.png)

Figure 10.Overview of the knowledge substrate in UFO2, combining static documentation with dynamic execution history.


* **核心思想：**
    * 结合“文档 + 历史经验”，持续增强 Agent 对各种应用的理解，不用重训练。

* **包含两个来源：**
    1. **从文档中引导：**
        * 自动解析软件说明文档、帮助文档，存入数据库，任务执行时调用它们做参考。
    2. **从经验中学习：**
        * 每次操作都会记录执行日志，后续可以从成功的例子中提取操作步骤作为经验，遇到相似任务时就能参考。

* **系统特性：**
    * 类似“操作系统级的知识缓存层”，以向量方式索引文档和经验。
    * 运行时支持“检索增强生成”（RAG），快速找资料。
    * 支持版本管理，软件更新后知识库也能随之演进。


### 3.7. Speculative Multi-Action Execution

* **核心思想：**
    * 一次调用大模型，预测一整批后续操作，然后逐步验证和执行。

* **执行流程：**
    1. **预测多个操作：** 一次 LLM 调用预测多个可能的下一步。
    2. **运行时检查：** 使用系统 API（比如 Windows UIA）确保按钮等控件还存在且可用。
    3. **按顺序执行：** 验证通过就执行；一旦有控件失效就立刻停止，重新规划。

* **优点：**
    * 大幅减少 LLM 推理次数 → 提升效率
    * 用系统 API 验证控件 → 更加稳定可靠（不靠图像识别）
    * 即使界面变化，也能安全回退


## 4.Picture-in-Picture Interface

* UFO2 系统引入了一个 **画中画（Picture-in-Picture, PiP）界面**，用于在不打扰用户操作的情况下执行自动化任务。

### ✅ 为什么要用 PiP？

* 传统的自动化工具会“抢占”用户电脑（比如鼠标键盘），用户在自动化运行时无法做其他事情。
* PiP 的设计目标是：**后台高效自动化 + 前台用户照常使用电脑**。


### ✅ PiP 是什么？

* 是一个小窗口，里面运行的是一个虚拟桌面（看起来像你电脑的另一个桌面）。
* 自动化任务在这个虚拟桌面里运行，不会干扰真实桌面。
* 用户可以自由移动、最小化这个窗口，继续用自己的电脑干别的事。


### ✅ 技术怎么实现？

* 利用了 Windows 的 RDP（远程桌面）循环机制，在本机开启一个独立会话。
* 自动化任务在这个隔离环境中运行，用户信息、网络环境保持一致，但**输入（鼠标键盘）和窗口控制完全隔离**。


### ✅ 有什么好处？

* 用户操作和自动化任务互不干扰。
* 自动化失败时不会影响真实桌面。
* 系统通过安全的通信机制（Windows Named Pipes）让 PiP 和主系统可以双向通信，进行任务分配、状态同步等。
* 提高了系统的可用性、安全性和扩展性。

### 总结

* PiP 就是一个隔离的小窗口，用来安全地跑自动化任务，用户依然可以正常使用电脑，互不干扰。


## 5.Implementation and Specialized Engineering Design


1. **整体架构**
    * 用Python做核心逻辑和代理控制，
    * C#做图形界面和Windows特定功能，
    * 结合Sentence Transformers实现文档和经验检索。
2. **多轮任务执行**
    * 支持会话式、多轮交互，能记忆上下文和任务状态，方便用户动态调整和监督任务，提升复杂任务完成度。
3. **安全保护机制**
    * 对潜在危险操作（删文件、关闭应用等）主动拦截，暂停执行并请求用户确认，防止误操作带来损失，可根据需求自定义风险规则。
4. **AppAgent机制**
    * 所有功能模块都以“代理”形式封装，支持第三方组件快速接入，实现统一管理和调度，提升系统扩展性。
5. **客户端-服务器部署**
    * 轻量客户端负责界面和感知，
    * 服务器集中处理逻辑和模型请求，增强安全性、可维护性和扩展能力。
6. **日志与调试系统**
    * 详细记录每步操作和状态，生成结构化日志，方便开发者复盘、调试和改进。

7. **自动任务评估**
    * 基于大语言模型自动分析执行过程，给出任务成功度评分，支持自我监控和持续优化。


总结来说，UFO2通过模块化设计、多轮交互、安全控制、服务化部署和完善的调试评估机制，实现了一个稳定、灵活且可扩展的桌面自动化智能代理系统。


## 6.Evaluation

1. **任务完成率提升**：比目前最强的桌面智能体（Operator）高出 10%，相对提升 50%。
2. **识别更多元素**：结合 UI 自动化 (UIA) 和视觉识别，可识别一些定制组件，UIA 单独做不到。
3. **用原生 API 提升成功率**：允许调用应用原生 API，成功率提升 8%，还更快更稳定。
4. **善用外部文档**：利用外部说明文档和执行日志，不用再训练也能应对新任务。
5. **一步多操作**：合并多步操作为一步 LLM 推理，节省最多 51.5% 推理成本。
6. **一切皆 Agent**：把每个应用都视为独立 Agent，使整体更高效，组件潜能充分释放。

> 结论：UFO2 通过深度集成 Windows 和应用 API，显著提高了桌面自动化效果，是原生桌面自动化方向的有力方案。


### 6.1 Experimental Setup


* **测试环境**：使用配有 AMD Ryzen 7 + 8GB 内存的虚拟机，图像模型运行在 NVIDIA A100 上。
* **测试基准**：
    * **WAA**：154 个真实任务，涵盖 15 个常用 Windows 应用。
    * **OSWorld-W**：49 个任务，聚焦 Office、浏览器、文件管理。
* **对比模型**：
    * UFO（旧版）
    * NAVI（截图+UIA）
    * OmniAgent（视觉模型+GPT）
    * Agent S（多智能体+规划）
    * Operator（OpenAI 的模拟人操作）

### 6.2 Success Rate Comparison

* **SR（成功率）**：完成任务的百分比
* **ACS（平均步骤数）**：完成任务需要多少 LLM 步骤，越少越高效

![](https://img.zhaoweiguo.com/uPic/2025/06/ajaXTo.jpg)

Table 1. Comparison of success rates (SR) across agents on WAA and OSWorld-W benchmarks.


* 🏆 成绩对比亮点
    * UFO2 全版本成功率远超所有对手，**最多高出一倍**（OSWorld-W）。
    * 即使是基础版（不加 API）也比现有最强的 Operator 更强。
    * 使用更强的 LLM（o1 模型）进一步拉大差距。
    * **优势场景**：浏览器任务（40%）、编程任务（58.3%）、Office 任务（51.9%）

* 失败主要分三类：
    1. **计划错误**：对任务理解不够，计划不合理。
    2. **执行错误**：计划对了，但操作错了，比如点错地方。
    3. **控件识别失败**：找不到需要操作的按钮或输入框，多见于自定义 UI。

> 最常见的失败原因是 **控件识别失败**，尤其是在不规范软件中（如 LibreOffice）。

![](https://img.zhaoweiguo.com/uPic/2025/06/IJ1UqK.jpg)

Table 2. SR breakdown by application type on WAA and OSWorld-W



### 6.3 Evaluation on Hybrid Control Detection

* 用 UIA + OmniParser（视觉识别）结合的方法，可以挽救 9.86% 的失败任务。
* 混合策略比单独使用任一方法都好，有效识别标准 + 非标准控件。
* 合并检测时，会自动去重，避免重复或误识。



### 6.4 Effectiveness of GUI + API Integration

* 在 Word、Excel、PPT 中手动开发了 12 个 API，用于简化复杂的 GUI 操作。
* 对比结果显示：加入 API 后任务成功率提升（GPT-4o 提升 6.1%，o1 提升 8.2%）。
* 原因：API 可绕过难以识别的控件（GPT-4o）或简化复杂操作（o1）。
* 任务执行步骤显著减少（o1 甚至减少了 58.5% 步数）。
* ✅ **结论**：API + GUI 的结合显著提高成功率和效率，是深度系统集成的关键。


### 6.5 Continuous Knowledge Integration Evaluation

* 给每个任务准备了帮助文档，同时记录成功执行过程，形成知识库。
* 在任务执行时检索相关文档或经验日志指导计划生成。
* 效果：最多可修复 17.7% 的计划错误，特别在使用强模型（如 o1）时效果更好。
* ✅ **结论**：动态知识增强让 UFO2 越用越聪明、越稳定，具备自我进化能力。


### 6.6 Effectiveness of Speculative Multi-Action Execution

* 比较一次一步 vs. 一次推测多步执行方式。
* 结果：成功率相当，但推测多步方式可减少最多 51.5% 的操作步骤（OSWorld-W）。
* ✅ **结论**：一步多做提升效率不牺牲准确性，极大节省 LLM 推理成本和延迟。


### 6.7 Operator as an AppAgent

* 把 OpenAI 的 Operator 作为 UFO2 的子智能体进行协作。
* 成效：在 WAA 中成功率提升（从 20.8% → 26.0%）。
* 原因：HostAgent 会拆分任务、减少干扰、优化视野。
* ✅ **结论**：UFO2 架构可兼容并强化已有智能体，体现“一切皆 Agent”的强大协作能力。


### 6.8 Efficiency Analysis

* **步骤数**：完整 UFO2 每个任务平均步骤数比基础版减少最多 50%。
* **延迟分析**：单步平均耗时约 10 秒，主要开销在 LLM 推理。
* GUI 控件识别增强只增加 1 秒延迟，换来识别准确性大幅提升。
* ✅ **结论**：即便增加视觉处理，整体执行时间仍维持在 1 分钟内，兼顾精度与效率。


### 6.9 Model Ablation

* 比较了 UFO2 用不同模型（GPT-4V、GPT-4o、Gemini 2.0、o1）时的表现。
* 带有内置推理能力的模型（如 o1）表现更好。
* ✅ **结论**：未来可通过增强“多步规划推理”的模型进一步提升自动化能力。


### 总结

* UFO2 的成功得益于以下几点：
    * 系统层深度集成（OS API + 应用 API）
    * 多智能体协同（HostAgent + AppAgents）
    * 混合视觉 + 接口操作方式
    * 灵活任务规划与执行
    * 对复杂、多步任务适应能力强

* 即使使用通用模型 GPT-4o，UFO2 架构也能击败专为自动化设计的系统，说明**架构设计优于模型优化**是成功关键。

> UFO2 通过深度系统集成（API + GUI + 知识 + 多智能体），结合推理能力强的模型，在任务成功率、执行效率和可扩展性上全面领先，是下一代桌面自动化的强力方案。


## 7.Discussion & Future Work

### ⏱️ 延迟与响应速度

* 目前 UFO2 每一步都需要调用大模型推理，**每次操作可能要几秒到几十秒**。
* 一些多步骤的复杂任务总耗时达 **1-2 分钟**，虽然还可以接受，但还是比不上人类。
* 为减少打扰，系统引入了 **画中画（PiP）模式**，在虚拟桌面中后台执行任务。
* **未来改进方向**：考虑使用更小、更快的推理模型（LAM），提升速度和扩展性。

### 🧠 接近人类水平的差距

* UFO2 还没完全达到人类水平，要**从两个方向改进**：
    1. **增强基础视觉语言模型**（比如 GPT-4V）：
       * 通过大量图形界面交互数据精调，提升泛化能力。
    2. **更深入的系统 API 与文档整合**：
       * 接入原生 API、结构化文档，帮助系统更准确理解任务上下文。

> 好消息是：UFO2 是模块化设计，可以**逐步升级**，不断接近人类水平。

### 💻 跨操作系统的通用性

* 虽然 UFO2 目前只支持 Windows（因市场占比超 70%），但架构本身是跨平台设计的。
* Windows 的 UIA 框架在 Linux 和 macOS 也有类似版本（AT-SPI 和 Accessibility API）。
* 所以 UFO2 的原理和结构**可以快速适配其他操作系统**。
* **未来目标**：打造成一个跨 Windows、Linux、macOS 的统一桌面自动化生态。


### ✅ 总结一句话：

> UFO2 目前虽表现出色，但还需在响应速度、模型能力和跨平台支持上进一步优化，未来目标是打造通用、高效、接近人类操作能力的跨平台自动化系统。


## 8.Related Work

### 8.1. Computer-Using Agents (CUAs)

* **CUAs（Computer-Using Agents）** 是指能像人一样在桌面操作系统上执行任务的 AI。
* **UFO（早期代表）**：利用多模态大模型（如 GPT-4V）+ UIA 接口来理解界面并执行任务，首创了多智能体结构，能处理跨应用和长流程任务。
* **后续系统**：
    * **CogAgent**：支持 PC、网页、Android 的多模态交互。
    * **Claude-3.5（Anthropic）**：完全基于截图来操作 GUI。
    * **Operator（OpenAI）**：用更强的多模态推理能力提升桌面自动化性能。

* ⚠️ **问题是**：这些系统大多是原型，**没有深入集成到操作系统或应用本身**。
* ✅ **UFO2 的不同点**：
    * 有模块化的 AgentOS 架构
    * 深度集成 OS 和应用 API
    * 视觉 + UI 混合识别
    * 可插拔、不中断系统运行


### 8.2. LLMs for Operating Systems

* **AIOS（Ge 等人提出）**：提出用 LLM 作为操作系统核心，通过自然语言“编程”操作系统。
* **Mei 等人实现的 AIOS 原型**：把 LLM 与系统核心功能（如进程调度、内存管理等）融合，还提供 SDK，简化 Agent 的开发。
* **Rama 等人**：基于 AIOS，加入语义化文件管理，进一步系统集成。
* **AutoOS**：用 LLM 自动优化 Linux 内核参数，提高系统效率。

* ✅ 这些研究都表明了一个趋势：**LLM 正逐步变成操作系统的核心组件**，实现更智能、自动化、用户友好的系统行为。

### 📌 UFO2 的位置：

> UFO2 继承了 CUAs 和 AIOS 两条研究路径的优点，专注于实际可落地的桌面自动化，采用深度系统集成 + 多模态 LLM + 多智能体协同，推动了“LLM + 操作系统”结合的落地实践。


## 9.Conclusion

* UFO2 是一个**实用的、深度集成操作系统的桌面自动化平台**（AgentOS），专为 Windows 环境设计。它解决了以往自动化系统（CUA）不稳定、难用的问题。
* **架构特点**：
    * 使用 **多智能体结构**：一个中心控制的 HostAgent + 多个负责具体应用的 AppAgent。
    * 每个 AppAgent 能同时使用 **GUI 操作 + 应用原生 API**，并自动吸收新知识，执行更稳更快。
    * 支持 **PiP（画中画）虚拟桌面**，用户和 Agent 可并行操作，互不干扰。
* **效果表现**：
    * 在 20 多个真实 Windows 应用中表现优异，**比现有最强系统更稳、更准、更易扩展**。
    * 即便使用像 GPT-4o 这种**通用模型**，也能超过专门优化的系统（如 Operator），说明系统架构非常关键。

* 一句话总结：
    * > **UFO2 将桌面自动化从实验原型带入实用阶段，靠的是强大的系统集成和多智能体设计，而不是单靠大模型。**





